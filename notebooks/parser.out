Grammar:

Rule 0     S' -> program
Rule 1     program -> empty
Rule 2     program -> statements
Rule 3     statements -> statements statement
Rule 4     statements -> statement
Rule 5     statement -> end_statement
Rule 6     statement -> begin_statement
Rule 7     statement -> expr SEP
Rule 8     statement -> var_assign SEP
Rule 9     statement -> LET var : var_type SEP
Rule 10    statement -> var_define SEP
Rule 11    statement -> class_definition
Rule 12    statement -> struct_definition
Rule 13    statement -> if_statement
Rule 14    statement -> for_statement
Rule 15    statement -> while_statement
Rule 16    statement -> return_statement
Rule 17    statement -> function_definition
Rule 18    statement -> import_statement
Rule 19    class_definition -> CLASS ID { function_definitions }
Rule 20    function_definitions -> function_definitions function_definition
Rule 21    function_definitions -> function_definition
Rule 22    function_definitions -> empty
Rule 23    struct_definition -> STRUCT ID { struct_fields } SEP
Rule 24    struct_fields -> struct_fields struct_field
Rule 25    struct_fields -> struct_field
Rule 26    struct_field -> LET ID : var_type SEP
Rule 27    var_type -> DICT_TYPE
Rule 28    var_type -> LIST_TYPE
Rule 29    var_type -> BOOL_TYPE
Rule 30    var_type -> STRING_TYPE
Rule 31    var_type -> FLOAT_TYPE
Rule 32    var_type -> INT_TYPE
Rule 33    import_statement -> IMPORT STRING SEP
Rule 34    function_definition -> FN ID ( params ) block
Rule 35    expr -> getter
Rule 36    expr -> { member_list }
Rule 37    expr -> NIL
Rule 38    expr -> var
Rule 39    expr -> var [ expr ]
Rule 40    expr -> list_val
Rule 41    expr -> FALSE
Rule 42    expr -> TRUE
Rule 43    expr -> STRING
Rule 44    expr -> FLOAT
Rule 45    expr -> INT
Rule 46    expr -> ( expr )
Rule 47    expr -> expr % expr  [precedence=left, level=11]
Rule 48    expr -> expr / expr  [precedence=left, level=11]
Rule 49    expr -> expr * expr  [precedence=left, level=11]
Rule 50    expr -> expr - expr  [precedence=left, level=10]
Rule 51    expr -> expr + expr  [precedence=left, level=10]
Rule 52    expr -> ! expr  [precedence=right, level=13]
Rule 53    expr -> + expr  [precedence=right, level=12]
Rule 54    expr -> - expr  [precedence=right, level=12]
Rule 55    expr -> ~ expr  [precedence=right, level=12]
Rule 56    expr -> expr | expr  [precedence=left, level=4]
Rule 57    expr -> expr ^ expr  [precedence=left, level=5]
Rule 58    expr -> expr & expr  [precedence=left, level=6]
Rule 59    expr -> expr SHR expr  [precedence=left, level=9]
Rule 60    expr -> expr SHL expr  [precedence=left, level=9]
Rule 61    expr -> expr GREATER expr  [precedence=left, level=8]
Rule 62    expr -> expr LESS expr  [precedence=left, level=8]
Rule 63    expr -> expr OR expr  [precedence=left, level=2]
Rule 64    expr -> expr AND expr  [precedence=left, level=3]
Rule 65    expr -> expr GREATEREQ expr  [precedence=left, level=8]
Rule 66    expr -> expr LESSEQ expr  [precedence=left, level=8]
Rule 67    expr -> expr NOTEQ expr  [precedence=left, level=7]
Rule 68    expr -> expr EQEQ expr  [precedence=left, level=7]
Rule 69    expr -> expr PIPE ID ( args )
Rule 70    expr -> ID DOUBLECOLON ID ( args )
Rule 71    expr -> ID ( args )
Rule 72    expr -> expr ? expr : expr
Rule 73    expr -> TYPEOF expr
Rule 74    expr -> LAMBDA ( params ) ARROW expr
Rule 75    expr -> ID LEFTARROW { struct_init_exprs }
Rule 76    struct_init_exprs -> struct_init_exprs , expr
Rule 77    struct_init_exprs -> expr
Rule 78    var_define -> LET getter ASSIGN expr
Rule 79    var_define -> LET var ASSIGN expr
Rule 80    return_statement -> RETURN expr SEP
Rule 81    var_assign -> DEC var  [precedence=right, level=12]
Rule 82    var_assign -> INC var  [precedence=right, level=12]
Rule 83    var_assign -> var SHRASGN expr  [precedence=right, level=1]
Rule 84    var_assign -> var SHLASGN expr  [precedence=right, level=1]
Rule 85    var_assign -> var XORASGN expr  [precedence=right, level=1]
Rule 86    var_assign -> var ORASGN expr  [precedence=right, level=1]
Rule 87    var_assign -> var ANDASGN expr  [precedence=right, level=1]
Rule 88    var_assign -> var MODULOASGN expr  [precedence=right, level=1]
Rule 89    var_assign -> var SLASHASGN expr  [precedence=right, level=1]
Rule 90    var_assign -> var STARASGN expr  [precedence=right, level=1]
Rule 91    var_assign -> var MINUSASGN expr  [precedence=right, level=1]
Rule 92    var_assign -> var PLUSASGN expr  [precedence=right, level=1]
Rule 93    var_assign -> var ASSIGN expr
Rule 94    if_statement -> IF expr block
Rule 95    if_statement -> IF expr block ELSE block
Rule 96    while_statement -> WHILE expr block
Rule 97    for_statement -> FOR var_assign SEP expr SEP var_assign block
Rule 98    list_val -> [ exprs ]
Rule 99    exprs -> exprs , expr
Rule 100   exprs -> expr
Rule 101   exprs -> empty
Rule 102   var -> var [ expr ]
Rule 103   var -> ID
Rule 104   empty -> <empty>
Rule 105   block -> statement
Rule 106   block -> { program }
Rule 107   params -> empty
Rule 108   params -> param
Rule 109   params -> params , param
Rule 110   param -> ID : var_type
Rule 111   args -> empty
Rule 112   args -> arg
Rule 113   args -> args , arg
Rule 114   arg -> expr
Rule 115   member_list -> member_list , member
Rule 116   member_list -> member
Rule 117   member_list -> empty
Rule 118   member -> STRING : expr
Rule 119   getter -> ID
Rule 120   getter -> getter . ID
Rule 121   begin_statement -> BEGIN
Rule 122   end_statement -> END

Terminals, with rules where they appear:

!                    : 52
%                    : 47
&                    : 58
(                    : 34 46 69 70 71 74
)                    : 34 46 69 70 71 74
*                    : 49
+                    : 51 53
,                    : 76 99 109 113 115
-                    : 50 54
.                    : 120
/                    : 48
:                    : 9 26 72 110 118
?                    : 72
AND                  : 64
ANDASGN              : 87
ARROW                : 74
ASSIGN               : 78 79 93
BEGIN                : 121
BOOL_TYPE            : 29
CLASS                : 19
DEC                  : 81
DICT_TYPE            : 27
DOUBLECOLON          : 70
ELSE                 : 95
END                  : 122
EQEQ                 : 68
FALSE                : 41
FLOAT                : 44
FLOAT_TYPE           : 31
FN                   : 34
FOR                  : 97
GREATER              : 61
GREATEREQ            : 65
ID                   : 19 23 26 34 69 70 70 71 75 103 110 119 120
IF                   : 94 95
IMPORT               : 33
INC                  : 82
INT                  : 45
INT_TYPE             : 32
LAMBDA               : 74
LEFTARROW            : 75
LESS                 : 62
LESSEQ               : 66
LET                  : 9 26 78 79
LIST_TYPE            : 28
MINUSASGN            : 91
MODULOASGN           : 88
NIL                  : 37
NOTEQ                : 67
OR                   : 63
ORASGN               : 86
PIPE                 : 69
PLUSASGN             : 92
RETURN               : 80
SEP                  : 7 8 9 10 23 26 33 80 97 97
SHL                  : 60
SHLASGN              : 84
SHR                  : 59
SHRASGN              : 83
SLASHASGN            : 89
STARASGN             : 90
STRING               : 33 43 118
STRING_TYPE          : 30
STRUCT               : 23
TRUE                 : 42
TYPEOF               : 73
WHILE                : 96
XORASGN              : 85
[                    : 39 98 102
]                    : 39 98 102
^                    : 57
error                : 
{                    : 19 23 36 75 106
|                    : 56
}                    : 19 23 36 75 106
~                    : 55

Nonterminals, with rules where they appear:

arg                  : 112 113
args                 : 69 70 71 113
begin_statement      : 6
block                : 34 94 95 95 96 97
class_definition     : 11
empty                : 1 22 101 107 111 117
end_statement        : 5
expr                 : 7 39 46 47 47 48 48 49 49 50 50 51 51 52 53 54 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 72 72 72 73 74 76 77 78 79 80 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 99 100 102 114 118
exprs                : 98 99
for_statement        : 14
function_definition  : 17 20 21
function_definitions : 19 20
getter               : 35 78 120
if_statement         : 13
import_statement     : 18
list_val             : 40
member               : 115 116
member_list          : 36 115
param                : 108 109
params               : 34 74 109
program              : 106 0
return_statement     : 16
statement            : 3 4 105
statements           : 2 3
struct_definition    : 12
struct_field         : 24 25
struct_fields        : 23 24
struct_init_exprs    : 75 76
var                  : 9 38 39 79 81 82 83 84 85 86 87 88 89 90 91 92 93 102
var_assign           : 8 97 97
var_define           : 10
var_type             : 9 26 110
while_statement      : 15


state 0

    (0) S' -> . program
    (1) program -> . empty
    (2) program -> . statements
    (104) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    $end            reduce using rule 104 (empty -> .)
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    program                        shift and go to state 1
    empty                          shift and go to state 2
    statements                     shift and go to state 3
    statement                      shift and go to state 4
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    expr                           shift and go to state 7
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 1

    (0) S' -> program .


state 2

    (1) program -> empty .
    $end            reduce using rule 1 (program -> empty .)


state 3

    (2) program -> statements .
    (3) statements -> statements . statement
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    $end            reduce using rule 2 (program -> statements .)
    }               reduce using rule 2 (program -> statements .)
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    statement                      shift and go to state 50
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    expr                           shift and go to state 7
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 4

    (4) statements -> statement .
    LET             reduce using rule 4 (statements -> statement .)
    END             reduce using rule 4 (statements -> statement .)
    BEGIN           reduce using rule 4 (statements -> statement .)
    {               reduce using rule 4 (statements -> statement .)
    NIL             reduce using rule 4 (statements -> statement .)
    FALSE           reduce using rule 4 (statements -> statement .)
    TRUE            reduce using rule 4 (statements -> statement .)
    STRING          reduce using rule 4 (statements -> statement .)
    FLOAT           reduce using rule 4 (statements -> statement .)
    INT             reduce using rule 4 (statements -> statement .)
    (               reduce using rule 4 (statements -> statement .)
    !               reduce using rule 4 (statements -> statement .)
    +               reduce using rule 4 (statements -> statement .)
    -               reduce using rule 4 (statements -> statement .)
    ~               reduce using rule 4 (statements -> statement .)
    ID              reduce using rule 4 (statements -> statement .)
    TYPEOF          reduce using rule 4 (statements -> statement .)
    LAMBDA          reduce using rule 4 (statements -> statement .)
    DEC             reduce using rule 4 (statements -> statement .)
    INC             reduce using rule 4 (statements -> statement .)
    CLASS           reduce using rule 4 (statements -> statement .)
    STRUCT          reduce using rule 4 (statements -> statement .)
    IF              reduce using rule 4 (statements -> statement .)
    FOR             reduce using rule 4 (statements -> statement .)
    WHILE           reduce using rule 4 (statements -> statement .)
    RETURN          reduce using rule 4 (statements -> statement .)
    FN              reduce using rule 4 (statements -> statement .)
    IMPORT          reduce using rule 4 (statements -> statement .)
    [               reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)
    }               reduce using rule 4 (statements -> statement .)


state 5

    (5) statement -> end_statement .
    LET             reduce using rule 5 (statement -> end_statement .)
    END             reduce using rule 5 (statement -> end_statement .)
    BEGIN           reduce using rule 5 (statement -> end_statement .)
    {               reduce using rule 5 (statement -> end_statement .)
    NIL             reduce using rule 5 (statement -> end_statement .)
    FALSE           reduce using rule 5 (statement -> end_statement .)
    TRUE            reduce using rule 5 (statement -> end_statement .)
    STRING          reduce using rule 5 (statement -> end_statement .)
    FLOAT           reduce using rule 5 (statement -> end_statement .)
    INT             reduce using rule 5 (statement -> end_statement .)
    (               reduce using rule 5 (statement -> end_statement .)
    !               reduce using rule 5 (statement -> end_statement .)
    +               reduce using rule 5 (statement -> end_statement .)
    -               reduce using rule 5 (statement -> end_statement .)
    ~               reduce using rule 5 (statement -> end_statement .)
    ID              reduce using rule 5 (statement -> end_statement .)
    TYPEOF          reduce using rule 5 (statement -> end_statement .)
    LAMBDA          reduce using rule 5 (statement -> end_statement .)
    DEC             reduce using rule 5 (statement -> end_statement .)
    INC             reduce using rule 5 (statement -> end_statement .)
    CLASS           reduce using rule 5 (statement -> end_statement .)
    STRUCT          reduce using rule 5 (statement -> end_statement .)
    IF              reduce using rule 5 (statement -> end_statement .)
    FOR             reduce using rule 5 (statement -> end_statement .)
    WHILE           reduce using rule 5 (statement -> end_statement .)
    RETURN          reduce using rule 5 (statement -> end_statement .)
    FN              reduce using rule 5 (statement -> end_statement .)
    IMPORT          reduce using rule 5 (statement -> end_statement .)
    [               reduce using rule 5 (statement -> end_statement .)
    $end            reduce using rule 5 (statement -> end_statement .)
    }               reduce using rule 5 (statement -> end_statement .)
    ELSE            reduce using rule 5 (statement -> end_statement .)


state 6

    (6) statement -> begin_statement .
    LET             reduce using rule 6 (statement -> begin_statement .)
    END             reduce using rule 6 (statement -> begin_statement .)
    BEGIN           reduce using rule 6 (statement -> begin_statement .)
    {               reduce using rule 6 (statement -> begin_statement .)
    NIL             reduce using rule 6 (statement -> begin_statement .)
    FALSE           reduce using rule 6 (statement -> begin_statement .)
    TRUE            reduce using rule 6 (statement -> begin_statement .)
    STRING          reduce using rule 6 (statement -> begin_statement .)
    FLOAT           reduce using rule 6 (statement -> begin_statement .)
    INT             reduce using rule 6 (statement -> begin_statement .)
    (               reduce using rule 6 (statement -> begin_statement .)
    !               reduce using rule 6 (statement -> begin_statement .)
    +               reduce using rule 6 (statement -> begin_statement .)
    -               reduce using rule 6 (statement -> begin_statement .)
    ~               reduce using rule 6 (statement -> begin_statement .)
    ID              reduce using rule 6 (statement -> begin_statement .)
    TYPEOF          reduce using rule 6 (statement -> begin_statement .)
    LAMBDA          reduce using rule 6 (statement -> begin_statement .)
    DEC             reduce using rule 6 (statement -> begin_statement .)
    INC             reduce using rule 6 (statement -> begin_statement .)
    CLASS           reduce using rule 6 (statement -> begin_statement .)
    STRUCT          reduce using rule 6 (statement -> begin_statement .)
    IF              reduce using rule 6 (statement -> begin_statement .)
    FOR             reduce using rule 6 (statement -> begin_statement .)
    WHILE           reduce using rule 6 (statement -> begin_statement .)
    RETURN          reduce using rule 6 (statement -> begin_statement .)
    FN              reduce using rule 6 (statement -> begin_statement .)
    IMPORT          reduce using rule 6 (statement -> begin_statement .)
    [               reduce using rule 6 (statement -> begin_statement .)
    $end            reduce using rule 6 (statement -> begin_statement .)
    }               reduce using rule 6 (statement -> begin_statement .)
    ELSE            reduce using rule 6 (statement -> begin_statement .)


state 7

    (7) statement -> expr . SEP
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             shift and go to state 51
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 8

    (8) statement -> var_assign . SEP
    SEP             shift and go to state 72


state 9

    (9) statement -> LET . var : var_type SEP
    (78) var_define -> LET . getter ASSIGN expr
    (79) var_define -> LET . var ASSIGN expr
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (119) getter -> . ID
    (120) getter -> . getter . ID
    ID              shift and go to state 75

    var                            shift and go to state 73
    getter                         shift and go to state 74

state 10

    (38) expr -> var .
    (39) expr -> var . [ expr ]
    (83) var_assign -> var . SHRASGN expr
    (84) var_assign -> var . SHLASGN expr
    (85) var_assign -> var . XORASGN expr
    (86) var_assign -> var . ORASGN expr
    (87) var_assign -> var . ANDASGN expr
    (88) var_assign -> var . MODULOASGN expr
    (89) var_assign -> var . SLASHASGN expr
    (90) var_assign -> var . STARASGN expr
    (91) var_assign -> var . MINUSASGN expr
    (92) var_assign -> var . PLUSASGN expr
    (93) var_assign -> var . ASSIGN expr
    (102) var -> var . [ expr ]
    SEP             reduce using rule 38 (expr -> var .)
    %               reduce using rule 38 (expr -> var .)
    /               reduce using rule 38 (expr -> var .)
    *               reduce using rule 38 (expr -> var .)
    -               reduce using rule 38 (expr -> var .)
    +               reduce using rule 38 (expr -> var .)
    |               reduce using rule 38 (expr -> var .)
    ^               reduce using rule 38 (expr -> var .)
    &               reduce using rule 38 (expr -> var .)
    SHR             reduce using rule 38 (expr -> var .)
    SHL             reduce using rule 38 (expr -> var .)
    GREATER         reduce using rule 38 (expr -> var .)
    LESS            reduce using rule 38 (expr -> var .)
    OR              reduce using rule 38 (expr -> var .)
    AND             reduce using rule 38 (expr -> var .)
    GREATEREQ       reduce using rule 38 (expr -> var .)
    LESSEQ          reduce using rule 38 (expr -> var .)
    NOTEQ           reduce using rule 38 (expr -> var .)
    EQEQ            reduce using rule 38 (expr -> var .)
    PIPE            reduce using rule 38 (expr -> var .)
    ?               reduce using rule 38 (expr -> var .)
    [               shift and go to state 76
    SHRASGN         shift and go to state 77
    SHLASGN         shift and go to state 78
    XORASGN         shift and go to state 79
    ORASGN          shift and go to state 80
    ANDASGN         shift and go to state 81
    MODULOASGN      shift and go to state 82
    SLASHASGN       shift and go to state 83
    STARASGN        shift and go to state 84
    MINUSASGN       shift and go to state 85
    PLUSASGN        shift and go to state 86
    ASSIGN          shift and go to state 87


state 11

    (10) statement -> var_define . SEP
    SEP             shift and go to state 88


state 12

    (11) statement -> class_definition .
    LET             reduce using rule 11 (statement -> class_definition .)
    END             reduce using rule 11 (statement -> class_definition .)
    BEGIN           reduce using rule 11 (statement -> class_definition .)
    {               reduce using rule 11 (statement -> class_definition .)
    NIL             reduce using rule 11 (statement -> class_definition .)
    FALSE           reduce using rule 11 (statement -> class_definition .)
    TRUE            reduce using rule 11 (statement -> class_definition .)
    STRING          reduce using rule 11 (statement -> class_definition .)
    FLOAT           reduce using rule 11 (statement -> class_definition .)
    INT             reduce using rule 11 (statement -> class_definition .)
    (               reduce using rule 11 (statement -> class_definition .)
    !               reduce using rule 11 (statement -> class_definition .)
    +               reduce using rule 11 (statement -> class_definition .)
    -               reduce using rule 11 (statement -> class_definition .)
    ~               reduce using rule 11 (statement -> class_definition .)
    ID              reduce using rule 11 (statement -> class_definition .)
    TYPEOF          reduce using rule 11 (statement -> class_definition .)
    LAMBDA          reduce using rule 11 (statement -> class_definition .)
    DEC             reduce using rule 11 (statement -> class_definition .)
    INC             reduce using rule 11 (statement -> class_definition .)
    CLASS           reduce using rule 11 (statement -> class_definition .)
    STRUCT          reduce using rule 11 (statement -> class_definition .)
    IF              reduce using rule 11 (statement -> class_definition .)
    FOR             reduce using rule 11 (statement -> class_definition .)
    WHILE           reduce using rule 11 (statement -> class_definition .)
    RETURN          reduce using rule 11 (statement -> class_definition .)
    FN              reduce using rule 11 (statement -> class_definition .)
    IMPORT          reduce using rule 11 (statement -> class_definition .)
    [               reduce using rule 11 (statement -> class_definition .)
    $end            reduce using rule 11 (statement -> class_definition .)
    }               reduce using rule 11 (statement -> class_definition .)
    ELSE            reduce using rule 11 (statement -> class_definition .)


state 13

    (12) statement -> struct_definition .
    LET             reduce using rule 12 (statement -> struct_definition .)
    END             reduce using rule 12 (statement -> struct_definition .)
    BEGIN           reduce using rule 12 (statement -> struct_definition .)
    {               reduce using rule 12 (statement -> struct_definition .)
    NIL             reduce using rule 12 (statement -> struct_definition .)
    FALSE           reduce using rule 12 (statement -> struct_definition .)
    TRUE            reduce using rule 12 (statement -> struct_definition .)
    STRING          reduce using rule 12 (statement -> struct_definition .)
    FLOAT           reduce using rule 12 (statement -> struct_definition .)
    INT             reduce using rule 12 (statement -> struct_definition .)
    (               reduce using rule 12 (statement -> struct_definition .)
    !               reduce using rule 12 (statement -> struct_definition .)
    +               reduce using rule 12 (statement -> struct_definition .)
    -               reduce using rule 12 (statement -> struct_definition .)
    ~               reduce using rule 12 (statement -> struct_definition .)
    ID              reduce using rule 12 (statement -> struct_definition .)
    TYPEOF          reduce using rule 12 (statement -> struct_definition .)
    LAMBDA          reduce using rule 12 (statement -> struct_definition .)
    DEC             reduce using rule 12 (statement -> struct_definition .)
    INC             reduce using rule 12 (statement -> struct_definition .)
    CLASS           reduce using rule 12 (statement -> struct_definition .)
    STRUCT          reduce using rule 12 (statement -> struct_definition .)
    IF              reduce using rule 12 (statement -> struct_definition .)
    FOR             reduce using rule 12 (statement -> struct_definition .)
    WHILE           reduce using rule 12 (statement -> struct_definition .)
    RETURN          reduce using rule 12 (statement -> struct_definition .)
    FN              reduce using rule 12 (statement -> struct_definition .)
    IMPORT          reduce using rule 12 (statement -> struct_definition .)
    [               reduce using rule 12 (statement -> struct_definition .)
    $end            reduce using rule 12 (statement -> struct_definition .)
    }               reduce using rule 12 (statement -> struct_definition .)
    ELSE            reduce using rule 12 (statement -> struct_definition .)


state 14

    (13) statement -> if_statement .
    LET             reduce using rule 13 (statement -> if_statement .)
    END             reduce using rule 13 (statement -> if_statement .)
    BEGIN           reduce using rule 13 (statement -> if_statement .)
    {               reduce using rule 13 (statement -> if_statement .)
    NIL             reduce using rule 13 (statement -> if_statement .)
    FALSE           reduce using rule 13 (statement -> if_statement .)
    TRUE            reduce using rule 13 (statement -> if_statement .)
    STRING          reduce using rule 13 (statement -> if_statement .)
    FLOAT           reduce using rule 13 (statement -> if_statement .)
    INT             reduce using rule 13 (statement -> if_statement .)
    (               reduce using rule 13 (statement -> if_statement .)
    !               reduce using rule 13 (statement -> if_statement .)
    +               reduce using rule 13 (statement -> if_statement .)
    -               reduce using rule 13 (statement -> if_statement .)
    ~               reduce using rule 13 (statement -> if_statement .)
    ID              reduce using rule 13 (statement -> if_statement .)
    TYPEOF          reduce using rule 13 (statement -> if_statement .)
    LAMBDA          reduce using rule 13 (statement -> if_statement .)
    DEC             reduce using rule 13 (statement -> if_statement .)
    INC             reduce using rule 13 (statement -> if_statement .)
    CLASS           reduce using rule 13 (statement -> if_statement .)
    STRUCT          reduce using rule 13 (statement -> if_statement .)
    IF              reduce using rule 13 (statement -> if_statement .)
    FOR             reduce using rule 13 (statement -> if_statement .)
    WHILE           reduce using rule 13 (statement -> if_statement .)
    RETURN          reduce using rule 13 (statement -> if_statement .)
    FN              reduce using rule 13 (statement -> if_statement .)
    IMPORT          reduce using rule 13 (statement -> if_statement .)
    [               reduce using rule 13 (statement -> if_statement .)
    $end            reduce using rule 13 (statement -> if_statement .)
    }               reduce using rule 13 (statement -> if_statement .)
    ELSE            reduce using rule 13 (statement -> if_statement .)


state 15

    (14) statement -> for_statement .
    LET             reduce using rule 14 (statement -> for_statement .)
    END             reduce using rule 14 (statement -> for_statement .)
    BEGIN           reduce using rule 14 (statement -> for_statement .)
    {               reduce using rule 14 (statement -> for_statement .)
    NIL             reduce using rule 14 (statement -> for_statement .)
    FALSE           reduce using rule 14 (statement -> for_statement .)
    TRUE            reduce using rule 14 (statement -> for_statement .)
    STRING          reduce using rule 14 (statement -> for_statement .)
    FLOAT           reduce using rule 14 (statement -> for_statement .)
    INT             reduce using rule 14 (statement -> for_statement .)
    (               reduce using rule 14 (statement -> for_statement .)
    !               reduce using rule 14 (statement -> for_statement .)
    +               reduce using rule 14 (statement -> for_statement .)
    -               reduce using rule 14 (statement -> for_statement .)
    ~               reduce using rule 14 (statement -> for_statement .)
    ID              reduce using rule 14 (statement -> for_statement .)
    TYPEOF          reduce using rule 14 (statement -> for_statement .)
    LAMBDA          reduce using rule 14 (statement -> for_statement .)
    DEC             reduce using rule 14 (statement -> for_statement .)
    INC             reduce using rule 14 (statement -> for_statement .)
    CLASS           reduce using rule 14 (statement -> for_statement .)
    STRUCT          reduce using rule 14 (statement -> for_statement .)
    IF              reduce using rule 14 (statement -> for_statement .)
    FOR             reduce using rule 14 (statement -> for_statement .)
    WHILE           reduce using rule 14 (statement -> for_statement .)
    RETURN          reduce using rule 14 (statement -> for_statement .)
    FN              reduce using rule 14 (statement -> for_statement .)
    IMPORT          reduce using rule 14 (statement -> for_statement .)
    [               reduce using rule 14 (statement -> for_statement .)
    $end            reduce using rule 14 (statement -> for_statement .)
    }               reduce using rule 14 (statement -> for_statement .)
    ELSE            reduce using rule 14 (statement -> for_statement .)


state 16

    (15) statement -> while_statement .
    LET             reduce using rule 15 (statement -> while_statement .)
    END             reduce using rule 15 (statement -> while_statement .)
    BEGIN           reduce using rule 15 (statement -> while_statement .)
    {               reduce using rule 15 (statement -> while_statement .)
    NIL             reduce using rule 15 (statement -> while_statement .)
    FALSE           reduce using rule 15 (statement -> while_statement .)
    TRUE            reduce using rule 15 (statement -> while_statement .)
    STRING          reduce using rule 15 (statement -> while_statement .)
    FLOAT           reduce using rule 15 (statement -> while_statement .)
    INT             reduce using rule 15 (statement -> while_statement .)
    (               reduce using rule 15 (statement -> while_statement .)
    !               reduce using rule 15 (statement -> while_statement .)
    +               reduce using rule 15 (statement -> while_statement .)
    -               reduce using rule 15 (statement -> while_statement .)
    ~               reduce using rule 15 (statement -> while_statement .)
    ID              reduce using rule 15 (statement -> while_statement .)
    TYPEOF          reduce using rule 15 (statement -> while_statement .)
    LAMBDA          reduce using rule 15 (statement -> while_statement .)
    DEC             reduce using rule 15 (statement -> while_statement .)
    INC             reduce using rule 15 (statement -> while_statement .)
    CLASS           reduce using rule 15 (statement -> while_statement .)
    STRUCT          reduce using rule 15 (statement -> while_statement .)
    IF              reduce using rule 15 (statement -> while_statement .)
    FOR             reduce using rule 15 (statement -> while_statement .)
    WHILE           reduce using rule 15 (statement -> while_statement .)
    RETURN          reduce using rule 15 (statement -> while_statement .)
    FN              reduce using rule 15 (statement -> while_statement .)
    IMPORT          reduce using rule 15 (statement -> while_statement .)
    [               reduce using rule 15 (statement -> while_statement .)
    $end            reduce using rule 15 (statement -> while_statement .)
    }               reduce using rule 15 (statement -> while_statement .)
    ELSE            reduce using rule 15 (statement -> while_statement .)


state 17

    (16) statement -> return_statement .
    LET             reduce using rule 16 (statement -> return_statement .)
    END             reduce using rule 16 (statement -> return_statement .)
    BEGIN           reduce using rule 16 (statement -> return_statement .)
    {               reduce using rule 16 (statement -> return_statement .)
    NIL             reduce using rule 16 (statement -> return_statement .)
    FALSE           reduce using rule 16 (statement -> return_statement .)
    TRUE            reduce using rule 16 (statement -> return_statement .)
    STRING          reduce using rule 16 (statement -> return_statement .)
    FLOAT           reduce using rule 16 (statement -> return_statement .)
    INT             reduce using rule 16 (statement -> return_statement .)
    (               reduce using rule 16 (statement -> return_statement .)
    !               reduce using rule 16 (statement -> return_statement .)
    +               reduce using rule 16 (statement -> return_statement .)
    -               reduce using rule 16 (statement -> return_statement .)
    ~               reduce using rule 16 (statement -> return_statement .)
    ID              reduce using rule 16 (statement -> return_statement .)
    TYPEOF          reduce using rule 16 (statement -> return_statement .)
    LAMBDA          reduce using rule 16 (statement -> return_statement .)
    DEC             reduce using rule 16 (statement -> return_statement .)
    INC             reduce using rule 16 (statement -> return_statement .)
    CLASS           reduce using rule 16 (statement -> return_statement .)
    STRUCT          reduce using rule 16 (statement -> return_statement .)
    IF              reduce using rule 16 (statement -> return_statement .)
    FOR             reduce using rule 16 (statement -> return_statement .)
    WHILE           reduce using rule 16 (statement -> return_statement .)
    RETURN          reduce using rule 16 (statement -> return_statement .)
    FN              reduce using rule 16 (statement -> return_statement .)
    IMPORT          reduce using rule 16 (statement -> return_statement .)
    [               reduce using rule 16 (statement -> return_statement .)
    $end            reduce using rule 16 (statement -> return_statement .)
    }               reduce using rule 16 (statement -> return_statement .)
    ELSE            reduce using rule 16 (statement -> return_statement .)


state 18

    (17) statement -> function_definition .
    LET             reduce using rule 17 (statement -> function_definition .)
    END             reduce using rule 17 (statement -> function_definition .)
    BEGIN           reduce using rule 17 (statement -> function_definition .)
    {               reduce using rule 17 (statement -> function_definition .)
    NIL             reduce using rule 17 (statement -> function_definition .)
    FALSE           reduce using rule 17 (statement -> function_definition .)
    TRUE            reduce using rule 17 (statement -> function_definition .)
    STRING          reduce using rule 17 (statement -> function_definition .)
    FLOAT           reduce using rule 17 (statement -> function_definition .)
    INT             reduce using rule 17 (statement -> function_definition .)
    (               reduce using rule 17 (statement -> function_definition .)
    !               reduce using rule 17 (statement -> function_definition .)
    +               reduce using rule 17 (statement -> function_definition .)
    -               reduce using rule 17 (statement -> function_definition .)
    ~               reduce using rule 17 (statement -> function_definition .)
    ID              reduce using rule 17 (statement -> function_definition .)
    TYPEOF          reduce using rule 17 (statement -> function_definition .)
    LAMBDA          reduce using rule 17 (statement -> function_definition .)
    DEC             reduce using rule 17 (statement -> function_definition .)
    INC             reduce using rule 17 (statement -> function_definition .)
    CLASS           reduce using rule 17 (statement -> function_definition .)
    STRUCT          reduce using rule 17 (statement -> function_definition .)
    IF              reduce using rule 17 (statement -> function_definition .)
    FOR             reduce using rule 17 (statement -> function_definition .)
    WHILE           reduce using rule 17 (statement -> function_definition .)
    RETURN          reduce using rule 17 (statement -> function_definition .)
    FN              reduce using rule 17 (statement -> function_definition .)
    IMPORT          reduce using rule 17 (statement -> function_definition .)
    [               reduce using rule 17 (statement -> function_definition .)
    $end            reduce using rule 17 (statement -> function_definition .)
    }               reduce using rule 17 (statement -> function_definition .)
    ELSE            reduce using rule 17 (statement -> function_definition .)


state 19

    (18) statement -> import_statement .
    LET             reduce using rule 18 (statement -> import_statement .)
    END             reduce using rule 18 (statement -> import_statement .)
    BEGIN           reduce using rule 18 (statement -> import_statement .)
    {               reduce using rule 18 (statement -> import_statement .)
    NIL             reduce using rule 18 (statement -> import_statement .)
    FALSE           reduce using rule 18 (statement -> import_statement .)
    TRUE            reduce using rule 18 (statement -> import_statement .)
    STRING          reduce using rule 18 (statement -> import_statement .)
    FLOAT           reduce using rule 18 (statement -> import_statement .)
    INT             reduce using rule 18 (statement -> import_statement .)
    (               reduce using rule 18 (statement -> import_statement .)
    !               reduce using rule 18 (statement -> import_statement .)
    +               reduce using rule 18 (statement -> import_statement .)
    -               reduce using rule 18 (statement -> import_statement .)
    ~               reduce using rule 18 (statement -> import_statement .)
    ID              reduce using rule 18 (statement -> import_statement .)
    TYPEOF          reduce using rule 18 (statement -> import_statement .)
    LAMBDA          reduce using rule 18 (statement -> import_statement .)
    DEC             reduce using rule 18 (statement -> import_statement .)
    INC             reduce using rule 18 (statement -> import_statement .)
    CLASS           reduce using rule 18 (statement -> import_statement .)
    STRUCT          reduce using rule 18 (statement -> import_statement .)
    IF              reduce using rule 18 (statement -> import_statement .)
    FOR             reduce using rule 18 (statement -> import_statement .)
    WHILE           reduce using rule 18 (statement -> import_statement .)
    RETURN          reduce using rule 18 (statement -> import_statement .)
    FN              reduce using rule 18 (statement -> import_statement .)
    IMPORT          reduce using rule 18 (statement -> import_statement .)
    [               reduce using rule 18 (statement -> import_statement .)
    $end            reduce using rule 18 (statement -> import_statement .)
    }               reduce using rule 18 (statement -> import_statement .)
    ELSE            reduce using rule 18 (statement -> import_statement .)


state 20

    (122) end_statement -> END .
    LET             reduce using rule 122 (end_statement -> END .)
    END             reduce using rule 122 (end_statement -> END .)
    BEGIN           reduce using rule 122 (end_statement -> END .)
    {               reduce using rule 122 (end_statement -> END .)
    NIL             reduce using rule 122 (end_statement -> END .)
    FALSE           reduce using rule 122 (end_statement -> END .)
    TRUE            reduce using rule 122 (end_statement -> END .)
    STRING          reduce using rule 122 (end_statement -> END .)
    FLOAT           reduce using rule 122 (end_statement -> END .)
    INT             reduce using rule 122 (end_statement -> END .)
    (               reduce using rule 122 (end_statement -> END .)
    !               reduce using rule 122 (end_statement -> END .)
    +               reduce using rule 122 (end_statement -> END .)
    -               reduce using rule 122 (end_statement -> END .)
    ~               reduce using rule 122 (end_statement -> END .)
    ID              reduce using rule 122 (end_statement -> END .)
    TYPEOF          reduce using rule 122 (end_statement -> END .)
    LAMBDA          reduce using rule 122 (end_statement -> END .)
    DEC             reduce using rule 122 (end_statement -> END .)
    INC             reduce using rule 122 (end_statement -> END .)
    CLASS           reduce using rule 122 (end_statement -> END .)
    STRUCT          reduce using rule 122 (end_statement -> END .)
    IF              reduce using rule 122 (end_statement -> END .)
    FOR             reduce using rule 122 (end_statement -> END .)
    WHILE           reduce using rule 122 (end_statement -> END .)
    RETURN          reduce using rule 122 (end_statement -> END .)
    FN              reduce using rule 122 (end_statement -> END .)
    IMPORT          reduce using rule 122 (end_statement -> END .)
    [               reduce using rule 122 (end_statement -> END .)
    $end            reduce using rule 122 (end_statement -> END .)
    }               reduce using rule 122 (end_statement -> END .)
    ELSE            reduce using rule 122 (end_statement -> END .)


state 21

    (121) begin_statement -> BEGIN .
    LET             reduce using rule 121 (begin_statement -> BEGIN .)
    END             reduce using rule 121 (begin_statement -> BEGIN .)
    BEGIN           reduce using rule 121 (begin_statement -> BEGIN .)
    {               reduce using rule 121 (begin_statement -> BEGIN .)
    NIL             reduce using rule 121 (begin_statement -> BEGIN .)
    FALSE           reduce using rule 121 (begin_statement -> BEGIN .)
    TRUE            reduce using rule 121 (begin_statement -> BEGIN .)
    STRING          reduce using rule 121 (begin_statement -> BEGIN .)
    FLOAT           reduce using rule 121 (begin_statement -> BEGIN .)
    INT             reduce using rule 121 (begin_statement -> BEGIN .)
    (               reduce using rule 121 (begin_statement -> BEGIN .)
    !               reduce using rule 121 (begin_statement -> BEGIN .)
    +               reduce using rule 121 (begin_statement -> BEGIN .)
    -               reduce using rule 121 (begin_statement -> BEGIN .)
    ~               reduce using rule 121 (begin_statement -> BEGIN .)
    ID              reduce using rule 121 (begin_statement -> BEGIN .)
    TYPEOF          reduce using rule 121 (begin_statement -> BEGIN .)
    LAMBDA          reduce using rule 121 (begin_statement -> BEGIN .)
    DEC             reduce using rule 121 (begin_statement -> BEGIN .)
    INC             reduce using rule 121 (begin_statement -> BEGIN .)
    CLASS           reduce using rule 121 (begin_statement -> BEGIN .)
    STRUCT          reduce using rule 121 (begin_statement -> BEGIN .)
    IF              reduce using rule 121 (begin_statement -> BEGIN .)
    FOR             reduce using rule 121 (begin_statement -> BEGIN .)
    WHILE           reduce using rule 121 (begin_statement -> BEGIN .)
    RETURN          reduce using rule 121 (begin_statement -> BEGIN .)
    FN              reduce using rule 121 (begin_statement -> BEGIN .)
    IMPORT          reduce using rule 121 (begin_statement -> BEGIN .)
    [               reduce using rule 121 (begin_statement -> BEGIN .)
    $end            reduce using rule 121 (begin_statement -> BEGIN .)
    }               reduce using rule 121 (begin_statement -> BEGIN .)
    ELSE            reduce using rule 121 (begin_statement -> BEGIN .)


state 22

    (35) expr -> getter .
    (120) getter -> getter . . ID
    SEP             reduce using rule 35 (expr -> getter .)
    %               reduce using rule 35 (expr -> getter .)
    /               reduce using rule 35 (expr -> getter .)
    *               reduce using rule 35 (expr -> getter .)
    -               reduce using rule 35 (expr -> getter .)
    +               reduce using rule 35 (expr -> getter .)
    |               reduce using rule 35 (expr -> getter .)
    ^               reduce using rule 35 (expr -> getter .)
    &               reduce using rule 35 (expr -> getter .)
    SHR             reduce using rule 35 (expr -> getter .)
    SHL             reduce using rule 35 (expr -> getter .)
    GREATER         reduce using rule 35 (expr -> getter .)
    LESS            reduce using rule 35 (expr -> getter .)
    OR              reduce using rule 35 (expr -> getter .)
    AND             reduce using rule 35 (expr -> getter .)
    GREATEREQ       reduce using rule 35 (expr -> getter .)
    LESSEQ          reduce using rule 35 (expr -> getter .)
    NOTEQ           reduce using rule 35 (expr -> getter .)
    EQEQ            reduce using rule 35 (expr -> getter .)
    PIPE            reduce using rule 35 (expr -> getter .)
    ?               reduce using rule 35 (expr -> getter .)
    ]               reduce using rule 35 (expr -> getter .)
    ,               reduce using rule 35 (expr -> getter .)
    )               reduce using rule 35 (expr -> getter .)
    {               reduce using rule 35 (expr -> getter .)
    LET             reduce using rule 35 (expr -> getter .)
    END             reduce using rule 35 (expr -> getter .)
    BEGIN           reduce using rule 35 (expr -> getter .)
    NIL             reduce using rule 35 (expr -> getter .)
    FALSE           reduce using rule 35 (expr -> getter .)
    TRUE            reduce using rule 35 (expr -> getter .)
    STRING          reduce using rule 35 (expr -> getter .)
    FLOAT           reduce using rule 35 (expr -> getter .)
    INT             reduce using rule 35 (expr -> getter .)
    (               reduce using rule 35 (expr -> getter .)
    !               reduce using rule 35 (expr -> getter .)
    ~               reduce using rule 35 (expr -> getter .)
    ID              reduce using rule 35 (expr -> getter .)
    TYPEOF          reduce using rule 35 (expr -> getter .)
    LAMBDA          reduce using rule 35 (expr -> getter .)
    DEC             reduce using rule 35 (expr -> getter .)
    INC             reduce using rule 35 (expr -> getter .)
    CLASS           reduce using rule 35 (expr -> getter .)
    STRUCT          reduce using rule 35 (expr -> getter .)
    IF              reduce using rule 35 (expr -> getter .)
    FOR             reduce using rule 35 (expr -> getter .)
    WHILE           reduce using rule 35 (expr -> getter .)
    RETURN          reduce using rule 35 (expr -> getter .)
    FN              reduce using rule 35 (expr -> getter .)
    IMPORT          reduce using rule 35 (expr -> getter .)
    [               reduce using rule 35 (expr -> getter .)
    :               reduce using rule 35 (expr -> getter .)
    }               reduce using rule 35 (expr -> getter .)
    .               shift and go to state 89


state 23

    (36) expr -> { . member_list }
    (115) member_list -> . member_list , member
    (116) member_list -> . member
    (117) member_list -> . empty
    (118) member -> . STRING : expr
    (104) empty -> .
    STRING          shift and go to state 93
    }               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)

    member_list                    shift and go to state 90
    member                         shift and go to state 91
    empty                          shift and go to state 92

state 24

    (37) expr -> NIL .
    SEP             reduce using rule 37 (expr -> NIL .)
    %               reduce using rule 37 (expr -> NIL .)
    /               reduce using rule 37 (expr -> NIL .)
    *               reduce using rule 37 (expr -> NIL .)
    -               reduce using rule 37 (expr -> NIL .)
    +               reduce using rule 37 (expr -> NIL .)
    |               reduce using rule 37 (expr -> NIL .)
    ^               reduce using rule 37 (expr -> NIL .)
    &               reduce using rule 37 (expr -> NIL .)
    SHR             reduce using rule 37 (expr -> NIL .)
    SHL             reduce using rule 37 (expr -> NIL .)
    GREATER         reduce using rule 37 (expr -> NIL .)
    LESS            reduce using rule 37 (expr -> NIL .)
    OR              reduce using rule 37 (expr -> NIL .)
    AND             reduce using rule 37 (expr -> NIL .)
    GREATEREQ       reduce using rule 37 (expr -> NIL .)
    LESSEQ          reduce using rule 37 (expr -> NIL .)
    NOTEQ           reduce using rule 37 (expr -> NIL .)
    EQEQ            reduce using rule 37 (expr -> NIL .)
    PIPE            reduce using rule 37 (expr -> NIL .)
    ?               reduce using rule 37 (expr -> NIL .)
    ]               reduce using rule 37 (expr -> NIL .)
    ,               reduce using rule 37 (expr -> NIL .)
    )               reduce using rule 37 (expr -> NIL .)
    {               reduce using rule 37 (expr -> NIL .)
    LET             reduce using rule 37 (expr -> NIL .)
    END             reduce using rule 37 (expr -> NIL .)
    BEGIN           reduce using rule 37 (expr -> NIL .)
    NIL             reduce using rule 37 (expr -> NIL .)
    FALSE           reduce using rule 37 (expr -> NIL .)
    TRUE            reduce using rule 37 (expr -> NIL .)
    STRING          reduce using rule 37 (expr -> NIL .)
    FLOAT           reduce using rule 37 (expr -> NIL .)
    INT             reduce using rule 37 (expr -> NIL .)
    (               reduce using rule 37 (expr -> NIL .)
    !               reduce using rule 37 (expr -> NIL .)
    ~               reduce using rule 37 (expr -> NIL .)
    ID              reduce using rule 37 (expr -> NIL .)
    TYPEOF          reduce using rule 37 (expr -> NIL .)
    LAMBDA          reduce using rule 37 (expr -> NIL .)
    DEC             reduce using rule 37 (expr -> NIL .)
    INC             reduce using rule 37 (expr -> NIL .)
    CLASS           reduce using rule 37 (expr -> NIL .)
    STRUCT          reduce using rule 37 (expr -> NIL .)
    IF              reduce using rule 37 (expr -> NIL .)
    FOR             reduce using rule 37 (expr -> NIL .)
    WHILE           reduce using rule 37 (expr -> NIL .)
    RETURN          reduce using rule 37 (expr -> NIL .)
    FN              reduce using rule 37 (expr -> NIL .)
    IMPORT          reduce using rule 37 (expr -> NIL .)
    [               reduce using rule 37 (expr -> NIL .)
    :               reduce using rule 37 (expr -> NIL .)
    }               reduce using rule 37 (expr -> NIL .)


state 25

    (98) list_val -> [ . exprs ]
    (99) exprs -> . exprs , expr
    (100) exprs -> . expr
    (101) exprs -> . empty
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (104) empty -> .
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    ]               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    [               shift and go to state 25

    exprs                          shift and go to state 94
    expr                           shift and go to state 95
    empty                          shift and go to state 96
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 26

    (40) expr -> list_val .
    SEP             reduce using rule 40 (expr -> list_val .)
    %               reduce using rule 40 (expr -> list_val .)
    /               reduce using rule 40 (expr -> list_val .)
    *               reduce using rule 40 (expr -> list_val .)
    -               reduce using rule 40 (expr -> list_val .)
    +               reduce using rule 40 (expr -> list_val .)
    |               reduce using rule 40 (expr -> list_val .)
    ^               reduce using rule 40 (expr -> list_val .)
    &               reduce using rule 40 (expr -> list_val .)
    SHR             reduce using rule 40 (expr -> list_val .)
    SHL             reduce using rule 40 (expr -> list_val .)
    GREATER         reduce using rule 40 (expr -> list_val .)
    LESS            reduce using rule 40 (expr -> list_val .)
    OR              reduce using rule 40 (expr -> list_val .)
    AND             reduce using rule 40 (expr -> list_val .)
    GREATEREQ       reduce using rule 40 (expr -> list_val .)
    LESSEQ          reduce using rule 40 (expr -> list_val .)
    NOTEQ           reduce using rule 40 (expr -> list_val .)
    EQEQ            reduce using rule 40 (expr -> list_val .)
    PIPE            reduce using rule 40 (expr -> list_val .)
    ?               reduce using rule 40 (expr -> list_val .)
    ]               reduce using rule 40 (expr -> list_val .)
    ,               reduce using rule 40 (expr -> list_val .)
    )               reduce using rule 40 (expr -> list_val .)
    {               reduce using rule 40 (expr -> list_val .)
    LET             reduce using rule 40 (expr -> list_val .)
    END             reduce using rule 40 (expr -> list_val .)
    BEGIN           reduce using rule 40 (expr -> list_val .)
    NIL             reduce using rule 40 (expr -> list_val .)
    FALSE           reduce using rule 40 (expr -> list_val .)
    TRUE            reduce using rule 40 (expr -> list_val .)
    STRING          reduce using rule 40 (expr -> list_val .)
    FLOAT           reduce using rule 40 (expr -> list_val .)
    INT             reduce using rule 40 (expr -> list_val .)
    (               reduce using rule 40 (expr -> list_val .)
    !               reduce using rule 40 (expr -> list_val .)
    ~               reduce using rule 40 (expr -> list_val .)
    ID              reduce using rule 40 (expr -> list_val .)
    TYPEOF          reduce using rule 40 (expr -> list_val .)
    LAMBDA          reduce using rule 40 (expr -> list_val .)
    DEC             reduce using rule 40 (expr -> list_val .)
    INC             reduce using rule 40 (expr -> list_val .)
    CLASS           reduce using rule 40 (expr -> list_val .)
    STRUCT          reduce using rule 40 (expr -> list_val .)
    IF              reduce using rule 40 (expr -> list_val .)
    FOR             reduce using rule 40 (expr -> list_val .)
    WHILE           reduce using rule 40 (expr -> list_val .)
    RETURN          reduce using rule 40 (expr -> list_val .)
    FN              reduce using rule 40 (expr -> list_val .)
    IMPORT          reduce using rule 40 (expr -> list_val .)
    [               reduce using rule 40 (expr -> list_val .)
    :               reduce using rule 40 (expr -> list_val .)
    }               reduce using rule 40 (expr -> list_val .)


state 27

    (41) expr -> FALSE .
    SEP             reduce using rule 41 (expr -> FALSE .)
    %               reduce using rule 41 (expr -> FALSE .)
    /               reduce using rule 41 (expr -> FALSE .)
    *               reduce using rule 41 (expr -> FALSE .)
    -               reduce using rule 41 (expr -> FALSE .)
    +               reduce using rule 41 (expr -> FALSE .)
    |               reduce using rule 41 (expr -> FALSE .)
    ^               reduce using rule 41 (expr -> FALSE .)
    &               reduce using rule 41 (expr -> FALSE .)
    SHR             reduce using rule 41 (expr -> FALSE .)
    SHL             reduce using rule 41 (expr -> FALSE .)
    GREATER         reduce using rule 41 (expr -> FALSE .)
    LESS            reduce using rule 41 (expr -> FALSE .)
    OR              reduce using rule 41 (expr -> FALSE .)
    AND             reduce using rule 41 (expr -> FALSE .)
    GREATEREQ       reduce using rule 41 (expr -> FALSE .)
    LESSEQ          reduce using rule 41 (expr -> FALSE .)
    NOTEQ           reduce using rule 41 (expr -> FALSE .)
    EQEQ            reduce using rule 41 (expr -> FALSE .)
    PIPE            reduce using rule 41 (expr -> FALSE .)
    ?               reduce using rule 41 (expr -> FALSE .)
    ]               reduce using rule 41 (expr -> FALSE .)
    ,               reduce using rule 41 (expr -> FALSE .)
    )               reduce using rule 41 (expr -> FALSE .)
    {               reduce using rule 41 (expr -> FALSE .)
    LET             reduce using rule 41 (expr -> FALSE .)
    END             reduce using rule 41 (expr -> FALSE .)
    BEGIN           reduce using rule 41 (expr -> FALSE .)
    NIL             reduce using rule 41 (expr -> FALSE .)
    FALSE           reduce using rule 41 (expr -> FALSE .)
    TRUE            reduce using rule 41 (expr -> FALSE .)
    STRING          reduce using rule 41 (expr -> FALSE .)
    FLOAT           reduce using rule 41 (expr -> FALSE .)
    INT             reduce using rule 41 (expr -> FALSE .)
    (               reduce using rule 41 (expr -> FALSE .)
    !               reduce using rule 41 (expr -> FALSE .)
    ~               reduce using rule 41 (expr -> FALSE .)
    ID              reduce using rule 41 (expr -> FALSE .)
    TYPEOF          reduce using rule 41 (expr -> FALSE .)
    LAMBDA          reduce using rule 41 (expr -> FALSE .)
    DEC             reduce using rule 41 (expr -> FALSE .)
    INC             reduce using rule 41 (expr -> FALSE .)
    CLASS           reduce using rule 41 (expr -> FALSE .)
    STRUCT          reduce using rule 41 (expr -> FALSE .)
    IF              reduce using rule 41 (expr -> FALSE .)
    FOR             reduce using rule 41 (expr -> FALSE .)
    WHILE           reduce using rule 41 (expr -> FALSE .)
    RETURN          reduce using rule 41 (expr -> FALSE .)
    FN              reduce using rule 41 (expr -> FALSE .)
    IMPORT          reduce using rule 41 (expr -> FALSE .)
    [               reduce using rule 41 (expr -> FALSE .)
    :               reduce using rule 41 (expr -> FALSE .)
    }               reduce using rule 41 (expr -> FALSE .)


state 28

    (42) expr -> TRUE .
    SEP             reduce using rule 42 (expr -> TRUE .)
    %               reduce using rule 42 (expr -> TRUE .)
    /               reduce using rule 42 (expr -> TRUE .)
    *               reduce using rule 42 (expr -> TRUE .)
    -               reduce using rule 42 (expr -> TRUE .)
    +               reduce using rule 42 (expr -> TRUE .)
    |               reduce using rule 42 (expr -> TRUE .)
    ^               reduce using rule 42 (expr -> TRUE .)
    &               reduce using rule 42 (expr -> TRUE .)
    SHR             reduce using rule 42 (expr -> TRUE .)
    SHL             reduce using rule 42 (expr -> TRUE .)
    GREATER         reduce using rule 42 (expr -> TRUE .)
    LESS            reduce using rule 42 (expr -> TRUE .)
    OR              reduce using rule 42 (expr -> TRUE .)
    AND             reduce using rule 42 (expr -> TRUE .)
    GREATEREQ       reduce using rule 42 (expr -> TRUE .)
    LESSEQ          reduce using rule 42 (expr -> TRUE .)
    NOTEQ           reduce using rule 42 (expr -> TRUE .)
    EQEQ            reduce using rule 42 (expr -> TRUE .)
    PIPE            reduce using rule 42 (expr -> TRUE .)
    ?               reduce using rule 42 (expr -> TRUE .)
    ]               reduce using rule 42 (expr -> TRUE .)
    ,               reduce using rule 42 (expr -> TRUE .)
    )               reduce using rule 42 (expr -> TRUE .)
    {               reduce using rule 42 (expr -> TRUE .)
    LET             reduce using rule 42 (expr -> TRUE .)
    END             reduce using rule 42 (expr -> TRUE .)
    BEGIN           reduce using rule 42 (expr -> TRUE .)
    NIL             reduce using rule 42 (expr -> TRUE .)
    FALSE           reduce using rule 42 (expr -> TRUE .)
    TRUE            reduce using rule 42 (expr -> TRUE .)
    STRING          reduce using rule 42 (expr -> TRUE .)
    FLOAT           reduce using rule 42 (expr -> TRUE .)
    INT             reduce using rule 42 (expr -> TRUE .)
    (               reduce using rule 42 (expr -> TRUE .)
    !               reduce using rule 42 (expr -> TRUE .)
    ~               reduce using rule 42 (expr -> TRUE .)
    ID              reduce using rule 42 (expr -> TRUE .)
    TYPEOF          reduce using rule 42 (expr -> TRUE .)
    LAMBDA          reduce using rule 42 (expr -> TRUE .)
    DEC             reduce using rule 42 (expr -> TRUE .)
    INC             reduce using rule 42 (expr -> TRUE .)
    CLASS           reduce using rule 42 (expr -> TRUE .)
    STRUCT          reduce using rule 42 (expr -> TRUE .)
    IF              reduce using rule 42 (expr -> TRUE .)
    FOR             reduce using rule 42 (expr -> TRUE .)
    WHILE           reduce using rule 42 (expr -> TRUE .)
    RETURN          reduce using rule 42 (expr -> TRUE .)
    FN              reduce using rule 42 (expr -> TRUE .)
    IMPORT          reduce using rule 42 (expr -> TRUE .)
    [               reduce using rule 42 (expr -> TRUE .)
    :               reduce using rule 42 (expr -> TRUE .)
    }               reduce using rule 42 (expr -> TRUE .)


state 29

    (43) expr -> STRING .
    SEP             reduce using rule 43 (expr -> STRING .)
    %               reduce using rule 43 (expr -> STRING .)
    /               reduce using rule 43 (expr -> STRING .)
    *               reduce using rule 43 (expr -> STRING .)
    -               reduce using rule 43 (expr -> STRING .)
    +               reduce using rule 43 (expr -> STRING .)
    |               reduce using rule 43 (expr -> STRING .)
    ^               reduce using rule 43 (expr -> STRING .)
    &               reduce using rule 43 (expr -> STRING .)
    SHR             reduce using rule 43 (expr -> STRING .)
    SHL             reduce using rule 43 (expr -> STRING .)
    GREATER         reduce using rule 43 (expr -> STRING .)
    LESS            reduce using rule 43 (expr -> STRING .)
    OR              reduce using rule 43 (expr -> STRING .)
    AND             reduce using rule 43 (expr -> STRING .)
    GREATEREQ       reduce using rule 43 (expr -> STRING .)
    LESSEQ          reduce using rule 43 (expr -> STRING .)
    NOTEQ           reduce using rule 43 (expr -> STRING .)
    EQEQ            reduce using rule 43 (expr -> STRING .)
    PIPE            reduce using rule 43 (expr -> STRING .)
    ?               reduce using rule 43 (expr -> STRING .)
    ]               reduce using rule 43 (expr -> STRING .)
    ,               reduce using rule 43 (expr -> STRING .)
    )               reduce using rule 43 (expr -> STRING .)
    {               reduce using rule 43 (expr -> STRING .)
    LET             reduce using rule 43 (expr -> STRING .)
    END             reduce using rule 43 (expr -> STRING .)
    BEGIN           reduce using rule 43 (expr -> STRING .)
    NIL             reduce using rule 43 (expr -> STRING .)
    FALSE           reduce using rule 43 (expr -> STRING .)
    TRUE            reduce using rule 43 (expr -> STRING .)
    STRING          reduce using rule 43 (expr -> STRING .)
    FLOAT           reduce using rule 43 (expr -> STRING .)
    INT             reduce using rule 43 (expr -> STRING .)
    (               reduce using rule 43 (expr -> STRING .)
    !               reduce using rule 43 (expr -> STRING .)
    ~               reduce using rule 43 (expr -> STRING .)
    ID              reduce using rule 43 (expr -> STRING .)
    TYPEOF          reduce using rule 43 (expr -> STRING .)
    LAMBDA          reduce using rule 43 (expr -> STRING .)
    DEC             reduce using rule 43 (expr -> STRING .)
    INC             reduce using rule 43 (expr -> STRING .)
    CLASS           reduce using rule 43 (expr -> STRING .)
    STRUCT          reduce using rule 43 (expr -> STRING .)
    IF              reduce using rule 43 (expr -> STRING .)
    FOR             reduce using rule 43 (expr -> STRING .)
    WHILE           reduce using rule 43 (expr -> STRING .)
    RETURN          reduce using rule 43 (expr -> STRING .)
    FN              reduce using rule 43 (expr -> STRING .)
    IMPORT          reduce using rule 43 (expr -> STRING .)
    [               reduce using rule 43 (expr -> STRING .)
    :               reduce using rule 43 (expr -> STRING .)
    }               reduce using rule 43 (expr -> STRING .)


state 30

    (44) expr -> FLOAT .
    SEP             reduce using rule 44 (expr -> FLOAT .)
    %               reduce using rule 44 (expr -> FLOAT .)
    /               reduce using rule 44 (expr -> FLOAT .)
    *               reduce using rule 44 (expr -> FLOAT .)
    -               reduce using rule 44 (expr -> FLOAT .)
    +               reduce using rule 44 (expr -> FLOAT .)
    |               reduce using rule 44 (expr -> FLOAT .)
    ^               reduce using rule 44 (expr -> FLOAT .)
    &               reduce using rule 44 (expr -> FLOAT .)
    SHR             reduce using rule 44 (expr -> FLOAT .)
    SHL             reduce using rule 44 (expr -> FLOAT .)
    GREATER         reduce using rule 44 (expr -> FLOAT .)
    LESS            reduce using rule 44 (expr -> FLOAT .)
    OR              reduce using rule 44 (expr -> FLOAT .)
    AND             reduce using rule 44 (expr -> FLOAT .)
    GREATEREQ       reduce using rule 44 (expr -> FLOAT .)
    LESSEQ          reduce using rule 44 (expr -> FLOAT .)
    NOTEQ           reduce using rule 44 (expr -> FLOAT .)
    EQEQ            reduce using rule 44 (expr -> FLOAT .)
    PIPE            reduce using rule 44 (expr -> FLOAT .)
    ?               reduce using rule 44 (expr -> FLOAT .)
    ]               reduce using rule 44 (expr -> FLOAT .)
    ,               reduce using rule 44 (expr -> FLOAT .)
    )               reduce using rule 44 (expr -> FLOAT .)
    {               reduce using rule 44 (expr -> FLOAT .)
    LET             reduce using rule 44 (expr -> FLOAT .)
    END             reduce using rule 44 (expr -> FLOAT .)
    BEGIN           reduce using rule 44 (expr -> FLOAT .)
    NIL             reduce using rule 44 (expr -> FLOAT .)
    FALSE           reduce using rule 44 (expr -> FLOAT .)
    TRUE            reduce using rule 44 (expr -> FLOAT .)
    STRING          reduce using rule 44 (expr -> FLOAT .)
    FLOAT           reduce using rule 44 (expr -> FLOAT .)
    INT             reduce using rule 44 (expr -> FLOAT .)
    (               reduce using rule 44 (expr -> FLOAT .)
    !               reduce using rule 44 (expr -> FLOAT .)
    ~               reduce using rule 44 (expr -> FLOAT .)
    ID              reduce using rule 44 (expr -> FLOAT .)
    TYPEOF          reduce using rule 44 (expr -> FLOAT .)
    LAMBDA          reduce using rule 44 (expr -> FLOAT .)
    DEC             reduce using rule 44 (expr -> FLOAT .)
    INC             reduce using rule 44 (expr -> FLOAT .)
    CLASS           reduce using rule 44 (expr -> FLOAT .)
    STRUCT          reduce using rule 44 (expr -> FLOAT .)
    IF              reduce using rule 44 (expr -> FLOAT .)
    FOR             reduce using rule 44 (expr -> FLOAT .)
    WHILE           reduce using rule 44 (expr -> FLOAT .)
    RETURN          reduce using rule 44 (expr -> FLOAT .)
    FN              reduce using rule 44 (expr -> FLOAT .)
    IMPORT          reduce using rule 44 (expr -> FLOAT .)
    [               reduce using rule 44 (expr -> FLOAT .)
    :               reduce using rule 44 (expr -> FLOAT .)
    }               reduce using rule 44 (expr -> FLOAT .)


state 31

    (45) expr -> INT .
    SEP             reduce using rule 45 (expr -> INT .)
    %               reduce using rule 45 (expr -> INT .)
    /               reduce using rule 45 (expr -> INT .)
    *               reduce using rule 45 (expr -> INT .)
    -               reduce using rule 45 (expr -> INT .)
    +               reduce using rule 45 (expr -> INT .)
    |               reduce using rule 45 (expr -> INT .)
    ^               reduce using rule 45 (expr -> INT .)
    &               reduce using rule 45 (expr -> INT .)
    SHR             reduce using rule 45 (expr -> INT .)
    SHL             reduce using rule 45 (expr -> INT .)
    GREATER         reduce using rule 45 (expr -> INT .)
    LESS            reduce using rule 45 (expr -> INT .)
    OR              reduce using rule 45 (expr -> INT .)
    AND             reduce using rule 45 (expr -> INT .)
    GREATEREQ       reduce using rule 45 (expr -> INT .)
    LESSEQ          reduce using rule 45 (expr -> INT .)
    NOTEQ           reduce using rule 45 (expr -> INT .)
    EQEQ            reduce using rule 45 (expr -> INT .)
    PIPE            reduce using rule 45 (expr -> INT .)
    ?               reduce using rule 45 (expr -> INT .)
    ]               reduce using rule 45 (expr -> INT .)
    ,               reduce using rule 45 (expr -> INT .)
    )               reduce using rule 45 (expr -> INT .)
    {               reduce using rule 45 (expr -> INT .)
    LET             reduce using rule 45 (expr -> INT .)
    END             reduce using rule 45 (expr -> INT .)
    BEGIN           reduce using rule 45 (expr -> INT .)
    NIL             reduce using rule 45 (expr -> INT .)
    FALSE           reduce using rule 45 (expr -> INT .)
    TRUE            reduce using rule 45 (expr -> INT .)
    STRING          reduce using rule 45 (expr -> INT .)
    FLOAT           reduce using rule 45 (expr -> INT .)
    INT             reduce using rule 45 (expr -> INT .)
    (               reduce using rule 45 (expr -> INT .)
    !               reduce using rule 45 (expr -> INT .)
    ~               reduce using rule 45 (expr -> INT .)
    ID              reduce using rule 45 (expr -> INT .)
    TYPEOF          reduce using rule 45 (expr -> INT .)
    LAMBDA          reduce using rule 45 (expr -> INT .)
    DEC             reduce using rule 45 (expr -> INT .)
    INC             reduce using rule 45 (expr -> INT .)
    CLASS           reduce using rule 45 (expr -> INT .)
    STRUCT          reduce using rule 45 (expr -> INT .)
    IF              reduce using rule 45 (expr -> INT .)
    FOR             reduce using rule 45 (expr -> INT .)
    WHILE           reduce using rule 45 (expr -> INT .)
    RETURN          reduce using rule 45 (expr -> INT .)
    FN              reduce using rule 45 (expr -> INT .)
    IMPORT          reduce using rule 45 (expr -> INT .)
    [               reduce using rule 45 (expr -> INT .)
    :               reduce using rule 45 (expr -> INT .)
    }               reduce using rule 45 (expr -> INT .)


state 32

    (46) expr -> ( . expr )
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 98
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 33

    (54) expr -> - . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 99
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 34

    (53) expr -> + . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 100
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 35

    (52) expr -> ! . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 101
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 36

    (55) expr -> ~ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 102
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 37

    (70) expr -> ID . DOUBLECOLON ID ( args )
    (71) expr -> ID . ( args )
    (75) expr -> ID . LEFTARROW { struct_init_exprs }
    (119) getter -> ID .
    (103) var -> ID .
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for [ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for SEP resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for % resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for / resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for * resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for - resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for + resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for | resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for & resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for SHR resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for SHL resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for EQEQ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for PIPE resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for ? resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for ] resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for , resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for { resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for LET resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for END resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for BEGIN resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for NIL resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 103 (var -> ID .)
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for ! resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for ~ resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for TYPEOF resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for LAMBDA resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for DEC resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for INC resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for CLASS resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for STRUCT resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for FN resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for IMPORT resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for : resolved using rule 103 (var -> ID .)
  ! reduce/reduce conflict for } resolved using rule 103 (var -> ID .)
    DOUBLECOLON     shift and go to state 103
    (               shift and go to state 104
    LEFTARROW       shift and go to state 105
    .               reduce using rule 119 (getter -> ID .)
    [               reduce using rule 103 (var -> ID .)
    SHRASGN         reduce using rule 103 (var -> ID .)
    SHLASGN         reduce using rule 103 (var -> ID .)
    XORASGN         reduce using rule 103 (var -> ID .)
    ORASGN          reduce using rule 103 (var -> ID .)
    ANDASGN         reduce using rule 103 (var -> ID .)
    MODULOASGN      reduce using rule 103 (var -> ID .)
    SLASHASGN       reduce using rule 103 (var -> ID .)
    STARASGN        reduce using rule 103 (var -> ID .)
    MINUSASGN       reduce using rule 103 (var -> ID .)
    PLUSASGN        reduce using rule 103 (var -> ID .)
    ASSIGN          reduce using rule 103 (var -> ID .)
    SEP             reduce using rule 103 (var -> ID .)
    %               reduce using rule 103 (var -> ID .)
    /               reduce using rule 103 (var -> ID .)
    *               reduce using rule 103 (var -> ID .)
    -               reduce using rule 103 (var -> ID .)
    +               reduce using rule 103 (var -> ID .)
    |               reduce using rule 103 (var -> ID .)
    ^               reduce using rule 103 (var -> ID .)
    &               reduce using rule 103 (var -> ID .)
    SHR             reduce using rule 103 (var -> ID .)
    SHL             reduce using rule 103 (var -> ID .)
    GREATER         reduce using rule 103 (var -> ID .)
    LESS            reduce using rule 103 (var -> ID .)
    OR              reduce using rule 103 (var -> ID .)
    AND             reduce using rule 103 (var -> ID .)
    GREATEREQ       reduce using rule 103 (var -> ID .)
    LESSEQ          reduce using rule 103 (var -> ID .)
    NOTEQ           reduce using rule 103 (var -> ID .)
    EQEQ            reduce using rule 103 (var -> ID .)
    PIPE            reduce using rule 103 (var -> ID .)
    ?               reduce using rule 103 (var -> ID .)
    ]               reduce using rule 103 (var -> ID .)
    ,               reduce using rule 103 (var -> ID .)
    )               reduce using rule 103 (var -> ID .)
    {               reduce using rule 103 (var -> ID .)
    LET             reduce using rule 103 (var -> ID .)
    END             reduce using rule 103 (var -> ID .)
    BEGIN           reduce using rule 103 (var -> ID .)
    NIL             reduce using rule 103 (var -> ID .)
    FALSE           reduce using rule 103 (var -> ID .)
    TRUE            reduce using rule 103 (var -> ID .)
    STRING          reduce using rule 103 (var -> ID .)
    FLOAT           reduce using rule 103 (var -> ID .)
    INT             reduce using rule 103 (var -> ID .)
    !               reduce using rule 103 (var -> ID .)
    ~               reduce using rule 103 (var -> ID .)
    ID              reduce using rule 103 (var -> ID .)
    TYPEOF          reduce using rule 103 (var -> ID .)
    LAMBDA          reduce using rule 103 (var -> ID .)
    DEC             reduce using rule 103 (var -> ID .)
    INC             reduce using rule 103 (var -> ID .)
    CLASS           reduce using rule 103 (var -> ID .)
    STRUCT          reduce using rule 103 (var -> ID .)
    IF              reduce using rule 103 (var -> ID .)
    FOR             reduce using rule 103 (var -> ID .)
    WHILE           reduce using rule 103 (var -> ID .)
    RETURN          reduce using rule 103 (var -> ID .)
    FN              reduce using rule 103 (var -> ID .)
    IMPORT          reduce using rule 103 (var -> ID .)
    :               reduce using rule 103 (var -> ID .)
    }               reduce using rule 103 (var -> ID .)


state 38

    (73) expr -> TYPEOF . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 106
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 39

    (74) expr -> LAMBDA . ( params ) ARROW expr
    (               shift and go to state 107


state 40

    (81) var_assign -> DEC . var
    (102) var -> . var [ expr ]
    (103) var -> . ID
    ID              shift and go to state 109

    var                            shift and go to state 108

state 41

    (82) var_assign -> INC . var
    (102) var -> . var [ expr ]
    (103) var -> . ID
    ID              shift and go to state 109

    var                            shift and go to state 110

state 42

    (19) class_definition -> CLASS . ID { function_definitions }
    ID              shift and go to state 111


state 43

    (23) struct_definition -> STRUCT . ID { struct_fields } SEP
    ID              shift and go to state 112


state 44

    (94) if_statement -> IF . expr block
    (95) if_statement -> IF . expr block ELSE block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 113
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 45

    (97) for_statement -> FOR . var_assign SEP expr SEP var_assign block
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (102) var -> . var [ expr ]
    (103) var -> . ID
    DEC             shift and go to state 40
    INC             shift and go to state 41
    ID              shift and go to state 109

    var_assign                     shift and go to state 114
    var                            shift and go to state 115

state 46

    (96) while_statement -> WHILE . expr block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 116
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 47

    (80) return_statement -> RETURN . expr SEP
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 117
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 48

    (34) function_definition -> FN . ID ( params ) block
    ID              shift and go to state 118


state 49

    (33) import_statement -> IMPORT . STRING SEP
    STRING          shift and go to state 119


state 50

    (3) statements -> statements statement .
    LET             reduce using rule 3 (statements -> statements statement .)
    END             reduce using rule 3 (statements -> statements statement .)
    BEGIN           reduce using rule 3 (statements -> statements statement .)
    {               reduce using rule 3 (statements -> statements statement .)
    NIL             reduce using rule 3 (statements -> statements statement .)
    FALSE           reduce using rule 3 (statements -> statements statement .)
    TRUE            reduce using rule 3 (statements -> statements statement .)
    STRING          reduce using rule 3 (statements -> statements statement .)
    FLOAT           reduce using rule 3 (statements -> statements statement .)
    INT             reduce using rule 3 (statements -> statements statement .)
    (               reduce using rule 3 (statements -> statements statement .)
    !               reduce using rule 3 (statements -> statements statement .)
    +               reduce using rule 3 (statements -> statements statement .)
    -               reduce using rule 3 (statements -> statements statement .)
    ~               reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    TYPEOF          reduce using rule 3 (statements -> statements statement .)
    LAMBDA          reduce using rule 3 (statements -> statements statement .)
    DEC             reduce using rule 3 (statements -> statements statement .)
    INC             reduce using rule 3 (statements -> statements statement .)
    CLASS           reduce using rule 3 (statements -> statements statement .)
    STRUCT          reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    FN              reduce using rule 3 (statements -> statements statement .)
    IMPORT          reduce using rule 3 (statements -> statements statement .)
    [               reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 51

    (7) statement -> expr SEP .
    LET             reduce using rule 7 (statement -> expr SEP .)
    END             reduce using rule 7 (statement -> expr SEP .)
    BEGIN           reduce using rule 7 (statement -> expr SEP .)
    {               reduce using rule 7 (statement -> expr SEP .)
    NIL             reduce using rule 7 (statement -> expr SEP .)
    FALSE           reduce using rule 7 (statement -> expr SEP .)
    TRUE            reduce using rule 7 (statement -> expr SEP .)
    STRING          reduce using rule 7 (statement -> expr SEP .)
    FLOAT           reduce using rule 7 (statement -> expr SEP .)
    INT             reduce using rule 7 (statement -> expr SEP .)
    (               reduce using rule 7 (statement -> expr SEP .)
    !               reduce using rule 7 (statement -> expr SEP .)
    +               reduce using rule 7 (statement -> expr SEP .)
    -               reduce using rule 7 (statement -> expr SEP .)
    ~               reduce using rule 7 (statement -> expr SEP .)
    ID              reduce using rule 7 (statement -> expr SEP .)
    TYPEOF          reduce using rule 7 (statement -> expr SEP .)
    LAMBDA          reduce using rule 7 (statement -> expr SEP .)
    DEC             reduce using rule 7 (statement -> expr SEP .)
    INC             reduce using rule 7 (statement -> expr SEP .)
    CLASS           reduce using rule 7 (statement -> expr SEP .)
    STRUCT          reduce using rule 7 (statement -> expr SEP .)
    IF              reduce using rule 7 (statement -> expr SEP .)
    FOR             reduce using rule 7 (statement -> expr SEP .)
    WHILE           reduce using rule 7 (statement -> expr SEP .)
    RETURN          reduce using rule 7 (statement -> expr SEP .)
    FN              reduce using rule 7 (statement -> expr SEP .)
    IMPORT          reduce using rule 7 (statement -> expr SEP .)
    [               reduce using rule 7 (statement -> expr SEP .)
    $end            reduce using rule 7 (statement -> expr SEP .)
    }               reduce using rule 7 (statement -> expr SEP .)
    ELSE            reduce using rule 7 (statement -> expr SEP .)


state 52

    (47) expr -> expr % . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 120
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 53

    (48) expr -> expr / . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 121
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 54

    (49) expr -> expr * . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 122
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 55

    (50) expr -> expr - . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 123
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 56

    (51) expr -> expr + . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 124
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 57

    (56) expr -> expr | . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 125
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 58

    (57) expr -> expr ^ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 126
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 59

    (58) expr -> expr & . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 127
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 60

    (59) expr -> expr SHR . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 128
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 61

    (60) expr -> expr SHL . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 129
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 62

    (61) expr -> expr GREATER . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 130
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 63

    (62) expr -> expr LESS . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 131
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 64

    (63) expr -> expr OR . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 132
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 65

    (64) expr -> expr AND . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 133
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 66

    (65) expr -> expr GREATEREQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 134
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 67

    (66) expr -> expr LESSEQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 135
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 68

    (67) expr -> expr NOTEQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 136
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 69

    (68) expr -> expr EQEQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 137
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 70

    (69) expr -> expr PIPE . ID ( args )
    ID              shift and go to state 138


state 71

    (72) expr -> expr ? . expr : expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 139
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 72

    (8) statement -> var_assign SEP .
    LET             reduce using rule 8 (statement -> var_assign SEP .)
    END             reduce using rule 8 (statement -> var_assign SEP .)
    BEGIN           reduce using rule 8 (statement -> var_assign SEP .)
    {               reduce using rule 8 (statement -> var_assign SEP .)
    NIL             reduce using rule 8 (statement -> var_assign SEP .)
    FALSE           reduce using rule 8 (statement -> var_assign SEP .)
    TRUE            reduce using rule 8 (statement -> var_assign SEP .)
    STRING          reduce using rule 8 (statement -> var_assign SEP .)
    FLOAT           reduce using rule 8 (statement -> var_assign SEP .)
    INT             reduce using rule 8 (statement -> var_assign SEP .)
    (               reduce using rule 8 (statement -> var_assign SEP .)
    !               reduce using rule 8 (statement -> var_assign SEP .)
    +               reduce using rule 8 (statement -> var_assign SEP .)
    -               reduce using rule 8 (statement -> var_assign SEP .)
    ~               reduce using rule 8 (statement -> var_assign SEP .)
    ID              reduce using rule 8 (statement -> var_assign SEP .)
    TYPEOF          reduce using rule 8 (statement -> var_assign SEP .)
    LAMBDA          reduce using rule 8 (statement -> var_assign SEP .)
    DEC             reduce using rule 8 (statement -> var_assign SEP .)
    INC             reduce using rule 8 (statement -> var_assign SEP .)
    CLASS           reduce using rule 8 (statement -> var_assign SEP .)
    STRUCT          reduce using rule 8 (statement -> var_assign SEP .)
    IF              reduce using rule 8 (statement -> var_assign SEP .)
    FOR             reduce using rule 8 (statement -> var_assign SEP .)
    WHILE           reduce using rule 8 (statement -> var_assign SEP .)
    RETURN          reduce using rule 8 (statement -> var_assign SEP .)
    FN              reduce using rule 8 (statement -> var_assign SEP .)
    IMPORT          reduce using rule 8 (statement -> var_assign SEP .)
    [               reduce using rule 8 (statement -> var_assign SEP .)
    $end            reduce using rule 8 (statement -> var_assign SEP .)
    }               reduce using rule 8 (statement -> var_assign SEP .)
    ELSE            reduce using rule 8 (statement -> var_assign SEP .)


state 73

    (9) statement -> LET var . : var_type SEP
    (79) var_define -> LET var . ASSIGN expr
    (102) var -> var . [ expr ]
    :               shift and go to state 140
    ASSIGN          shift and go to state 141
    [               shift and go to state 142


state 74

    (78) var_define -> LET getter . ASSIGN expr
    (120) getter -> getter . . ID
    ASSIGN          shift and go to state 143
    .               shift and go to state 89


state 75

    (103) var -> ID .
    (119) getter -> ID .
  ! reduce/reduce conflict for ASSIGN resolved using rule 103 (var -> ID .)
    :               reduce using rule 103 (var -> ID .)
    ASSIGN          reduce using rule 103 (var -> ID .)
    [               reduce using rule 103 (var -> ID .)
    .               reduce using rule 119 (getter -> ID .)


state 76

    (39) expr -> var [ . expr ]
    (102) var -> var [ . expr ]
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 144
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 77

    (83) var_assign -> var SHRASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 145
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 78

    (84) var_assign -> var SHLASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 146
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 79

    (85) var_assign -> var XORASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 147
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 80

    (86) var_assign -> var ORASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 148
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 81

    (87) var_assign -> var ANDASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 149
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 82

    (88) var_assign -> var MODULOASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 150
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 83

    (89) var_assign -> var SLASHASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 151
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 84

    (90) var_assign -> var STARASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 152
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 85

    (91) var_assign -> var MINUSASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 153
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 86

    (92) var_assign -> var PLUSASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 154
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 87

    (93) var_assign -> var ASSIGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 155
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 88

    (10) statement -> var_define SEP .
    LET             reduce using rule 10 (statement -> var_define SEP .)
    END             reduce using rule 10 (statement -> var_define SEP .)
    BEGIN           reduce using rule 10 (statement -> var_define SEP .)
    {               reduce using rule 10 (statement -> var_define SEP .)
    NIL             reduce using rule 10 (statement -> var_define SEP .)
    FALSE           reduce using rule 10 (statement -> var_define SEP .)
    TRUE            reduce using rule 10 (statement -> var_define SEP .)
    STRING          reduce using rule 10 (statement -> var_define SEP .)
    FLOAT           reduce using rule 10 (statement -> var_define SEP .)
    INT             reduce using rule 10 (statement -> var_define SEP .)
    (               reduce using rule 10 (statement -> var_define SEP .)
    !               reduce using rule 10 (statement -> var_define SEP .)
    +               reduce using rule 10 (statement -> var_define SEP .)
    -               reduce using rule 10 (statement -> var_define SEP .)
    ~               reduce using rule 10 (statement -> var_define SEP .)
    ID              reduce using rule 10 (statement -> var_define SEP .)
    TYPEOF          reduce using rule 10 (statement -> var_define SEP .)
    LAMBDA          reduce using rule 10 (statement -> var_define SEP .)
    DEC             reduce using rule 10 (statement -> var_define SEP .)
    INC             reduce using rule 10 (statement -> var_define SEP .)
    CLASS           reduce using rule 10 (statement -> var_define SEP .)
    STRUCT          reduce using rule 10 (statement -> var_define SEP .)
    IF              reduce using rule 10 (statement -> var_define SEP .)
    FOR             reduce using rule 10 (statement -> var_define SEP .)
    WHILE           reduce using rule 10 (statement -> var_define SEP .)
    RETURN          reduce using rule 10 (statement -> var_define SEP .)
    FN              reduce using rule 10 (statement -> var_define SEP .)
    IMPORT          reduce using rule 10 (statement -> var_define SEP .)
    [               reduce using rule 10 (statement -> var_define SEP .)
    $end            reduce using rule 10 (statement -> var_define SEP .)
    }               reduce using rule 10 (statement -> var_define SEP .)
    ELSE            reduce using rule 10 (statement -> var_define SEP .)


state 89

    (120) getter -> getter . . ID
    ID              shift and go to state 156


state 90

    (36) expr -> { member_list . }
    (115) member_list -> member_list . , member
    }               shift and go to state 157
    ,               shift and go to state 158


state 91

    (116) member_list -> member .
    }               reduce using rule 116 (member_list -> member .)
    ,               reduce using rule 116 (member_list -> member .)


state 92

    (117) member_list -> empty .
    }               reduce using rule 117 (member_list -> empty .)
    ,               reduce using rule 117 (member_list -> empty .)


state 93

    (118) member -> STRING . : expr
    :               shift and go to state 159


state 94

    (98) list_val -> [ exprs . ]
    (99) exprs -> exprs . , expr
    ]               shift and go to state 160
    ,               shift and go to state 161


state 95

    (100) exprs -> expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    ]               reduce using rule 100 (exprs -> expr .)
    ,               reduce using rule 100 (exprs -> expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 96

    (101) exprs -> empty .
    ]               reduce using rule 101 (exprs -> empty .)
    ,               reduce using rule 101 (exprs -> empty .)


state 97

    (38) expr -> var .
    (39) expr -> var . [ expr ]
    (102) var -> var . [ expr ]
  ! shift/reduce conflict for [ resolved as shift
    %               reduce using rule 38 (expr -> var .)
    /               reduce using rule 38 (expr -> var .)
    *               reduce using rule 38 (expr -> var .)
    -               reduce using rule 38 (expr -> var .)
    +               reduce using rule 38 (expr -> var .)
    |               reduce using rule 38 (expr -> var .)
    ^               reduce using rule 38 (expr -> var .)
    &               reduce using rule 38 (expr -> var .)
    SHR             reduce using rule 38 (expr -> var .)
    SHL             reduce using rule 38 (expr -> var .)
    GREATER         reduce using rule 38 (expr -> var .)
    LESS            reduce using rule 38 (expr -> var .)
    OR              reduce using rule 38 (expr -> var .)
    AND             reduce using rule 38 (expr -> var .)
    GREATEREQ       reduce using rule 38 (expr -> var .)
    LESSEQ          reduce using rule 38 (expr -> var .)
    NOTEQ           reduce using rule 38 (expr -> var .)
    EQEQ            reduce using rule 38 (expr -> var .)
    PIPE            reduce using rule 38 (expr -> var .)
    ?               reduce using rule 38 (expr -> var .)
    ]               reduce using rule 38 (expr -> var .)
    ,               reduce using rule 38 (expr -> var .)
    )               reduce using rule 38 (expr -> var .)
    SEP             reduce using rule 38 (expr -> var .)
    {               reduce using rule 38 (expr -> var .)
    LET             reduce using rule 38 (expr -> var .)
    END             reduce using rule 38 (expr -> var .)
    BEGIN           reduce using rule 38 (expr -> var .)
    NIL             reduce using rule 38 (expr -> var .)
    FALSE           reduce using rule 38 (expr -> var .)
    TRUE            reduce using rule 38 (expr -> var .)
    STRING          reduce using rule 38 (expr -> var .)
    FLOAT           reduce using rule 38 (expr -> var .)
    INT             reduce using rule 38 (expr -> var .)
    (               reduce using rule 38 (expr -> var .)
    !               reduce using rule 38 (expr -> var .)
    ~               reduce using rule 38 (expr -> var .)
    ID              reduce using rule 38 (expr -> var .)
    TYPEOF          reduce using rule 38 (expr -> var .)
    LAMBDA          reduce using rule 38 (expr -> var .)
    DEC             reduce using rule 38 (expr -> var .)
    INC             reduce using rule 38 (expr -> var .)
    CLASS           reduce using rule 38 (expr -> var .)
    STRUCT          reduce using rule 38 (expr -> var .)
    IF              reduce using rule 38 (expr -> var .)
    FOR             reduce using rule 38 (expr -> var .)
    WHILE           reduce using rule 38 (expr -> var .)
    RETURN          reduce using rule 38 (expr -> var .)
    FN              reduce using rule 38 (expr -> var .)
    IMPORT          reduce using rule 38 (expr -> var .)
    :               reduce using rule 38 (expr -> var .)
    }               reduce using rule 38 (expr -> var .)
    [               shift and go to state 76


state 98

    (46) expr -> ( expr . )
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    )               shift and go to state 162
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 99

    (54) expr -> - expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 54 (expr -> - expr .)
    %               reduce using rule 54 (expr -> - expr .)
    /               reduce using rule 54 (expr -> - expr .)
    *               reduce using rule 54 (expr -> - expr .)
    -               reduce using rule 54 (expr -> - expr .)
    +               reduce using rule 54 (expr -> - expr .)
    |               reduce using rule 54 (expr -> - expr .)
    ^               reduce using rule 54 (expr -> - expr .)
    &               reduce using rule 54 (expr -> - expr .)
    SHR             reduce using rule 54 (expr -> - expr .)
    SHL             reduce using rule 54 (expr -> - expr .)
    GREATER         reduce using rule 54 (expr -> - expr .)
    LESS            reduce using rule 54 (expr -> - expr .)
    OR              reduce using rule 54 (expr -> - expr .)
    AND             reduce using rule 54 (expr -> - expr .)
    GREATEREQ       reduce using rule 54 (expr -> - expr .)
    LESSEQ          reduce using rule 54 (expr -> - expr .)
    NOTEQ           reduce using rule 54 (expr -> - expr .)
    EQEQ            reduce using rule 54 (expr -> - expr .)
    PIPE            reduce using rule 54 (expr -> - expr .)
    ?               reduce using rule 54 (expr -> - expr .)
    ]               reduce using rule 54 (expr -> - expr .)
    ,               reduce using rule 54 (expr -> - expr .)
    )               reduce using rule 54 (expr -> - expr .)
    {               reduce using rule 54 (expr -> - expr .)
    LET             reduce using rule 54 (expr -> - expr .)
    END             reduce using rule 54 (expr -> - expr .)
    BEGIN           reduce using rule 54 (expr -> - expr .)
    NIL             reduce using rule 54 (expr -> - expr .)
    FALSE           reduce using rule 54 (expr -> - expr .)
    TRUE            reduce using rule 54 (expr -> - expr .)
    STRING          reduce using rule 54 (expr -> - expr .)
    FLOAT           reduce using rule 54 (expr -> - expr .)
    INT             reduce using rule 54 (expr -> - expr .)
    (               reduce using rule 54 (expr -> - expr .)
    !               reduce using rule 54 (expr -> - expr .)
    ~               reduce using rule 54 (expr -> - expr .)
    ID              reduce using rule 54 (expr -> - expr .)
    TYPEOF          reduce using rule 54 (expr -> - expr .)
    LAMBDA          reduce using rule 54 (expr -> - expr .)
    DEC             reduce using rule 54 (expr -> - expr .)
    INC             reduce using rule 54 (expr -> - expr .)
    CLASS           reduce using rule 54 (expr -> - expr .)
    STRUCT          reduce using rule 54 (expr -> - expr .)
    IF              reduce using rule 54 (expr -> - expr .)
    FOR             reduce using rule 54 (expr -> - expr .)
    WHILE           reduce using rule 54 (expr -> - expr .)
    RETURN          reduce using rule 54 (expr -> - expr .)
    FN              reduce using rule 54 (expr -> - expr .)
    IMPORT          reduce using rule 54 (expr -> - expr .)
    [               reduce using rule 54 (expr -> - expr .)
    :               reduce using rule 54 (expr -> - expr .)
    }               reduce using rule 54 (expr -> - expr .)


state 100

    (53) expr -> + expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 53 (expr -> + expr .)
    %               reduce using rule 53 (expr -> + expr .)
    /               reduce using rule 53 (expr -> + expr .)
    *               reduce using rule 53 (expr -> + expr .)
    -               reduce using rule 53 (expr -> + expr .)
    +               reduce using rule 53 (expr -> + expr .)
    |               reduce using rule 53 (expr -> + expr .)
    ^               reduce using rule 53 (expr -> + expr .)
    &               reduce using rule 53 (expr -> + expr .)
    SHR             reduce using rule 53 (expr -> + expr .)
    SHL             reduce using rule 53 (expr -> + expr .)
    GREATER         reduce using rule 53 (expr -> + expr .)
    LESS            reduce using rule 53 (expr -> + expr .)
    OR              reduce using rule 53 (expr -> + expr .)
    AND             reduce using rule 53 (expr -> + expr .)
    GREATEREQ       reduce using rule 53 (expr -> + expr .)
    LESSEQ          reduce using rule 53 (expr -> + expr .)
    NOTEQ           reduce using rule 53 (expr -> + expr .)
    EQEQ            reduce using rule 53 (expr -> + expr .)
    PIPE            reduce using rule 53 (expr -> + expr .)
    ?               reduce using rule 53 (expr -> + expr .)
    ]               reduce using rule 53 (expr -> + expr .)
    ,               reduce using rule 53 (expr -> + expr .)
    )               reduce using rule 53 (expr -> + expr .)
    {               reduce using rule 53 (expr -> + expr .)
    LET             reduce using rule 53 (expr -> + expr .)
    END             reduce using rule 53 (expr -> + expr .)
    BEGIN           reduce using rule 53 (expr -> + expr .)
    NIL             reduce using rule 53 (expr -> + expr .)
    FALSE           reduce using rule 53 (expr -> + expr .)
    TRUE            reduce using rule 53 (expr -> + expr .)
    STRING          reduce using rule 53 (expr -> + expr .)
    FLOAT           reduce using rule 53 (expr -> + expr .)
    INT             reduce using rule 53 (expr -> + expr .)
    (               reduce using rule 53 (expr -> + expr .)
    !               reduce using rule 53 (expr -> + expr .)
    ~               reduce using rule 53 (expr -> + expr .)
    ID              reduce using rule 53 (expr -> + expr .)
    TYPEOF          reduce using rule 53 (expr -> + expr .)
    LAMBDA          reduce using rule 53 (expr -> + expr .)
    DEC             reduce using rule 53 (expr -> + expr .)
    INC             reduce using rule 53 (expr -> + expr .)
    CLASS           reduce using rule 53 (expr -> + expr .)
    STRUCT          reduce using rule 53 (expr -> + expr .)
    IF              reduce using rule 53 (expr -> + expr .)
    FOR             reduce using rule 53 (expr -> + expr .)
    WHILE           reduce using rule 53 (expr -> + expr .)
    RETURN          reduce using rule 53 (expr -> + expr .)
    FN              reduce using rule 53 (expr -> + expr .)
    IMPORT          reduce using rule 53 (expr -> + expr .)
    [               reduce using rule 53 (expr -> + expr .)
    :               reduce using rule 53 (expr -> + expr .)
    }               reduce using rule 53 (expr -> + expr .)


state 101

    (52) expr -> ! expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 52 (expr -> ! expr .)
    %               reduce using rule 52 (expr -> ! expr .)
    /               reduce using rule 52 (expr -> ! expr .)
    *               reduce using rule 52 (expr -> ! expr .)
    -               reduce using rule 52 (expr -> ! expr .)
    +               reduce using rule 52 (expr -> ! expr .)
    |               reduce using rule 52 (expr -> ! expr .)
    ^               reduce using rule 52 (expr -> ! expr .)
    &               reduce using rule 52 (expr -> ! expr .)
    SHR             reduce using rule 52 (expr -> ! expr .)
    SHL             reduce using rule 52 (expr -> ! expr .)
    GREATER         reduce using rule 52 (expr -> ! expr .)
    LESS            reduce using rule 52 (expr -> ! expr .)
    OR              reduce using rule 52 (expr -> ! expr .)
    AND             reduce using rule 52 (expr -> ! expr .)
    GREATEREQ       reduce using rule 52 (expr -> ! expr .)
    LESSEQ          reduce using rule 52 (expr -> ! expr .)
    NOTEQ           reduce using rule 52 (expr -> ! expr .)
    EQEQ            reduce using rule 52 (expr -> ! expr .)
    PIPE            reduce using rule 52 (expr -> ! expr .)
    ?               reduce using rule 52 (expr -> ! expr .)
    ]               reduce using rule 52 (expr -> ! expr .)
    ,               reduce using rule 52 (expr -> ! expr .)
    )               reduce using rule 52 (expr -> ! expr .)
    {               reduce using rule 52 (expr -> ! expr .)
    LET             reduce using rule 52 (expr -> ! expr .)
    END             reduce using rule 52 (expr -> ! expr .)
    BEGIN           reduce using rule 52 (expr -> ! expr .)
    NIL             reduce using rule 52 (expr -> ! expr .)
    FALSE           reduce using rule 52 (expr -> ! expr .)
    TRUE            reduce using rule 52 (expr -> ! expr .)
    STRING          reduce using rule 52 (expr -> ! expr .)
    FLOAT           reduce using rule 52 (expr -> ! expr .)
    INT             reduce using rule 52 (expr -> ! expr .)
    (               reduce using rule 52 (expr -> ! expr .)
    !               reduce using rule 52 (expr -> ! expr .)
    ~               reduce using rule 52 (expr -> ! expr .)
    ID              reduce using rule 52 (expr -> ! expr .)
    TYPEOF          reduce using rule 52 (expr -> ! expr .)
    LAMBDA          reduce using rule 52 (expr -> ! expr .)
    DEC             reduce using rule 52 (expr -> ! expr .)
    INC             reduce using rule 52 (expr -> ! expr .)
    CLASS           reduce using rule 52 (expr -> ! expr .)
    STRUCT          reduce using rule 52 (expr -> ! expr .)
    IF              reduce using rule 52 (expr -> ! expr .)
    FOR             reduce using rule 52 (expr -> ! expr .)
    WHILE           reduce using rule 52 (expr -> ! expr .)
    RETURN          reduce using rule 52 (expr -> ! expr .)
    FN              reduce using rule 52 (expr -> ! expr .)
    IMPORT          reduce using rule 52 (expr -> ! expr .)
    [               reduce using rule 52 (expr -> ! expr .)
    :               reduce using rule 52 (expr -> ! expr .)
    }               reduce using rule 52 (expr -> ! expr .)


state 102

    (55) expr -> ~ expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 55 (expr -> ~ expr .)
    %               reduce using rule 55 (expr -> ~ expr .)
    /               reduce using rule 55 (expr -> ~ expr .)
    *               reduce using rule 55 (expr -> ~ expr .)
    -               reduce using rule 55 (expr -> ~ expr .)
    +               reduce using rule 55 (expr -> ~ expr .)
    |               reduce using rule 55 (expr -> ~ expr .)
    ^               reduce using rule 55 (expr -> ~ expr .)
    &               reduce using rule 55 (expr -> ~ expr .)
    SHR             reduce using rule 55 (expr -> ~ expr .)
    SHL             reduce using rule 55 (expr -> ~ expr .)
    GREATER         reduce using rule 55 (expr -> ~ expr .)
    LESS            reduce using rule 55 (expr -> ~ expr .)
    OR              reduce using rule 55 (expr -> ~ expr .)
    AND             reduce using rule 55 (expr -> ~ expr .)
    GREATEREQ       reduce using rule 55 (expr -> ~ expr .)
    LESSEQ          reduce using rule 55 (expr -> ~ expr .)
    NOTEQ           reduce using rule 55 (expr -> ~ expr .)
    EQEQ            reduce using rule 55 (expr -> ~ expr .)
    PIPE            reduce using rule 55 (expr -> ~ expr .)
    ?               reduce using rule 55 (expr -> ~ expr .)
    ]               reduce using rule 55 (expr -> ~ expr .)
    ,               reduce using rule 55 (expr -> ~ expr .)
    )               reduce using rule 55 (expr -> ~ expr .)
    {               reduce using rule 55 (expr -> ~ expr .)
    LET             reduce using rule 55 (expr -> ~ expr .)
    END             reduce using rule 55 (expr -> ~ expr .)
    BEGIN           reduce using rule 55 (expr -> ~ expr .)
    NIL             reduce using rule 55 (expr -> ~ expr .)
    FALSE           reduce using rule 55 (expr -> ~ expr .)
    TRUE            reduce using rule 55 (expr -> ~ expr .)
    STRING          reduce using rule 55 (expr -> ~ expr .)
    FLOAT           reduce using rule 55 (expr -> ~ expr .)
    INT             reduce using rule 55 (expr -> ~ expr .)
    (               reduce using rule 55 (expr -> ~ expr .)
    !               reduce using rule 55 (expr -> ~ expr .)
    ~               reduce using rule 55 (expr -> ~ expr .)
    ID              reduce using rule 55 (expr -> ~ expr .)
    TYPEOF          reduce using rule 55 (expr -> ~ expr .)
    LAMBDA          reduce using rule 55 (expr -> ~ expr .)
    DEC             reduce using rule 55 (expr -> ~ expr .)
    INC             reduce using rule 55 (expr -> ~ expr .)
    CLASS           reduce using rule 55 (expr -> ~ expr .)
    STRUCT          reduce using rule 55 (expr -> ~ expr .)
    IF              reduce using rule 55 (expr -> ~ expr .)
    FOR             reduce using rule 55 (expr -> ~ expr .)
    WHILE           reduce using rule 55 (expr -> ~ expr .)
    RETURN          reduce using rule 55 (expr -> ~ expr .)
    FN              reduce using rule 55 (expr -> ~ expr .)
    IMPORT          reduce using rule 55 (expr -> ~ expr .)
    [               reduce using rule 55 (expr -> ~ expr .)
    :               reduce using rule 55 (expr -> ~ expr .)
    }               reduce using rule 55 (expr -> ~ expr .)


state 103

    (70) expr -> ID DOUBLECOLON . ID ( args )
    ID              shift and go to state 163


state 104

    (71) expr -> ID ( . args )
    (111) args -> . empty
    (112) args -> . arg
    (113) args -> . args , arg
    (104) empty -> .
    (114) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    args                           shift and go to state 164
    empty                          shift and go to state 165
    arg                            shift and go to state 166
    expr                           shift and go to state 167
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 105

    (75) expr -> ID LEFTARROW . { struct_init_exprs }
    {               shift and go to state 168


state 106

    (73) expr -> TYPEOF expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 73 (expr -> TYPEOF expr .)
    ]               reduce using rule 73 (expr -> TYPEOF expr .)
    ,               reduce using rule 73 (expr -> TYPEOF expr .)
    )               reduce using rule 73 (expr -> TYPEOF expr .)
    {               reduce using rule 73 (expr -> TYPEOF expr .)
    LET             reduce using rule 73 (expr -> TYPEOF expr .)
    END             reduce using rule 73 (expr -> TYPEOF expr .)
    BEGIN           reduce using rule 73 (expr -> TYPEOF expr .)
    NIL             reduce using rule 73 (expr -> TYPEOF expr .)
    FALSE           reduce using rule 73 (expr -> TYPEOF expr .)
    TRUE            reduce using rule 73 (expr -> TYPEOF expr .)
    STRING          reduce using rule 73 (expr -> TYPEOF expr .)
    FLOAT           reduce using rule 73 (expr -> TYPEOF expr .)
    INT             reduce using rule 73 (expr -> TYPEOF expr .)
    (               reduce using rule 73 (expr -> TYPEOF expr .)
    !               reduce using rule 73 (expr -> TYPEOF expr .)
    ~               reduce using rule 73 (expr -> TYPEOF expr .)
    ID              reduce using rule 73 (expr -> TYPEOF expr .)
    TYPEOF          reduce using rule 73 (expr -> TYPEOF expr .)
    LAMBDA          reduce using rule 73 (expr -> TYPEOF expr .)
    DEC             reduce using rule 73 (expr -> TYPEOF expr .)
    INC             reduce using rule 73 (expr -> TYPEOF expr .)
    CLASS           reduce using rule 73 (expr -> TYPEOF expr .)
    STRUCT          reduce using rule 73 (expr -> TYPEOF expr .)
    IF              reduce using rule 73 (expr -> TYPEOF expr .)
    FOR             reduce using rule 73 (expr -> TYPEOF expr .)
    WHILE           reduce using rule 73 (expr -> TYPEOF expr .)
    RETURN          reduce using rule 73 (expr -> TYPEOF expr .)
    FN              reduce using rule 73 (expr -> TYPEOF expr .)
    IMPORT          reduce using rule 73 (expr -> TYPEOF expr .)
    [               reduce using rule 73 (expr -> TYPEOF expr .)
    :               reduce using rule 73 (expr -> TYPEOF expr .)
    }               reduce using rule 73 (expr -> TYPEOF expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 107

    (74) expr -> LAMBDA ( . params ) ARROW expr
    (107) params -> . empty
    (108) params -> . param
    (109) params -> . params , param
    (104) empty -> .
    (110) param -> . ID : var_type
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    ID              shift and go to state 172

    params                         shift and go to state 169
    empty                          shift and go to state 170
    param                          shift and go to state 171

state 108

    (81) var_assign -> DEC var .
    (102) var -> var . [ expr ]
    SEP             reduce using rule 81 (var_assign -> DEC var .)
    {               reduce using rule 81 (var_assign -> DEC var .)
    LET             reduce using rule 81 (var_assign -> DEC var .)
    END             reduce using rule 81 (var_assign -> DEC var .)
    BEGIN           reduce using rule 81 (var_assign -> DEC var .)
    NIL             reduce using rule 81 (var_assign -> DEC var .)
    FALSE           reduce using rule 81 (var_assign -> DEC var .)
    TRUE            reduce using rule 81 (var_assign -> DEC var .)
    STRING          reduce using rule 81 (var_assign -> DEC var .)
    FLOAT           reduce using rule 81 (var_assign -> DEC var .)
    INT             reduce using rule 81 (var_assign -> DEC var .)
    (               reduce using rule 81 (var_assign -> DEC var .)
    !               reduce using rule 81 (var_assign -> DEC var .)
    +               reduce using rule 81 (var_assign -> DEC var .)
    -               reduce using rule 81 (var_assign -> DEC var .)
    ~               reduce using rule 81 (var_assign -> DEC var .)
    ID              reduce using rule 81 (var_assign -> DEC var .)
    TYPEOF          reduce using rule 81 (var_assign -> DEC var .)
    LAMBDA          reduce using rule 81 (var_assign -> DEC var .)
    DEC             reduce using rule 81 (var_assign -> DEC var .)
    INC             reduce using rule 81 (var_assign -> DEC var .)
    CLASS           reduce using rule 81 (var_assign -> DEC var .)
    STRUCT          reduce using rule 81 (var_assign -> DEC var .)
    IF              reduce using rule 81 (var_assign -> DEC var .)
    FOR             reduce using rule 81 (var_assign -> DEC var .)
    WHILE           reduce using rule 81 (var_assign -> DEC var .)
    RETURN          reduce using rule 81 (var_assign -> DEC var .)
    FN              reduce using rule 81 (var_assign -> DEC var .)
    IMPORT          reduce using rule 81 (var_assign -> DEC var .)
    [               reduce using rule 81 (var_assign -> DEC var .)


state 109

    (103) var -> ID .
    [               reduce using rule 103 (var -> ID .)
    SEP             reduce using rule 103 (var -> ID .)
    {               reduce using rule 103 (var -> ID .)
    LET             reduce using rule 103 (var -> ID .)
    END             reduce using rule 103 (var -> ID .)
    BEGIN           reduce using rule 103 (var -> ID .)
    NIL             reduce using rule 103 (var -> ID .)
    FALSE           reduce using rule 103 (var -> ID .)
    TRUE            reduce using rule 103 (var -> ID .)
    STRING          reduce using rule 103 (var -> ID .)
    FLOAT           reduce using rule 103 (var -> ID .)
    INT             reduce using rule 103 (var -> ID .)
    (               reduce using rule 103 (var -> ID .)
    !               reduce using rule 103 (var -> ID .)
    +               reduce using rule 103 (var -> ID .)
    -               reduce using rule 103 (var -> ID .)
    ~               reduce using rule 103 (var -> ID .)
    ID              reduce using rule 103 (var -> ID .)
    TYPEOF          reduce using rule 103 (var -> ID .)
    LAMBDA          reduce using rule 103 (var -> ID .)
    DEC             reduce using rule 103 (var -> ID .)
    INC             reduce using rule 103 (var -> ID .)
    CLASS           reduce using rule 103 (var -> ID .)
    STRUCT          reduce using rule 103 (var -> ID .)
    IF              reduce using rule 103 (var -> ID .)
    FOR             reduce using rule 103 (var -> ID .)
    WHILE           reduce using rule 103 (var -> ID .)
    RETURN          reduce using rule 103 (var -> ID .)
    FN              reduce using rule 103 (var -> ID .)
    IMPORT          reduce using rule 103 (var -> ID .)
    SHRASGN         reduce using rule 103 (var -> ID .)
    SHLASGN         reduce using rule 103 (var -> ID .)
    XORASGN         reduce using rule 103 (var -> ID .)
    ORASGN          reduce using rule 103 (var -> ID .)
    ANDASGN         reduce using rule 103 (var -> ID .)
    MODULOASGN      reduce using rule 103 (var -> ID .)
    SLASHASGN       reduce using rule 103 (var -> ID .)
    STARASGN        reduce using rule 103 (var -> ID .)
    MINUSASGN       reduce using rule 103 (var -> ID .)
    PLUSASGN        reduce using rule 103 (var -> ID .)
    ASSIGN          reduce using rule 103 (var -> ID .)


state 110

    (82) var_assign -> INC var .
    (102) var -> var . [ expr ]
    SEP             reduce using rule 82 (var_assign -> INC var .)
    {               reduce using rule 82 (var_assign -> INC var .)
    LET             reduce using rule 82 (var_assign -> INC var .)
    END             reduce using rule 82 (var_assign -> INC var .)
    BEGIN           reduce using rule 82 (var_assign -> INC var .)
    NIL             reduce using rule 82 (var_assign -> INC var .)
    FALSE           reduce using rule 82 (var_assign -> INC var .)
    TRUE            reduce using rule 82 (var_assign -> INC var .)
    STRING          reduce using rule 82 (var_assign -> INC var .)
    FLOAT           reduce using rule 82 (var_assign -> INC var .)
    INT             reduce using rule 82 (var_assign -> INC var .)
    (               reduce using rule 82 (var_assign -> INC var .)
    !               reduce using rule 82 (var_assign -> INC var .)
    +               reduce using rule 82 (var_assign -> INC var .)
    -               reduce using rule 82 (var_assign -> INC var .)
    ~               reduce using rule 82 (var_assign -> INC var .)
    ID              reduce using rule 82 (var_assign -> INC var .)
    TYPEOF          reduce using rule 82 (var_assign -> INC var .)
    LAMBDA          reduce using rule 82 (var_assign -> INC var .)
    DEC             reduce using rule 82 (var_assign -> INC var .)
    INC             reduce using rule 82 (var_assign -> INC var .)
    CLASS           reduce using rule 82 (var_assign -> INC var .)
    STRUCT          reduce using rule 82 (var_assign -> INC var .)
    IF              reduce using rule 82 (var_assign -> INC var .)
    FOR             reduce using rule 82 (var_assign -> INC var .)
    WHILE           reduce using rule 82 (var_assign -> INC var .)
    RETURN          reduce using rule 82 (var_assign -> INC var .)
    FN              reduce using rule 82 (var_assign -> INC var .)
    IMPORT          reduce using rule 82 (var_assign -> INC var .)
    [               reduce using rule 82 (var_assign -> INC var .)


state 111

    (19) class_definition -> CLASS ID . { function_definitions }
    {               shift and go to state 173


state 112

    (23) struct_definition -> STRUCT ID . { struct_fields } SEP
    {               shift and go to state 174


state 113

    (94) if_statement -> IF expr . block
    (95) if_statement -> IF expr . block ELSE block
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    (105) block -> . statement
    (106) block -> . { program }
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 176
    +               shift and go to state 177
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71
    {               shift and go to state 179
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    expr                           shift and go to state 7
    block                          shift and go to state 175
    statement                      shift and go to state 178
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 114

    (97) for_statement -> FOR var_assign . SEP expr SEP var_assign block
    SEP             shift and go to state 180


state 115

    (83) var_assign -> var . SHRASGN expr
    (84) var_assign -> var . SHLASGN expr
    (85) var_assign -> var . XORASGN expr
    (86) var_assign -> var . ORASGN expr
    (87) var_assign -> var . ANDASGN expr
    (88) var_assign -> var . MODULOASGN expr
    (89) var_assign -> var . SLASHASGN expr
    (90) var_assign -> var . STARASGN expr
    (91) var_assign -> var . MINUSASGN expr
    (92) var_assign -> var . PLUSASGN expr
    (93) var_assign -> var . ASSIGN expr
    (102) var -> var . [ expr ]
    SHRASGN         shift and go to state 77
    SHLASGN         shift and go to state 78
    XORASGN         shift and go to state 79
    ORASGN          shift and go to state 80
    ANDASGN         shift and go to state 81
    MODULOASGN      shift and go to state 82
    SLASHASGN       shift and go to state 83
    STARASGN        shift and go to state 84
    MINUSASGN       shift and go to state 85
    PLUSASGN        shift and go to state 86
    ASSIGN          shift and go to state 87
    [               shift and go to state 142


state 116

    (96) while_statement -> WHILE expr . block
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    (105) block -> . statement
    (106) block -> . { program }
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 176
    +               shift and go to state 177
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71
    {               shift and go to state 179
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    expr                           shift and go to state 7
    block                          shift and go to state 181
    statement                      shift and go to state 178
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 117

    (80) return_statement -> RETURN expr . SEP
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             shift and go to state 182
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 118

    (34) function_definition -> FN ID . ( params ) block
    (               shift and go to state 183


state 119

    (33) import_statement -> IMPORT STRING . SEP
    SEP             shift and go to state 184


state 120

    (47) expr -> expr % expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 47 (expr -> expr % expr .)
    %               reduce using rule 47 (expr -> expr % expr .)
    /               reduce using rule 47 (expr -> expr % expr .)
    *               reduce using rule 47 (expr -> expr % expr .)
    -               reduce using rule 47 (expr -> expr % expr .)
    +               reduce using rule 47 (expr -> expr % expr .)
    |               reduce using rule 47 (expr -> expr % expr .)
    ^               reduce using rule 47 (expr -> expr % expr .)
    &               reduce using rule 47 (expr -> expr % expr .)
    SHR             reduce using rule 47 (expr -> expr % expr .)
    SHL             reduce using rule 47 (expr -> expr % expr .)
    GREATER         reduce using rule 47 (expr -> expr % expr .)
    LESS            reduce using rule 47 (expr -> expr % expr .)
    OR              reduce using rule 47 (expr -> expr % expr .)
    AND             reduce using rule 47 (expr -> expr % expr .)
    GREATEREQ       reduce using rule 47 (expr -> expr % expr .)
    LESSEQ          reduce using rule 47 (expr -> expr % expr .)
    NOTEQ           reduce using rule 47 (expr -> expr % expr .)
    EQEQ            reduce using rule 47 (expr -> expr % expr .)
    PIPE            reduce using rule 47 (expr -> expr % expr .)
    ?               reduce using rule 47 (expr -> expr % expr .)
    ]               reduce using rule 47 (expr -> expr % expr .)
    ,               reduce using rule 47 (expr -> expr % expr .)
    )               reduce using rule 47 (expr -> expr % expr .)
    {               reduce using rule 47 (expr -> expr % expr .)
    LET             reduce using rule 47 (expr -> expr % expr .)
    END             reduce using rule 47 (expr -> expr % expr .)
    BEGIN           reduce using rule 47 (expr -> expr % expr .)
    NIL             reduce using rule 47 (expr -> expr % expr .)
    FALSE           reduce using rule 47 (expr -> expr % expr .)
    TRUE            reduce using rule 47 (expr -> expr % expr .)
    STRING          reduce using rule 47 (expr -> expr % expr .)
    FLOAT           reduce using rule 47 (expr -> expr % expr .)
    INT             reduce using rule 47 (expr -> expr % expr .)
    (               reduce using rule 47 (expr -> expr % expr .)
    !               reduce using rule 47 (expr -> expr % expr .)
    ~               reduce using rule 47 (expr -> expr % expr .)
    ID              reduce using rule 47 (expr -> expr % expr .)
    TYPEOF          reduce using rule 47 (expr -> expr % expr .)
    LAMBDA          reduce using rule 47 (expr -> expr % expr .)
    DEC             reduce using rule 47 (expr -> expr % expr .)
    INC             reduce using rule 47 (expr -> expr % expr .)
    CLASS           reduce using rule 47 (expr -> expr % expr .)
    STRUCT          reduce using rule 47 (expr -> expr % expr .)
    IF              reduce using rule 47 (expr -> expr % expr .)
    FOR             reduce using rule 47 (expr -> expr % expr .)
    WHILE           reduce using rule 47 (expr -> expr % expr .)
    RETURN          reduce using rule 47 (expr -> expr % expr .)
    FN              reduce using rule 47 (expr -> expr % expr .)
    IMPORT          reduce using rule 47 (expr -> expr % expr .)
    [               reduce using rule 47 (expr -> expr % expr .)
    :               reduce using rule 47 (expr -> expr % expr .)
    }               reduce using rule 47 (expr -> expr % expr .)


state 121

    (48) expr -> expr / expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 48 (expr -> expr / expr .)
    %               reduce using rule 48 (expr -> expr / expr .)
    /               reduce using rule 48 (expr -> expr / expr .)
    *               reduce using rule 48 (expr -> expr / expr .)
    -               reduce using rule 48 (expr -> expr / expr .)
    +               reduce using rule 48 (expr -> expr / expr .)
    |               reduce using rule 48 (expr -> expr / expr .)
    ^               reduce using rule 48 (expr -> expr / expr .)
    &               reduce using rule 48 (expr -> expr / expr .)
    SHR             reduce using rule 48 (expr -> expr / expr .)
    SHL             reduce using rule 48 (expr -> expr / expr .)
    GREATER         reduce using rule 48 (expr -> expr / expr .)
    LESS            reduce using rule 48 (expr -> expr / expr .)
    OR              reduce using rule 48 (expr -> expr / expr .)
    AND             reduce using rule 48 (expr -> expr / expr .)
    GREATEREQ       reduce using rule 48 (expr -> expr / expr .)
    LESSEQ          reduce using rule 48 (expr -> expr / expr .)
    NOTEQ           reduce using rule 48 (expr -> expr / expr .)
    EQEQ            reduce using rule 48 (expr -> expr / expr .)
    PIPE            reduce using rule 48 (expr -> expr / expr .)
    ?               reduce using rule 48 (expr -> expr / expr .)
    ]               reduce using rule 48 (expr -> expr / expr .)
    ,               reduce using rule 48 (expr -> expr / expr .)
    )               reduce using rule 48 (expr -> expr / expr .)
    {               reduce using rule 48 (expr -> expr / expr .)
    LET             reduce using rule 48 (expr -> expr / expr .)
    END             reduce using rule 48 (expr -> expr / expr .)
    BEGIN           reduce using rule 48 (expr -> expr / expr .)
    NIL             reduce using rule 48 (expr -> expr / expr .)
    FALSE           reduce using rule 48 (expr -> expr / expr .)
    TRUE            reduce using rule 48 (expr -> expr / expr .)
    STRING          reduce using rule 48 (expr -> expr / expr .)
    FLOAT           reduce using rule 48 (expr -> expr / expr .)
    INT             reduce using rule 48 (expr -> expr / expr .)
    (               reduce using rule 48 (expr -> expr / expr .)
    !               reduce using rule 48 (expr -> expr / expr .)
    ~               reduce using rule 48 (expr -> expr / expr .)
    ID              reduce using rule 48 (expr -> expr / expr .)
    TYPEOF          reduce using rule 48 (expr -> expr / expr .)
    LAMBDA          reduce using rule 48 (expr -> expr / expr .)
    DEC             reduce using rule 48 (expr -> expr / expr .)
    INC             reduce using rule 48 (expr -> expr / expr .)
    CLASS           reduce using rule 48 (expr -> expr / expr .)
    STRUCT          reduce using rule 48 (expr -> expr / expr .)
    IF              reduce using rule 48 (expr -> expr / expr .)
    FOR             reduce using rule 48 (expr -> expr / expr .)
    WHILE           reduce using rule 48 (expr -> expr / expr .)
    RETURN          reduce using rule 48 (expr -> expr / expr .)
    FN              reduce using rule 48 (expr -> expr / expr .)
    IMPORT          reduce using rule 48 (expr -> expr / expr .)
    [               reduce using rule 48 (expr -> expr / expr .)
    :               reduce using rule 48 (expr -> expr / expr .)
    }               reduce using rule 48 (expr -> expr / expr .)


state 122

    (49) expr -> expr * expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 49 (expr -> expr * expr .)
    %               reduce using rule 49 (expr -> expr * expr .)
    /               reduce using rule 49 (expr -> expr * expr .)
    *               reduce using rule 49 (expr -> expr * expr .)
    -               reduce using rule 49 (expr -> expr * expr .)
    +               reduce using rule 49 (expr -> expr * expr .)
    |               reduce using rule 49 (expr -> expr * expr .)
    ^               reduce using rule 49 (expr -> expr * expr .)
    &               reduce using rule 49 (expr -> expr * expr .)
    SHR             reduce using rule 49 (expr -> expr * expr .)
    SHL             reduce using rule 49 (expr -> expr * expr .)
    GREATER         reduce using rule 49 (expr -> expr * expr .)
    LESS            reduce using rule 49 (expr -> expr * expr .)
    OR              reduce using rule 49 (expr -> expr * expr .)
    AND             reduce using rule 49 (expr -> expr * expr .)
    GREATEREQ       reduce using rule 49 (expr -> expr * expr .)
    LESSEQ          reduce using rule 49 (expr -> expr * expr .)
    NOTEQ           reduce using rule 49 (expr -> expr * expr .)
    EQEQ            reduce using rule 49 (expr -> expr * expr .)
    PIPE            reduce using rule 49 (expr -> expr * expr .)
    ?               reduce using rule 49 (expr -> expr * expr .)
    ]               reduce using rule 49 (expr -> expr * expr .)
    ,               reduce using rule 49 (expr -> expr * expr .)
    )               reduce using rule 49 (expr -> expr * expr .)
    {               reduce using rule 49 (expr -> expr * expr .)
    LET             reduce using rule 49 (expr -> expr * expr .)
    END             reduce using rule 49 (expr -> expr * expr .)
    BEGIN           reduce using rule 49 (expr -> expr * expr .)
    NIL             reduce using rule 49 (expr -> expr * expr .)
    FALSE           reduce using rule 49 (expr -> expr * expr .)
    TRUE            reduce using rule 49 (expr -> expr * expr .)
    STRING          reduce using rule 49 (expr -> expr * expr .)
    FLOAT           reduce using rule 49 (expr -> expr * expr .)
    INT             reduce using rule 49 (expr -> expr * expr .)
    (               reduce using rule 49 (expr -> expr * expr .)
    !               reduce using rule 49 (expr -> expr * expr .)
    ~               reduce using rule 49 (expr -> expr * expr .)
    ID              reduce using rule 49 (expr -> expr * expr .)
    TYPEOF          reduce using rule 49 (expr -> expr * expr .)
    LAMBDA          reduce using rule 49 (expr -> expr * expr .)
    DEC             reduce using rule 49 (expr -> expr * expr .)
    INC             reduce using rule 49 (expr -> expr * expr .)
    CLASS           reduce using rule 49 (expr -> expr * expr .)
    STRUCT          reduce using rule 49 (expr -> expr * expr .)
    IF              reduce using rule 49 (expr -> expr * expr .)
    FOR             reduce using rule 49 (expr -> expr * expr .)
    WHILE           reduce using rule 49 (expr -> expr * expr .)
    RETURN          reduce using rule 49 (expr -> expr * expr .)
    FN              reduce using rule 49 (expr -> expr * expr .)
    IMPORT          reduce using rule 49 (expr -> expr * expr .)
    [               reduce using rule 49 (expr -> expr * expr .)
    :               reduce using rule 49 (expr -> expr * expr .)
    }               reduce using rule 49 (expr -> expr * expr .)


state 123

    (50) expr -> expr - expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 50 (expr -> expr - expr .)
    -               reduce using rule 50 (expr -> expr - expr .)
    +               reduce using rule 50 (expr -> expr - expr .)
    |               reduce using rule 50 (expr -> expr - expr .)
    ^               reduce using rule 50 (expr -> expr - expr .)
    &               reduce using rule 50 (expr -> expr - expr .)
    SHR             reduce using rule 50 (expr -> expr - expr .)
    SHL             reduce using rule 50 (expr -> expr - expr .)
    GREATER         reduce using rule 50 (expr -> expr - expr .)
    LESS            reduce using rule 50 (expr -> expr - expr .)
    OR              reduce using rule 50 (expr -> expr - expr .)
    AND             reduce using rule 50 (expr -> expr - expr .)
    GREATEREQ       reduce using rule 50 (expr -> expr - expr .)
    LESSEQ          reduce using rule 50 (expr -> expr - expr .)
    NOTEQ           reduce using rule 50 (expr -> expr - expr .)
    EQEQ            reduce using rule 50 (expr -> expr - expr .)
    PIPE            reduce using rule 50 (expr -> expr - expr .)
    ?               reduce using rule 50 (expr -> expr - expr .)
    ]               reduce using rule 50 (expr -> expr - expr .)
    ,               reduce using rule 50 (expr -> expr - expr .)
    )               reduce using rule 50 (expr -> expr - expr .)
    {               reduce using rule 50 (expr -> expr - expr .)
    LET             reduce using rule 50 (expr -> expr - expr .)
    END             reduce using rule 50 (expr -> expr - expr .)
    BEGIN           reduce using rule 50 (expr -> expr - expr .)
    NIL             reduce using rule 50 (expr -> expr - expr .)
    FALSE           reduce using rule 50 (expr -> expr - expr .)
    TRUE            reduce using rule 50 (expr -> expr - expr .)
    STRING          reduce using rule 50 (expr -> expr - expr .)
    FLOAT           reduce using rule 50 (expr -> expr - expr .)
    INT             reduce using rule 50 (expr -> expr - expr .)
    (               reduce using rule 50 (expr -> expr - expr .)
    !               reduce using rule 50 (expr -> expr - expr .)
    ~               reduce using rule 50 (expr -> expr - expr .)
    ID              reduce using rule 50 (expr -> expr - expr .)
    TYPEOF          reduce using rule 50 (expr -> expr - expr .)
    LAMBDA          reduce using rule 50 (expr -> expr - expr .)
    DEC             reduce using rule 50 (expr -> expr - expr .)
    INC             reduce using rule 50 (expr -> expr - expr .)
    CLASS           reduce using rule 50 (expr -> expr - expr .)
    STRUCT          reduce using rule 50 (expr -> expr - expr .)
    IF              reduce using rule 50 (expr -> expr - expr .)
    FOR             reduce using rule 50 (expr -> expr - expr .)
    WHILE           reduce using rule 50 (expr -> expr - expr .)
    RETURN          reduce using rule 50 (expr -> expr - expr .)
    FN              reduce using rule 50 (expr -> expr - expr .)
    IMPORT          reduce using rule 50 (expr -> expr - expr .)
    [               reduce using rule 50 (expr -> expr - expr .)
    :               reduce using rule 50 (expr -> expr - expr .)
    }               reduce using rule 50 (expr -> expr - expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54


state 124

    (51) expr -> expr + expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 51 (expr -> expr + expr .)
    -               reduce using rule 51 (expr -> expr + expr .)
    +               reduce using rule 51 (expr -> expr + expr .)
    |               reduce using rule 51 (expr -> expr + expr .)
    ^               reduce using rule 51 (expr -> expr + expr .)
    &               reduce using rule 51 (expr -> expr + expr .)
    SHR             reduce using rule 51 (expr -> expr + expr .)
    SHL             reduce using rule 51 (expr -> expr + expr .)
    GREATER         reduce using rule 51 (expr -> expr + expr .)
    LESS            reduce using rule 51 (expr -> expr + expr .)
    OR              reduce using rule 51 (expr -> expr + expr .)
    AND             reduce using rule 51 (expr -> expr + expr .)
    GREATEREQ       reduce using rule 51 (expr -> expr + expr .)
    LESSEQ          reduce using rule 51 (expr -> expr + expr .)
    NOTEQ           reduce using rule 51 (expr -> expr + expr .)
    EQEQ            reduce using rule 51 (expr -> expr + expr .)
    PIPE            reduce using rule 51 (expr -> expr + expr .)
    ?               reduce using rule 51 (expr -> expr + expr .)
    ]               reduce using rule 51 (expr -> expr + expr .)
    ,               reduce using rule 51 (expr -> expr + expr .)
    )               reduce using rule 51 (expr -> expr + expr .)
    {               reduce using rule 51 (expr -> expr + expr .)
    LET             reduce using rule 51 (expr -> expr + expr .)
    END             reduce using rule 51 (expr -> expr + expr .)
    BEGIN           reduce using rule 51 (expr -> expr + expr .)
    NIL             reduce using rule 51 (expr -> expr + expr .)
    FALSE           reduce using rule 51 (expr -> expr + expr .)
    TRUE            reduce using rule 51 (expr -> expr + expr .)
    STRING          reduce using rule 51 (expr -> expr + expr .)
    FLOAT           reduce using rule 51 (expr -> expr + expr .)
    INT             reduce using rule 51 (expr -> expr + expr .)
    (               reduce using rule 51 (expr -> expr + expr .)
    !               reduce using rule 51 (expr -> expr + expr .)
    ~               reduce using rule 51 (expr -> expr + expr .)
    ID              reduce using rule 51 (expr -> expr + expr .)
    TYPEOF          reduce using rule 51 (expr -> expr + expr .)
    LAMBDA          reduce using rule 51 (expr -> expr + expr .)
    DEC             reduce using rule 51 (expr -> expr + expr .)
    INC             reduce using rule 51 (expr -> expr + expr .)
    CLASS           reduce using rule 51 (expr -> expr + expr .)
    STRUCT          reduce using rule 51 (expr -> expr + expr .)
    IF              reduce using rule 51 (expr -> expr + expr .)
    FOR             reduce using rule 51 (expr -> expr + expr .)
    WHILE           reduce using rule 51 (expr -> expr + expr .)
    RETURN          reduce using rule 51 (expr -> expr + expr .)
    FN              reduce using rule 51 (expr -> expr + expr .)
    IMPORT          reduce using rule 51 (expr -> expr + expr .)
    [               reduce using rule 51 (expr -> expr + expr .)
    :               reduce using rule 51 (expr -> expr + expr .)
    }               reduce using rule 51 (expr -> expr + expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54


state 125

    (56) expr -> expr | expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 56 (expr -> expr | expr .)
    |               reduce using rule 56 (expr -> expr | expr .)
    OR              reduce using rule 56 (expr -> expr | expr .)
    AND             reduce using rule 56 (expr -> expr | expr .)
    PIPE            reduce using rule 56 (expr -> expr | expr .)
    ?               reduce using rule 56 (expr -> expr | expr .)
    ]               reduce using rule 56 (expr -> expr | expr .)
    ,               reduce using rule 56 (expr -> expr | expr .)
    )               reduce using rule 56 (expr -> expr | expr .)
    {               reduce using rule 56 (expr -> expr | expr .)
    LET             reduce using rule 56 (expr -> expr | expr .)
    END             reduce using rule 56 (expr -> expr | expr .)
    BEGIN           reduce using rule 56 (expr -> expr | expr .)
    NIL             reduce using rule 56 (expr -> expr | expr .)
    FALSE           reduce using rule 56 (expr -> expr | expr .)
    TRUE            reduce using rule 56 (expr -> expr | expr .)
    STRING          reduce using rule 56 (expr -> expr | expr .)
    FLOAT           reduce using rule 56 (expr -> expr | expr .)
    INT             reduce using rule 56 (expr -> expr | expr .)
    (               reduce using rule 56 (expr -> expr | expr .)
    !               reduce using rule 56 (expr -> expr | expr .)
    ~               reduce using rule 56 (expr -> expr | expr .)
    ID              reduce using rule 56 (expr -> expr | expr .)
    TYPEOF          reduce using rule 56 (expr -> expr | expr .)
    LAMBDA          reduce using rule 56 (expr -> expr | expr .)
    DEC             reduce using rule 56 (expr -> expr | expr .)
    INC             reduce using rule 56 (expr -> expr | expr .)
    CLASS           reduce using rule 56 (expr -> expr | expr .)
    STRUCT          reduce using rule 56 (expr -> expr | expr .)
    IF              reduce using rule 56 (expr -> expr | expr .)
    FOR             reduce using rule 56 (expr -> expr | expr .)
    WHILE           reduce using rule 56 (expr -> expr | expr .)
    RETURN          reduce using rule 56 (expr -> expr | expr .)
    FN              reduce using rule 56 (expr -> expr | expr .)
    IMPORT          reduce using rule 56 (expr -> expr | expr .)
    [               reduce using rule 56 (expr -> expr | expr .)
    :               reduce using rule 56 (expr -> expr | expr .)
    }               reduce using rule 56 (expr -> expr | expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69


state 126

    (57) expr -> expr ^ expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 57 (expr -> expr ^ expr .)
    |               reduce using rule 57 (expr -> expr ^ expr .)
    ^               reduce using rule 57 (expr -> expr ^ expr .)
    OR              reduce using rule 57 (expr -> expr ^ expr .)
    AND             reduce using rule 57 (expr -> expr ^ expr .)
    PIPE            reduce using rule 57 (expr -> expr ^ expr .)
    ?               reduce using rule 57 (expr -> expr ^ expr .)
    ]               reduce using rule 57 (expr -> expr ^ expr .)
    ,               reduce using rule 57 (expr -> expr ^ expr .)
    )               reduce using rule 57 (expr -> expr ^ expr .)
    {               reduce using rule 57 (expr -> expr ^ expr .)
    LET             reduce using rule 57 (expr -> expr ^ expr .)
    END             reduce using rule 57 (expr -> expr ^ expr .)
    BEGIN           reduce using rule 57 (expr -> expr ^ expr .)
    NIL             reduce using rule 57 (expr -> expr ^ expr .)
    FALSE           reduce using rule 57 (expr -> expr ^ expr .)
    TRUE            reduce using rule 57 (expr -> expr ^ expr .)
    STRING          reduce using rule 57 (expr -> expr ^ expr .)
    FLOAT           reduce using rule 57 (expr -> expr ^ expr .)
    INT             reduce using rule 57 (expr -> expr ^ expr .)
    (               reduce using rule 57 (expr -> expr ^ expr .)
    !               reduce using rule 57 (expr -> expr ^ expr .)
    ~               reduce using rule 57 (expr -> expr ^ expr .)
    ID              reduce using rule 57 (expr -> expr ^ expr .)
    TYPEOF          reduce using rule 57 (expr -> expr ^ expr .)
    LAMBDA          reduce using rule 57 (expr -> expr ^ expr .)
    DEC             reduce using rule 57 (expr -> expr ^ expr .)
    INC             reduce using rule 57 (expr -> expr ^ expr .)
    CLASS           reduce using rule 57 (expr -> expr ^ expr .)
    STRUCT          reduce using rule 57 (expr -> expr ^ expr .)
    IF              reduce using rule 57 (expr -> expr ^ expr .)
    FOR             reduce using rule 57 (expr -> expr ^ expr .)
    WHILE           reduce using rule 57 (expr -> expr ^ expr .)
    RETURN          reduce using rule 57 (expr -> expr ^ expr .)
    FN              reduce using rule 57 (expr -> expr ^ expr .)
    IMPORT          reduce using rule 57 (expr -> expr ^ expr .)
    [               reduce using rule 57 (expr -> expr ^ expr .)
    :               reduce using rule 57 (expr -> expr ^ expr .)
    }               reduce using rule 57 (expr -> expr ^ expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69


state 127

    (58) expr -> expr & expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 58 (expr -> expr & expr .)
    |               reduce using rule 58 (expr -> expr & expr .)
    ^               reduce using rule 58 (expr -> expr & expr .)
    &               reduce using rule 58 (expr -> expr & expr .)
    OR              reduce using rule 58 (expr -> expr & expr .)
    AND             reduce using rule 58 (expr -> expr & expr .)
    PIPE            reduce using rule 58 (expr -> expr & expr .)
    ?               reduce using rule 58 (expr -> expr & expr .)
    ]               reduce using rule 58 (expr -> expr & expr .)
    ,               reduce using rule 58 (expr -> expr & expr .)
    )               reduce using rule 58 (expr -> expr & expr .)
    {               reduce using rule 58 (expr -> expr & expr .)
    LET             reduce using rule 58 (expr -> expr & expr .)
    END             reduce using rule 58 (expr -> expr & expr .)
    BEGIN           reduce using rule 58 (expr -> expr & expr .)
    NIL             reduce using rule 58 (expr -> expr & expr .)
    FALSE           reduce using rule 58 (expr -> expr & expr .)
    TRUE            reduce using rule 58 (expr -> expr & expr .)
    STRING          reduce using rule 58 (expr -> expr & expr .)
    FLOAT           reduce using rule 58 (expr -> expr & expr .)
    INT             reduce using rule 58 (expr -> expr & expr .)
    (               reduce using rule 58 (expr -> expr & expr .)
    !               reduce using rule 58 (expr -> expr & expr .)
    ~               reduce using rule 58 (expr -> expr & expr .)
    ID              reduce using rule 58 (expr -> expr & expr .)
    TYPEOF          reduce using rule 58 (expr -> expr & expr .)
    LAMBDA          reduce using rule 58 (expr -> expr & expr .)
    DEC             reduce using rule 58 (expr -> expr & expr .)
    INC             reduce using rule 58 (expr -> expr & expr .)
    CLASS           reduce using rule 58 (expr -> expr & expr .)
    STRUCT          reduce using rule 58 (expr -> expr & expr .)
    IF              reduce using rule 58 (expr -> expr & expr .)
    FOR             reduce using rule 58 (expr -> expr & expr .)
    WHILE           reduce using rule 58 (expr -> expr & expr .)
    RETURN          reduce using rule 58 (expr -> expr & expr .)
    FN              reduce using rule 58 (expr -> expr & expr .)
    IMPORT          reduce using rule 58 (expr -> expr & expr .)
    [               reduce using rule 58 (expr -> expr & expr .)
    :               reduce using rule 58 (expr -> expr & expr .)
    }               reduce using rule 58 (expr -> expr & expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69


state 128

    (59) expr -> expr SHR expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 59 (expr -> expr SHR expr .)
    |               reduce using rule 59 (expr -> expr SHR expr .)
    ^               reduce using rule 59 (expr -> expr SHR expr .)
    &               reduce using rule 59 (expr -> expr SHR expr .)
    SHR             reduce using rule 59 (expr -> expr SHR expr .)
    SHL             reduce using rule 59 (expr -> expr SHR expr .)
    GREATER         reduce using rule 59 (expr -> expr SHR expr .)
    LESS            reduce using rule 59 (expr -> expr SHR expr .)
    OR              reduce using rule 59 (expr -> expr SHR expr .)
    AND             reduce using rule 59 (expr -> expr SHR expr .)
    GREATEREQ       reduce using rule 59 (expr -> expr SHR expr .)
    LESSEQ          reduce using rule 59 (expr -> expr SHR expr .)
    NOTEQ           reduce using rule 59 (expr -> expr SHR expr .)
    EQEQ            reduce using rule 59 (expr -> expr SHR expr .)
    PIPE            reduce using rule 59 (expr -> expr SHR expr .)
    ?               reduce using rule 59 (expr -> expr SHR expr .)
    ]               reduce using rule 59 (expr -> expr SHR expr .)
    ,               reduce using rule 59 (expr -> expr SHR expr .)
    )               reduce using rule 59 (expr -> expr SHR expr .)
    {               reduce using rule 59 (expr -> expr SHR expr .)
    LET             reduce using rule 59 (expr -> expr SHR expr .)
    END             reduce using rule 59 (expr -> expr SHR expr .)
    BEGIN           reduce using rule 59 (expr -> expr SHR expr .)
    NIL             reduce using rule 59 (expr -> expr SHR expr .)
    FALSE           reduce using rule 59 (expr -> expr SHR expr .)
    TRUE            reduce using rule 59 (expr -> expr SHR expr .)
    STRING          reduce using rule 59 (expr -> expr SHR expr .)
    FLOAT           reduce using rule 59 (expr -> expr SHR expr .)
    INT             reduce using rule 59 (expr -> expr SHR expr .)
    (               reduce using rule 59 (expr -> expr SHR expr .)
    !               reduce using rule 59 (expr -> expr SHR expr .)
    ~               reduce using rule 59 (expr -> expr SHR expr .)
    ID              reduce using rule 59 (expr -> expr SHR expr .)
    TYPEOF          reduce using rule 59 (expr -> expr SHR expr .)
    LAMBDA          reduce using rule 59 (expr -> expr SHR expr .)
    DEC             reduce using rule 59 (expr -> expr SHR expr .)
    INC             reduce using rule 59 (expr -> expr SHR expr .)
    CLASS           reduce using rule 59 (expr -> expr SHR expr .)
    STRUCT          reduce using rule 59 (expr -> expr SHR expr .)
    IF              reduce using rule 59 (expr -> expr SHR expr .)
    FOR             reduce using rule 59 (expr -> expr SHR expr .)
    WHILE           reduce using rule 59 (expr -> expr SHR expr .)
    RETURN          reduce using rule 59 (expr -> expr SHR expr .)
    FN              reduce using rule 59 (expr -> expr SHR expr .)
    IMPORT          reduce using rule 59 (expr -> expr SHR expr .)
    [               reduce using rule 59 (expr -> expr SHR expr .)
    :               reduce using rule 59 (expr -> expr SHR expr .)
    }               reduce using rule 59 (expr -> expr SHR expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56


state 129

    (60) expr -> expr SHL expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 60 (expr -> expr SHL expr .)
    |               reduce using rule 60 (expr -> expr SHL expr .)
    ^               reduce using rule 60 (expr -> expr SHL expr .)
    &               reduce using rule 60 (expr -> expr SHL expr .)
    SHR             reduce using rule 60 (expr -> expr SHL expr .)
    SHL             reduce using rule 60 (expr -> expr SHL expr .)
    GREATER         reduce using rule 60 (expr -> expr SHL expr .)
    LESS            reduce using rule 60 (expr -> expr SHL expr .)
    OR              reduce using rule 60 (expr -> expr SHL expr .)
    AND             reduce using rule 60 (expr -> expr SHL expr .)
    GREATEREQ       reduce using rule 60 (expr -> expr SHL expr .)
    LESSEQ          reduce using rule 60 (expr -> expr SHL expr .)
    NOTEQ           reduce using rule 60 (expr -> expr SHL expr .)
    EQEQ            reduce using rule 60 (expr -> expr SHL expr .)
    PIPE            reduce using rule 60 (expr -> expr SHL expr .)
    ?               reduce using rule 60 (expr -> expr SHL expr .)
    ]               reduce using rule 60 (expr -> expr SHL expr .)
    ,               reduce using rule 60 (expr -> expr SHL expr .)
    )               reduce using rule 60 (expr -> expr SHL expr .)
    {               reduce using rule 60 (expr -> expr SHL expr .)
    LET             reduce using rule 60 (expr -> expr SHL expr .)
    END             reduce using rule 60 (expr -> expr SHL expr .)
    BEGIN           reduce using rule 60 (expr -> expr SHL expr .)
    NIL             reduce using rule 60 (expr -> expr SHL expr .)
    FALSE           reduce using rule 60 (expr -> expr SHL expr .)
    TRUE            reduce using rule 60 (expr -> expr SHL expr .)
    STRING          reduce using rule 60 (expr -> expr SHL expr .)
    FLOAT           reduce using rule 60 (expr -> expr SHL expr .)
    INT             reduce using rule 60 (expr -> expr SHL expr .)
    (               reduce using rule 60 (expr -> expr SHL expr .)
    !               reduce using rule 60 (expr -> expr SHL expr .)
    ~               reduce using rule 60 (expr -> expr SHL expr .)
    ID              reduce using rule 60 (expr -> expr SHL expr .)
    TYPEOF          reduce using rule 60 (expr -> expr SHL expr .)
    LAMBDA          reduce using rule 60 (expr -> expr SHL expr .)
    DEC             reduce using rule 60 (expr -> expr SHL expr .)
    INC             reduce using rule 60 (expr -> expr SHL expr .)
    CLASS           reduce using rule 60 (expr -> expr SHL expr .)
    STRUCT          reduce using rule 60 (expr -> expr SHL expr .)
    IF              reduce using rule 60 (expr -> expr SHL expr .)
    FOR             reduce using rule 60 (expr -> expr SHL expr .)
    WHILE           reduce using rule 60 (expr -> expr SHL expr .)
    RETURN          reduce using rule 60 (expr -> expr SHL expr .)
    FN              reduce using rule 60 (expr -> expr SHL expr .)
    IMPORT          reduce using rule 60 (expr -> expr SHL expr .)
    [               reduce using rule 60 (expr -> expr SHL expr .)
    :               reduce using rule 60 (expr -> expr SHL expr .)
    }               reduce using rule 60 (expr -> expr SHL expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56


state 130

    (61) expr -> expr GREATER expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 61 (expr -> expr GREATER expr .)
    |               reduce using rule 61 (expr -> expr GREATER expr .)
    ^               reduce using rule 61 (expr -> expr GREATER expr .)
    &               reduce using rule 61 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 61 (expr -> expr GREATER expr .)
    LESS            reduce using rule 61 (expr -> expr GREATER expr .)
    OR              reduce using rule 61 (expr -> expr GREATER expr .)
    AND             reduce using rule 61 (expr -> expr GREATER expr .)
    GREATEREQ       reduce using rule 61 (expr -> expr GREATER expr .)
    LESSEQ          reduce using rule 61 (expr -> expr GREATER expr .)
    NOTEQ           reduce using rule 61 (expr -> expr GREATER expr .)
    EQEQ            reduce using rule 61 (expr -> expr GREATER expr .)
    PIPE            reduce using rule 61 (expr -> expr GREATER expr .)
    ?               reduce using rule 61 (expr -> expr GREATER expr .)
    ]               reduce using rule 61 (expr -> expr GREATER expr .)
    ,               reduce using rule 61 (expr -> expr GREATER expr .)
    )               reduce using rule 61 (expr -> expr GREATER expr .)
    {               reduce using rule 61 (expr -> expr GREATER expr .)
    LET             reduce using rule 61 (expr -> expr GREATER expr .)
    END             reduce using rule 61 (expr -> expr GREATER expr .)
    BEGIN           reduce using rule 61 (expr -> expr GREATER expr .)
    NIL             reduce using rule 61 (expr -> expr GREATER expr .)
    FALSE           reduce using rule 61 (expr -> expr GREATER expr .)
    TRUE            reduce using rule 61 (expr -> expr GREATER expr .)
    STRING          reduce using rule 61 (expr -> expr GREATER expr .)
    FLOAT           reduce using rule 61 (expr -> expr GREATER expr .)
    INT             reduce using rule 61 (expr -> expr GREATER expr .)
    (               reduce using rule 61 (expr -> expr GREATER expr .)
    !               reduce using rule 61 (expr -> expr GREATER expr .)
    ~               reduce using rule 61 (expr -> expr GREATER expr .)
    ID              reduce using rule 61 (expr -> expr GREATER expr .)
    TYPEOF          reduce using rule 61 (expr -> expr GREATER expr .)
    LAMBDA          reduce using rule 61 (expr -> expr GREATER expr .)
    DEC             reduce using rule 61 (expr -> expr GREATER expr .)
    INC             reduce using rule 61 (expr -> expr GREATER expr .)
    CLASS           reduce using rule 61 (expr -> expr GREATER expr .)
    STRUCT          reduce using rule 61 (expr -> expr GREATER expr .)
    IF              reduce using rule 61 (expr -> expr GREATER expr .)
    FOR             reduce using rule 61 (expr -> expr GREATER expr .)
    WHILE           reduce using rule 61 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 61 (expr -> expr GREATER expr .)
    FN              reduce using rule 61 (expr -> expr GREATER expr .)
    IMPORT          reduce using rule 61 (expr -> expr GREATER expr .)
    [               reduce using rule 61 (expr -> expr GREATER expr .)
    :               reduce using rule 61 (expr -> expr GREATER expr .)
    }               reduce using rule 61 (expr -> expr GREATER expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61


state 131

    (62) expr -> expr LESS expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 62 (expr -> expr LESS expr .)
    |               reduce using rule 62 (expr -> expr LESS expr .)
    ^               reduce using rule 62 (expr -> expr LESS expr .)
    &               reduce using rule 62 (expr -> expr LESS expr .)
    GREATER         reduce using rule 62 (expr -> expr LESS expr .)
    LESS            reduce using rule 62 (expr -> expr LESS expr .)
    OR              reduce using rule 62 (expr -> expr LESS expr .)
    AND             reduce using rule 62 (expr -> expr LESS expr .)
    GREATEREQ       reduce using rule 62 (expr -> expr LESS expr .)
    LESSEQ          reduce using rule 62 (expr -> expr LESS expr .)
    NOTEQ           reduce using rule 62 (expr -> expr LESS expr .)
    EQEQ            reduce using rule 62 (expr -> expr LESS expr .)
    PIPE            reduce using rule 62 (expr -> expr LESS expr .)
    ?               reduce using rule 62 (expr -> expr LESS expr .)
    ]               reduce using rule 62 (expr -> expr LESS expr .)
    ,               reduce using rule 62 (expr -> expr LESS expr .)
    )               reduce using rule 62 (expr -> expr LESS expr .)
    {               reduce using rule 62 (expr -> expr LESS expr .)
    LET             reduce using rule 62 (expr -> expr LESS expr .)
    END             reduce using rule 62 (expr -> expr LESS expr .)
    BEGIN           reduce using rule 62 (expr -> expr LESS expr .)
    NIL             reduce using rule 62 (expr -> expr LESS expr .)
    FALSE           reduce using rule 62 (expr -> expr LESS expr .)
    TRUE            reduce using rule 62 (expr -> expr LESS expr .)
    STRING          reduce using rule 62 (expr -> expr LESS expr .)
    FLOAT           reduce using rule 62 (expr -> expr LESS expr .)
    INT             reduce using rule 62 (expr -> expr LESS expr .)
    (               reduce using rule 62 (expr -> expr LESS expr .)
    !               reduce using rule 62 (expr -> expr LESS expr .)
    ~               reduce using rule 62 (expr -> expr LESS expr .)
    ID              reduce using rule 62 (expr -> expr LESS expr .)
    TYPEOF          reduce using rule 62 (expr -> expr LESS expr .)
    LAMBDA          reduce using rule 62 (expr -> expr LESS expr .)
    DEC             reduce using rule 62 (expr -> expr LESS expr .)
    INC             reduce using rule 62 (expr -> expr LESS expr .)
    CLASS           reduce using rule 62 (expr -> expr LESS expr .)
    STRUCT          reduce using rule 62 (expr -> expr LESS expr .)
    IF              reduce using rule 62 (expr -> expr LESS expr .)
    FOR             reduce using rule 62 (expr -> expr LESS expr .)
    WHILE           reduce using rule 62 (expr -> expr LESS expr .)
    RETURN          reduce using rule 62 (expr -> expr LESS expr .)
    FN              reduce using rule 62 (expr -> expr LESS expr .)
    IMPORT          reduce using rule 62 (expr -> expr LESS expr .)
    [               reduce using rule 62 (expr -> expr LESS expr .)
    :               reduce using rule 62 (expr -> expr LESS expr .)
    }               reduce using rule 62 (expr -> expr LESS expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61


state 132

    (63) expr -> expr OR expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 63 (expr -> expr OR expr .)
    OR              reduce using rule 63 (expr -> expr OR expr .)
    PIPE            reduce using rule 63 (expr -> expr OR expr .)
    ?               reduce using rule 63 (expr -> expr OR expr .)
    ]               reduce using rule 63 (expr -> expr OR expr .)
    ,               reduce using rule 63 (expr -> expr OR expr .)
    )               reduce using rule 63 (expr -> expr OR expr .)
    {               reduce using rule 63 (expr -> expr OR expr .)
    LET             reduce using rule 63 (expr -> expr OR expr .)
    END             reduce using rule 63 (expr -> expr OR expr .)
    BEGIN           reduce using rule 63 (expr -> expr OR expr .)
    NIL             reduce using rule 63 (expr -> expr OR expr .)
    FALSE           reduce using rule 63 (expr -> expr OR expr .)
    TRUE            reduce using rule 63 (expr -> expr OR expr .)
    STRING          reduce using rule 63 (expr -> expr OR expr .)
    FLOAT           reduce using rule 63 (expr -> expr OR expr .)
    INT             reduce using rule 63 (expr -> expr OR expr .)
    (               reduce using rule 63 (expr -> expr OR expr .)
    !               reduce using rule 63 (expr -> expr OR expr .)
    ~               reduce using rule 63 (expr -> expr OR expr .)
    ID              reduce using rule 63 (expr -> expr OR expr .)
    TYPEOF          reduce using rule 63 (expr -> expr OR expr .)
    LAMBDA          reduce using rule 63 (expr -> expr OR expr .)
    DEC             reduce using rule 63 (expr -> expr OR expr .)
    INC             reduce using rule 63 (expr -> expr OR expr .)
    CLASS           reduce using rule 63 (expr -> expr OR expr .)
    STRUCT          reduce using rule 63 (expr -> expr OR expr .)
    IF              reduce using rule 63 (expr -> expr OR expr .)
    FOR             reduce using rule 63 (expr -> expr OR expr .)
    WHILE           reduce using rule 63 (expr -> expr OR expr .)
    RETURN          reduce using rule 63 (expr -> expr OR expr .)
    FN              reduce using rule 63 (expr -> expr OR expr .)
    IMPORT          reduce using rule 63 (expr -> expr OR expr .)
    [               reduce using rule 63 (expr -> expr OR expr .)
    :               reduce using rule 63 (expr -> expr OR expr .)
    }               reduce using rule 63 (expr -> expr OR expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69


state 133

    (64) expr -> expr AND expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 64 (expr -> expr AND expr .)
    OR              reduce using rule 64 (expr -> expr AND expr .)
    AND             reduce using rule 64 (expr -> expr AND expr .)
    PIPE            reduce using rule 64 (expr -> expr AND expr .)
    ?               reduce using rule 64 (expr -> expr AND expr .)
    ]               reduce using rule 64 (expr -> expr AND expr .)
    ,               reduce using rule 64 (expr -> expr AND expr .)
    )               reduce using rule 64 (expr -> expr AND expr .)
    {               reduce using rule 64 (expr -> expr AND expr .)
    LET             reduce using rule 64 (expr -> expr AND expr .)
    END             reduce using rule 64 (expr -> expr AND expr .)
    BEGIN           reduce using rule 64 (expr -> expr AND expr .)
    NIL             reduce using rule 64 (expr -> expr AND expr .)
    FALSE           reduce using rule 64 (expr -> expr AND expr .)
    TRUE            reduce using rule 64 (expr -> expr AND expr .)
    STRING          reduce using rule 64 (expr -> expr AND expr .)
    FLOAT           reduce using rule 64 (expr -> expr AND expr .)
    INT             reduce using rule 64 (expr -> expr AND expr .)
    (               reduce using rule 64 (expr -> expr AND expr .)
    !               reduce using rule 64 (expr -> expr AND expr .)
    ~               reduce using rule 64 (expr -> expr AND expr .)
    ID              reduce using rule 64 (expr -> expr AND expr .)
    TYPEOF          reduce using rule 64 (expr -> expr AND expr .)
    LAMBDA          reduce using rule 64 (expr -> expr AND expr .)
    DEC             reduce using rule 64 (expr -> expr AND expr .)
    INC             reduce using rule 64 (expr -> expr AND expr .)
    CLASS           reduce using rule 64 (expr -> expr AND expr .)
    STRUCT          reduce using rule 64 (expr -> expr AND expr .)
    IF              reduce using rule 64 (expr -> expr AND expr .)
    FOR             reduce using rule 64 (expr -> expr AND expr .)
    WHILE           reduce using rule 64 (expr -> expr AND expr .)
    RETURN          reduce using rule 64 (expr -> expr AND expr .)
    FN              reduce using rule 64 (expr -> expr AND expr .)
    IMPORT          reduce using rule 64 (expr -> expr AND expr .)
    [               reduce using rule 64 (expr -> expr AND expr .)
    :               reduce using rule 64 (expr -> expr AND expr .)
    }               reduce using rule 64 (expr -> expr AND expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69


state 134

    (65) expr -> expr GREATEREQ expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    |               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    ^               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    &               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    GREATER         reduce using rule 65 (expr -> expr GREATEREQ expr .)
    LESS            reduce using rule 65 (expr -> expr GREATEREQ expr .)
    OR              reduce using rule 65 (expr -> expr GREATEREQ expr .)
    AND             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    GREATEREQ       reduce using rule 65 (expr -> expr GREATEREQ expr .)
    LESSEQ          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    NOTEQ           reduce using rule 65 (expr -> expr GREATEREQ expr .)
    EQEQ            reduce using rule 65 (expr -> expr GREATEREQ expr .)
    PIPE            reduce using rule 65 (expr -> expr GREATEREQ expr .)
    ?               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    ]               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    ,               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    )               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    {               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    LET             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    END             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    BEGIN           reduce using rule 65 (expr -> expr GREATEREQ expr .)
    NIL             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    FALSE           reduce using rule 65 (expr -> expr GREATEREQ expr .)
    TRUE            reduce using rule 65 (expr -> expr GREATEREQ expr .)
    STRING          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    FLOAT           reduce using rule 65 (expr -> expr GREATEREQ expr .)
    INT             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    (               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    !               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    ~               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    ID              reduce using rule 65 (expr -> expr GREATEREQ expr .)
    TYPEOF          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    LAMBDA          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    DEC             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    INC             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    CLASS           reduce using rule 65 (expr -> expr GREATEREQ expr .)
    STRUCT          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    IF              reduce using rule 65 (expr -> expr GREATEREQ expr .)
    FOR             reduce using rule 65 (expr -> expr GREATEREQ expr .)
    WHILE           reduce using rule 65 (expr -> expr GREATEREQ expr .)
    RETURN          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    FN              reduce using rule 65 (expr -> expr GREATEREQ expr .)
    IMPORT          reduce using rule 65 (expr -> expr GREATEREQ expr .)
    [               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    :               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    }               reduce using rule 65 (expr -> expr GREATEREQ expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61


state 135

    (66) expr -> expr LESSEQ expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 66 (expr -> expr LESSEQ expr .)
    |               reduce using rule 66 (expr -> expr LESSEQ expr .)
    ^               reduce using rule 66 (expr -> expr LESSEQ expr .)
    &               reduce using rule 66 (expr -> expr LESSEQ expr .)
    GREATER         reduce using rule 66 (expr -> expr LESSEQ expr .)
    LESS            reduce using rule 66 (expr -> expr LESSEQ expr .)
    OR              reduce using rule 66 (expr -> expr LESSEQ expr .)
    AND             reduce using rule 66 (expr -> expr LESSEQ expr .)
    GREATEREQ       reduce using rule 66 (expr -> expr LESSEQ expr .)
    LESSEQ          reduce using rule 66 (expr -> expr LESSEQ expr .)
    NOTEQ           reduce using rule 66 (expr -> expr LESSEQ expr .)
    EQEQ            reduce using rule 66 (expr -> expr LESSEQ expr .)
    PIPE            reduce using rule 66 (expr -> expr LESSEQ expr .)
    ?               reduce using rule 66 (expr -> expr LESSEQ expr .)
    ]               reduce using rule 66 (expr -> expr LESSEQ expr .)
    ,               reduce using rule 66 (expr -> expr LESSEQ expr .)
    )               reduce using rule 66 (expr -> expr LESSEQ expr .)
    {               reduce using rule 66 (expr -> expr LESSEQ expr .)
    LET             reduce using rule 66 (expr -> expr LESSEQ expr .)
    END             reduce using rule 66 (expr -> expr LESSEQ expr .)
    BEGIN           reduce using rule 66 (expr -> expr LESSEQ expr .)
    NIL             reduce using rule 66 (expr -> expr LESSEQ expr .)
    FALSE           reduce using rule 66 (expr -> expr LESSEQ expr .)
    TRUE            reduce using rule 66 (expr -> expr LESSEQ expr .)
    STRING          reduce using rule 66 (expr -> expr LESSEQ expr .)
    FLOAT           reduce using rule 66 (expr -> expr LESSEQ expr .)
    INT             reduce using rule 66 (expr -> expr LESSEQ expr .)
    (               reduce using rule 66 (expr -> expr LESSEQ expr .)
    !               reduce using rule 66 (expr -> expr LESSEQ expr .)
    ~               reduce using rule 66 (expr -> expr LESSEQ expr .)
    ID              reduce using rule 66 (expr -> expr LESSEQ expr .)
    TYPEOF          reduce using rule 66 (expr -> expr LESSEQ expr .)
    LAMBDA          reduce using rule 66 (expr -> expr LESSEQ expr .)
    DEC             reduce using rule 66 (expr -> expr LESSEQ expr .)
    INC             reduce using rule 66 (expr -> expr LESSEQ expr .)
    CLASS           reduce using rule 66 (expr -> expr LESSEQ expr .)
    STRUCT          reduce using rule 66 (expr -> expr LESSEQ expr .)
    IF              reduce using rule 66 (expr -> expr LESSEQ expr .)
    FOR             reduce using rule 66 (expr -> expr LESSEQ expr .)
    WHILE           reduce using rule 66 (expr -> expr LESSEQ expr .)
    RETURN          reduce using rule 66 (expr -> expr LESSEQ expr .)
    FN              reduce using rule 66 (expr -> expr LESSEQ expr .)
    IMPORT          reduce using rule 66 (expr -> expr LESSEQ expr .)
    [               reduce using rule 66 (expr -> expr LESSEQ expr .)
    :               reduce using rule 66 (expr -> expr LESSEQ expr .)
    }               reduce using rule 66 (expr -> expr LESSEQ expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61


state 136

    (67) expr -> expr NOTEQ expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 67 (expr -> expr NOTEQ expr .)
    |               reduce using rule 67 (expr -> expr NOTEQ expr .)
    ^               reduce using rule 67 (expr -> expr NOTEQ expr .)
    &               reduce using rule 67 (expr -> expr NOTEQ expr .)
    OR              reduce using rule 67 (expr -> expr NOTEQ expr .)
    AND             reduce using rule 67 (expr -> expr NOTEQ expr .)
    NOTEQ           reduce using rule 67 (expr -> expr NOTEQ expr .)
    EQEQ            reduce using rule 67 (expr -> expr NOTEQ expr .)
    PIPE            reduce using rule 67 (expr -> expr NOTEQ expr .)
    ?               reduce using rule 67 (expr -> expr NOTEQ expr .)
    ]               reduce using rule 67 (expr -> expr NOTEQ expr .)
    ,               reduce using rule 67 (expr -> expr NOTEQ expr .)
    )               reduce using rule 67 (expr -> expr NOTEQ expr .)
    {               reduce using rule 67 (expr -> expr NOTEQ expr .)
    LET             reduce using rule 67 (expr -> expr NOTEQ expr .)
    END             reduce using rule 67 (expr -> expr NOTEQ expr .)
    BEGIN           reduce using rule 67 (expr -> expr NOTEQ expr .)
    NIL             reduce using rule 67 (expr -> expr NOTEQ expr .)
    FALSE           reduce using rule 67 (expr -> expr NOTEQ expr .)
    TRUE            reduce using rule 67 (expr -> expr NOTEQ expr .)
    STRING          reduce using rule 67 (expr -> expr NOTEQ expr .)
    FLOAT           reduce using rule 67 (expr -> expr NOTEQ expr .)
    INT             reduce using rule 67 (expr -> expr NOTEQ expr .)
    (               reduce using rule 67 (expr -> expr NOTEQ expr .)
    !               reduce using rule 67 (expr -> expr NOTEQ expr .)
    ~               reduce using rule 67 (expr -> expr NOTEQ expr .)
    ID              reduce using rule 67 (expr -> expr NOTEQ expr .)
    TYPEOF          reduce using rule 67 (expr -> expr NOTEQ expr .)
    LAMBDA          reduce using rule 67 (expr -> expr NOTEQ expr .)
    DEC             reduce using rule 67 (expr -> expr NOTEQ expr .)
    INC             reduce using rule 67 (expr -> expr NOTEQ expr .)
    CLASS           reduce using rule 67 (expr -> expr NOTEQ expr .)
    STRUCT          reduce using rule 67 (expr -> expr NOTEQ expr .)
    IF              reduce using rule 67 (expr -> expr NOTEQ expr .)
    FOR             reduce using rule 67 (expr -> expr NOTEQ expr .)
    WHILE           reduce using rule 67 (expr -> expr NOTEQ expr .)
    RETURN          reduce using rule 67 (expr -> expr NOTEQ expr .)
    FN              reduce using rule 67 (expr -> expr NOTEQ expr .)
    IMPORT          reduce using rule 67 (expr -> expr NOTEQ expr .)
    [               reduce using rule 67 (expr -> expr NOTEQ expr .)
    :               reduce using rule 67 (expr -> expr NOTEQ expr .)
    }               reduce using rule 67 (expr -> expr NOTEQ expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67


state 137

    (68) expr -> expr EQEQ expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 68 (expr -> expr EQEQ expr .)
    |               reduce using rule 68 (expr -> expr EQEQ expr .)
    ^               reduce using rule 68 (expr -> expr EQEQ expr .)
    &               reduce using rule 68 (expr -> expr EQEQ expr .)
    OR              reduce using rule 68 (expr -> expr EQEQ expr .)
    AND             reduce using rule 68 (expr -> expr EQEQ expr .)
    NOTEQ           reduce using rule 68 (expr -> expr EQEQ expr .)
    EQEQ            reduce using rule 68 (expr -> expr EQEQ expr .)
    PIPE            reduce using rule 68 (expr -> expr EQEQ expr .)
    ?               reduce using rule 68 (expr -> expr EQEQ expr .)
    ]               reduce using rule 68 (expr -> expr EQEQ expr .)
    ,               reduce using rule 68 (expr -> expr EQEQ expr .)
    )               reduce using rule 68 (expr -> expr EQEQ expr .)
    {               reduce using rule 68 (expr -> expr EQEQ expr .)
    LET             reduce using rule 68 (expr -> expr EQEQ expr .)
    END             reduce using rule 68 (expr -> expr EQEQ expr .)
    BEGIN           reduce using rule 68 (expr -> expr EQEQ expr .)
    NIL             reduce using rule 68 (expr -> expr EQEQ expr .)
    FALSE           reduce using rule 68 (expr -> expr EQEQ expr .)
    TRUE            reduce using rule 68 (expr -> expr EQEQ expr .)
    STRING          reduce using rule 68 (expr -> expr EQEQ expr .)
    FLOAT           reduce using rule 68 (expr -> expr EQEQ expr .)
    INT             reduce using rule 68 (expr -> expr EQEQ expr .)
    (               reduce using rule 68 (expr -> expr EQEQ expr .)
    !               reduce using rule 68 (expr -> expr EQEQ expr .)
    ~               reduce using rule 68 (expr -> expr EQEQ expr .)
    ID              reduce using rule 68 (expr -> expr EQEQ expr .)
    TYPEOF          reduce using rule 68 (expr -> expr EQEQ expr .)
    LAMBDA          reduce using rule 68 (expr -> expr EQEQ expr .)
    DEC             reduce using rule 68 (expr -> expr EQEQ expr .)
    INC             reduce using rule 68 (expr -> expr EQEQ expr .)
    CLASS           reduce using rule 68 (expr -> expr EQEQ expr .)
    STRUCT          reduce using rule 68 (expr -> expr EQEQ expr .)
    IF              reduce using rule 68 (expr -> expr EQEQ expr .)
    FOR             reduce using rule 68 (expr -> expr EQEQ expr .)
    WHILE           reduce using rule 68 (expr -> expr EQEQ expr .)
    RETURN          reduce using rule 68 (expr -> expr EQEQ expr .)
    FN              reduce using rule 68 (expr -> expr EQEQ expr .)
    IMPORT          reduce using rule 68 (expr -> expr EQEQ expr .)
    [               reduce using rule 68 (expr -> expr EQEQ expr .)
    :               reduce using rule 68 (expr -> expr EQEQ expr .)
    }               reduce using rule 68 (expr -> expr EQEQ expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67


state 138

    (69) expr -> expr PIPE ID . ( args )
    (               shift and go to state 185


state 139

    (72) expr -> expr ? expr . : expr
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    :               shift and go to state 186
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 140

    (9) statement -> LET var : . var_type SEP
    (27) var_type -> . DICT_TYPE
    (28) var_type -> . LIST_TYPE
    (29) var_type -> . BOOL_TYPE
    (30) var_type -> . STRING_TYPE
    (31) var_type -> . FLOAT_TYPE
    (32) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 188
    LIST_TYPE       shift and go to state 189
    BOOL_TYPE       shift and go to state 190
    STRING_TYPE     shift and go to state 191
    FLOAT_TYPE      shift and go to state 192
    INT_TYPE        shift and go to state 193

    var_type                       shift and go to state 187

state 141

    (79) var_define -> LET var ASSIGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 194
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 142

    (102) var -> var [ . expr ]
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    var                            shift and go to state 97
    expr                           shift and go to state 195
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 143

    (78) var_define -> LET getter ASSIGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    getter                         shift and go to state 22
    expr                           shift and go to state 196
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 144

    (39) expr -> var [ expr . ]
    (102) var -> var [ expr . ]
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    ]               shift and go to state 197
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 145

    (83) var_assign -> var SHRASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    {               reduce using rule 83 (var_assign -> var SHRASGN expr .)
    LET             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    END             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    BEGIN           reduce using rule 83 (var_assign -> var SHRASGN expr .)
    NIL             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    FALSE           reduce using rule 83 (var_assign -> var SHRASGN expr .)
    TRUE            reduce using rule 83 (var_assign -> var SHRASGN expr .)
    STRING          reduce using rule 83 (var_assign -> var SHRASGN expr .)
    FLOAT           reduce using rule 83 (var_assign -> var SHRASGN expr .)
    INT             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    (               reduce using rule 83 (var_assign -> var SHRASGN expr .)
    !               reduce using rule 83 (var_assign -> var SHRASGN expr .)
    ~               reduce using rule 83 (var_assign -> var SHRASGN expr .)
    ID              reduce using rule 83 (var_assign -> var SHRASGN expr .)
    TYPEOF          reduce using rule 83 (var_assign -> var SHRASGN expr .)
    LAMBDA          reduce using rule 83 (var_assign -> var SHRASGN expr .)
    DEC             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    INC             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    CLASS           reduce using rule 83 (var_assign -> var SHRASGN expr .)
    STRUCT          reduce using rule 83 (var_assign -> var SHRASGN expr .)
    IF              reduce using rule 83 (var_assign -> var SHRASGN expr .)
    FOR             reduce using rule 83 (var_assign -> var SHRASGN expr .)
    WHILE           reduce using rule 83 (var_assign -> var SHRASGN expr .)
    RETURN          reduce using rule 83 (var_assign -> var SHRASGN expr .)
    FN              reduce using rule 83 (var_assign -> var SHRASGN expr .)
    IMPORT          reduce using rule 83 (var_assign -> var SHRASGN expr .)
    [               reduce using rule 83 (var_assign -> var SHRASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 146

    (84) var_assign -> var SHLASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    {               reduce using rule 84 (var_assign -> var SHLASGN expr .)
    LET             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    END             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    BEGIN           reduce using rule 84 (var_assign -> var SHLASGN expr .)
    NIL             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    FALSE           reduce using rule 84 (var_assign -> var SHLASGN expr .)
    TRUE            reduce using rule 84 (var_assign -> var SHLASGN expr .)
    STRING          reduce using rule 84 (var_assign -> var SHLASGN expr .)
    FLOAT           reduce using rule 84 (var_assign -> var SHLASGN expr .)
    INT             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    (               reduce using rule 84 (var_assign -> var SHLASGN expr .)
    !               reduce using rule 84 (var_assign -> var SHLASGN expr .)
    ~               reduce using rule 84 (var_assign -> var SHLASGN expr .)
    ID              reduce using rule 84 (var_assign -> var SHLASGN expr .)
    TYPEOF          reduce using rule 84 (var_assign -> var SHLASGN expr .)
    LAMBDA          reduce using rule 84 (var_assign -> var SHLASGN expr .)
    DEC             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    INC             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    CLASS           reduce using rule 84 (var_assign -> var SHLASGN expr .)
    STRUCT          reduce using rule 84 (var_assign -> var SHLASGN expr .)
    IF              reduce using rule 84 (var_assign -> var SHLASGN expr .)
    FOR             reduce using rule 84 (var_assign -> var SHLASGN expr .)
    WHILE           reduce using rule 84 (var_assign -> var SHLASGN expr .)
    RETURN          reduce using rule 84 (var_assign -> var SHLASGN expr .)
    FN              reduce using rule 84 (var_assign -> var SHLASGN expr .)
    IMPORT          reduce using rule 84 (var_assign -> var SHLASGN expr .)
    [               reduce using rule 84 (var_assign -> var SHLASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 147

    (85) var_assign -> var XORASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 85 (var_assign -> var XORASGN expr .)
    {               reduce using rule 85 (var_assign -> var XORASGN expr .)
    LET             reduce using rule 85 (var_assign -> var XORASGN expr .)
    END             reduce using rule 85 (var_assign -> var XORASGN expr .)
    BEGIN           reduce using rule 85 (var_assign -> var XORASGN expr .)
    NIL             reduce using rule 85 (var_assign -> var XORASGN expr .)
    FALSE           reduce using rule 85 (var_assign -> var XORASGN expr .)
    TRUE            reduce using rule 85 (var_assign -> var XORASGN expr .)
    STRING          reduce using rule 85 (var_assign -> var XORASGN expr .)
    FLOAT           reduce using rule 85 (var_assign -> var XORASGN expr .)
    INT             reduce using rule 85 (var_assign -> var XORASGN expr .)
    (               reduce using rule 85 (var_assign -> var XORASGN expr .)
    !               reduce using rule 85 (var_assign -> var XORASGN expr .)
    ~               reduce using rule 85 (var_assign -> var XORASGN expr .)
    ID              reduce using rule 85 (var_assign -> var XORASGN expr .)
    TYPEOF          reduce using rule 85 (var_assign -> var XORASGN expr .)
    LAMBDA          reduce using rule 85 (var_assign -> var XORASGN expr .)
    DEC             reduce using rule 85 (var_assign -> var XORASGN expr .)
    INC             reduce using rule 85 (var_assign -> var XORASGN expr .)
    CLASS           reduce using rule 85 (var_assign -> var XORASGN expr .)
    STRUCT          reduce using rule 85 (var_assign -> var XORASGN expr .)
    IF              reduce using rule 85 (var_assign -> var XORASGN expr .)
    FOR             reduce using rule 85 (var_assign -> var XORASGN expr .)
    WHILE           reduce using rule 85 (var_assign -> var XORASGN expr .)
    RETURN          reduce using rule 85 (var_assign -> var XORASGN expr .)
    FN              reduce using rule 85 (var_assign -> var XORASGN expr .)
    IMPORT          reduce using rule 85 (var_assign -> var XORASGN expr .)
    [               reduce using rule 85 (var_assign -> var XORASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 148

    (86) var_assign -> var ORASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 86 (var_assign -> var ORASGN expr .)
    {               reduce using rule 86 (var_assign -> var ORASGN expr .)
    LET             reduce using rule 86 (var_assign -> var ORASGN expr .)
    END             reduce using rule 86 (var_assign -> var ORASGN expr .)
    BEGIN           reduce using rule 86 (var_assign -> var ORASGN expr .)
    NIL             reduce using rule 86 (var_assign -> var ORASGN expr .)
    FALSE           reduce using rule 86 (var_assign -> var ORASGN expr .)
    TRUE            reduce using rule 86 (var_assign -> var ORASGN expr .)
    STRING          reduce using rule 86 (var_assign -> var ORASGN expr .)
    FLOAT           reduce using rule 86 (var_assign -> var ORASGN expr .)
    INT             reduce using rule 86 (var_assign -> var ORASGN expr .)
    (               reduce using rule 86 (var_assign -> var ORASGN expr .)
    !               reduce using rule 86 (var_assign -> var ORASGN expr .)
    ~               reduce using rule 86 (var_assign -> var ORASGN expr .)
    ID              reduce using rule 86 (var_assign -> var ORASGN expr .)
    TYPEOF          reduce using rule 86 (var_assign -> var ORASGN expr .)
    LAMBDA          reduce using rule 86 (var_assign -> var ORASGN expr .)
    DEC             reduce using rule 86 (var_assign -> var ORASGN expr .)
    INC             reduce using rule 86 (var_assign -> var ORASGN expr .)
    CLASS           reduce using rule 86 (var_assign -> var ORASGN expr .)
    STRUCT          reduce using rule 86 (var_assign -> var ORASGN expr .)
    IF              reduce using rule 86 (var_assign -> var ORASGN expr .)
    FOR             reduce using rule 86 (var_assign -> var ORASGN expr .)
    WHILE           reduce using rule 86 (var_assign -> var ORASGN expr .)
    RETURN          reduce using rule 86 (var_assign -> var ORASGN expr .)
    FN              reduce using rule 86 (var_assign -> var ORASGN expr .)
    IMPORT          reduce using rule 86 (var_assign -> var ORASGN expr .)
    [               reduce using rule 86 (var_assign -> var ORASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 149

    (87) var_assign -> var ANDASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    {               reduce using rule 87 (var_assign -> var ANDASGN expr .)
    LET             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    END             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    BEGIN           reduce using rule 87 (var_assign -> var ANDASGN expr .)
    NIL             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    FALSE           reduce using rule 87 (var_assign -> var ANDASGN expr .)
    TRUE            reduce using rule 87 (var_assign -> var ANDASGN expr .)
    STRING          reduce using rule 87 (var_assign -> var ANDASGN expr .)
    FLOAT           reduce using rule 87 (var_assign -> var ANDASGN expr .)
    INT             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    (               reduce using rule 87 (var_assign -> var ANDASGN expr .)
    !               reduce using rule 87 (var_assign -> var ANDASGN expr .)
    ~               reduce using rule 87 (var_assign -> var ANDASGN expr .)
    ID              reduce using rule 87 (var_assign -> var ANDASGN expr .)
    TYPEOF          reduce using rule 87 (var_assign -> var ANDASGN expr .)
    LAMBDA          reduce using rule 87 (var_assign -> var ANDASGN expr .)
    DEC             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    INC             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    CLASS           reduce using rule 87 (var_assign -> var ANDASGN expr .)
    STRUCT          reduce using rule 87 (var_assign -> var ANDASGN expr .)
    IF              reduce using rule 87 (var_assign -> var ANDASGN expr .)
    FOR             reduce using rule 87 (var_assign -> var ANDASGN expr .)
    WHILE           reduce using rule 87 (var_assign -> var ANDASGN expr .)
    RETURN          reduce using rule 87 (var_assign -> var ANDASGN expr .)
    FN              reduce using rule 87 (var_assign -> var ANDASGN expr .)
    IMPORT          reduce using rule 87 (var_assign -> var ANDASGN expr .)
    [               reduce using rule 87 (var_assign -> var ANDASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 150

    (88) var_assign -> var MODULOASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    {               reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    LET             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    END             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    BEGIN           reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    NIL             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    FALSE           reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    TRUE            reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    STRING          reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    FLOAT           reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    INT             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    (               reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    !               reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    ~               reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    ID              reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    TYPEOF          reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    LAMBDA          reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    DEC             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    INC             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    CLASS           reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    STRUCT          reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    IF              reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    FOR             reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    WHILE           reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    RETURN          reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    FN              reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    IMPORT          reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    [               reduce using rule 88 (var_assign -> var MODULOASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 151

    (89) var_assign -> var SLASHASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    {               reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    LET             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    END             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    BEGIN           reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    NIL             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    FALSE           reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    TRUE            reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    STRING          reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    FLOAT           reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    INT             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    (               reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    !               reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    ~               reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    ID              reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    TYPEOF          reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    LAMBDA          reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    DEC             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    INC             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    CLASS           reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    STRUCT          reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    IF              reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    FOR             reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    WHILE           reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    RETURN          reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    FN              reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    IMPORT          reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    [               reduce using rule 89 (var_assign -> var SLASHASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 152

    (90) var_assign -> var STARASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 90 (var_assign -> var STARASGN expr .)
    {               reduce using rule 90 (var_assign -> var STARASGN expr .)
    LET             reduce using rule 90 (var_assign -> var STARASGN expr .)
    END             reduce using rule 90 (var_assign -> var STARASGN expr .)
    BEGIN           reduce using rule 90 (var_assign -> var STARASGN expr .)
    NIL             reduce using rule 90 (var_assign -> var STARASGN expr .)
    FALSE           reduce using rule 90 (var_assign -> var STARASGN expr .)
    TRUE            reduce using rule 90 (var_assign -> var STARASGN expr .)
    STRING          reduce using rule 90 (var_assign -> var STARASGN expr .)
    FLOAT           reduce using rule 90 (var_assign -> var STARASGN expr .)
    INT             reduce using rule 90 (var_assign -> var STARASGN expr .)
    (               reduce using rule 90 (var_assign -> var STARASGN expr .)
    !               reduce using rule 90 (var_assign -> var STARASGN expr .)
    ~               reduce using rule 90 (var_assign -> var STARASGN expr .)
    ID              reduce using rule 90 (var_assign -> var STARASGN expr .)
    TYPEOF          reduce using rule 90 (var_assign -> var STARASGN expr .)
    LAMBDA          reduce using rule 90 (var_assign -> var STARASGN expr .)
    DEC             reduce using rule 90 (var_assign -> var STARASGN expr .)
    INC             reduce using rule 90 (var_assign -> var STARASGN expr .)
    CLASS           reduce using rule 90 (var_assign -> var STARASGN expr .)
    STRUCT          reduce using rule 90 (var_assign -> var STARASGN expr .)
    IF              reduce using rule 90 (var_assign -> var STARASGN expr .)
    FOR             reduce using rule 90 (var_assign -> var STARASGN expr .)
    WHILE           reduce using rule 90 (var_assign -> var STARASGN expr .)
    RETURN          reduce using rule 90 (var_assign -> var STARASGN expr .)
    FN              reduce using rule 90 (var_assign -> var STARASGN expr .)
    IMPORT          reduce using rule 90 (var_assign -> var STARASGN expr .)
    [               reduce using rule 90 (var_assign -> var STARASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 153

    (91) var_assign -> var MINUSASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    {               reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    LET             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    END             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    BEGIN           reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    NIL             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    FALSE           reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    TRUE            reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    STRING          reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    FLOAT           reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    INT             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    (               reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    !               reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    ~               reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    ID              reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    TYPEOF          reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    LAMBDA          reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    DEC             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    INC             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    CLASS           reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    STRUCT          reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    IF              reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    FOR             reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    WHILE           reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    RETURN          reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    FN              reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    IMPORT          reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    [               reduce using rule 91 (var_assign -> var MINUSASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 154

    (92) var_assign -> var PLUSASGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    {               reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    LET             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    END             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    BEGIN           reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    NIL             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    FALSE           reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    TRUE            reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    STRING          reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    FLOAT           reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    INT             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    (               reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    !               reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    ~               reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    ID              reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    TYPEOF          reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    LAMBDA          reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    DEC             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    INC             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    CLASS           reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    STRUCT          reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    IF              reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    FOR             reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    WHILE           reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    RETURN          reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    FN              reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    IMPORT          reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    [               reduce using rule 92 (var_assign -> var PLUSASGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 155

    (93) var_assign -> var ASSIGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    SEP             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    {               reduce using rule 93 (var_assign -> var ASSIGN expr .)
    LET             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    END             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    BEGIN           reduce using rule 93 (var_assign -> var ASSIGN expr .)
    NIL             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    FALSE           reduce using rule 93 (var_assign -> var ASSIGN expr .)
    TRUE            reduce using rule 93 (var_assign -> var ASSIGN expr .)
    STRING          reduce using rule 93 (var_assign -> var ASSIGN expr .)
    FLOAT           reduce using rule 93 (var_assign -> var ASSIGN expr .)
    INT             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    (               reduce using rule 93 (var_assign -> var ASSIGN expr .)
    !               reduce using rule 93 (var_assign -> var ASSIGN expr .)
    ~               reduce using rule 93 (var_assign -> var ASSIGN expr .)
    ID              reduce using rule 93 (var_assign -> var ASSIGN expr .)
    TYPEOF          reduce using rule 93 (var_assign -> var ASSIGN expr .)
    LAMBDA          reduce using rule 93 (var_assign -> var ASSIGN expr .)
    DEC             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    INC             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    CLASS           reduce using rule 93 (var_assign -> var ASSIGN expr .)
    STRUCT          reduce using rule 93 (var_assign -> var ASSIGN expr .)
    IF              reduce using rule 93 (var_assign -> var ASSIGN expr .)
    FOR             reduce using rule 93 (var_assign -> var ASSIGN expr .)
    WHILE           reduce using rule 93 (var_assign -> var ASSIGN expr .)
    RETURN          reduce using rule 93 (var_assign -> var ASSIGN expr .)
    FN              reduce using rule 93 (var_assign -> var ASSIGN expr .)
    IMPORT          reduce using rule 93 (var_assign -> var ASSIGN expr .)
    [               reduce using rule 93 (var_assign -> var ASSIGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 156

    (120) getter -> getter . ID .
    .               reduce using rule 120 (getter -> getter . ID .)
    SEP             reduce using rule 120 (getter -> getter . ID .)
    %               reduce using rule 120 (getter -> getter . ID .)
    /               reduce using rule 120 (getter -> getter . ID .)
    *               reduce using rule 120 (getter -> getter . ID .)
    -               reduce using rule 120 (getter -> getter . ID .)
    +               reduce using rule 120 (getter -> getter . ID .)
    |               reduce using rule 120 (getter -> getter . ID .)
    ^               reduce using rule 120 (getter -> getter . ID .)
    &               reduce using rule 120 (getter -> getter . ID .)
    SHR             reduce using rule 120 (getter -> getter . ID .)
    SHL             reduce using rule 120 (getter -> getter . ID .)
    GREATER         reduce using rule 120 (getter -> getter . ID .)
    LESS            reduce using rule 120 (getter -> getter . ID .)
    OR              reduce using rule 120 (getter -> getter . ID .)
    AND             reduce using rule 120 (getter -> getter . ID .)
    GREATEREQ       reduce using rule 120 (getter -> getter . ID .)
    LESSEQ          reduce using rule 120 (getter -> getter . ID .)
    NOTEQ           reduce using rule 120 (getter -> getter . ID .)
    EQEQ            reduce using rule 120 (getter -> getter . ID .)
    PIPE            reduce using rule 120 (getter -> getter . ID .)
    ?               reduce using rule 120 (getter -> getter . ID .)
    ASSIGN          reduce using rule 120 (getter -> getter . ID .)
    ]               reduce using rule 120 (getter -> getter . ID .)
    ,               reduce using rule 120 (getter -> getter . ID .)
    )               reduce using rule 120 (getter -> getter . ID .)
    {               reduce using rule 120 (getter -> getter . ID .)
    LET             reduce using rule 120 (getter -> getter . ID .)
    END             reduce using rule 120 (getter -> getter . ID .)
    BEGIN           reduce using rule 120 (getter -> getter . ID .)
    NIL             reduce using rule 120 (getter -> getter . ID .)
    FALSE           reduce using rule 120 (getter -> getter . ID .)
    TRUE            reduce using rule 120 (getter -> getter . ID .)
    STRING          reduce using rule 120 (getter -> getter . ID .)
    FLOAT           reduce using rule 120 (getter -> getter . ID .)
    INT             reduce using rule 120 (getter -> getter . ID .)
    (               reduce using rule 120 (getter -> getter . ID .)
    !               reduce using rule 120 (getter -> getter . ID .)
    ~               reduce using rule 120 (getter -> getter . ID .)
    ID              reduce using rule 120 (getter -> getter . ID .)
    TYPEOF          reduce using rule 120 (getter -> getter . ID .)
    LAMBDA          reduce using rule 120 (getter -> getter . ID .)
    DEC             reduce using rule 120 (getter -> getter . ID .)
    INC             reduce using rule 120 (getter -> getter . ID .)
    CLASS           reduce using rule 120 (getter -> getter . ID .)
    STRUCT          reduce using rule 120 (getter -> getter . ID .)
    IF              reduce using rule 120 (getter -> getter . ID .)
    FOR             reduce using rule 120 (getter -> getter . ID .)
    WHILE           reduce using rule 120 (getter -> getter . ID .)
    RETURN          reduce using rule 120 (getter -> getter . ID .)
    FN              reduce using rule 120 (getter -> getter . ID .)
    IMPORT          reduce using rule 120 (getter -> getter . ID .)
    [               reduce using rule 120 (getter -> getter . ID .)
    :               reduce using rule 120 (getter -> getter . ID .)
    }               reduce using rule 120 (getter -> getter . ID .)


state 157

    (36) expr -> { member_list } .
    SEP             reduce using rule 36 (expr -> { member_list } .)
    %               reduce using rule 36 (expr -> { member_list } .)
    /               reduce using rule 36 (expr -> { member_list } .)
    *               reduce using rule 36 (expr -> { member_list } .)
    -               reduce using rule 36 (expr -> { member_list } .)
    +               reduce using rule 36 (expr -> { member_list } .)
    |               reduce using rule 36 (expr -> { member_list } .)
    ^               reduce using rule 36 (expr -> { member_list } .)
    &               reduce using rule 36 (expr -> { member_list } .)
    SHR             reduce using rule 36 (expr -> { member_list } .)
    SHL             reduce using rule 36 (expr -> { member_list } .)
    GREATER         reduce using rule 36 (expr -> { member_list } .)
    LESS            reduce using rule 36 (expr -> { member_list } .)
    OR              reduce using rule 36 (expr -> { member_list } .)
    AND             reduce using rule 36 (expr -> { member_list } .)
    GREATEREQ       reduce using rule 36 (expr -> { member_list } .)
    LESSEQ          reduce using rule 36 (expr -> { member_list } .)
    NOTEQ           reduce using rule 36 (expr -> { member_list } .)
    EQEQ            reduce using rule 36 (expr -> { member_list } .)
    PIPE            reduce using rule 36 (expr -> { member_list } .)
    ?               reduce using rule 36 (expr -> { member_list } .)
    ]               reduce using rule 36 (expr -> { member_list } .)
    ,               reduce using rule 36 (expr -> { member_list } .)
    )               reduce using rule 36 (expr -> { member_list } .)
    {               reduce using rule 36 (expr -> { member_list } .)
    LET             reduce using rule 36 (expr -> { member_list } .)
    END             reduce using rule 36 (expr -> { member_list } .)
    BEGIN           reduce using rule 36 (expr -> { member_list } .)
    NIL             reduce using rule 36 (expr -> { member_list } .)
    FALSE           reduce using rule 36 (expr -> { member_list } .)
    TRUE            reduce using rule 36 (expr -> { member_list } .)
    STRING          reduce using rule 36 (expr -> { member_list } .)
    FLOAT           reduce using rule 36 (expr -> { member_list } .)
    INT             reduce using rule 36 (expr -> { member_list } .)
    (               reduce using rule 36 (expr -> { member_list } .)
    !               reduce using rule 36 (expr -> { member_list } .)
    ~               reduce using rule 36 (expr -> { member_list } .)
    ID              reduce using rule 36 (expr -> { member_list } .)
    TYPEOF          reduce using rule 36 (expr -> { member_list } .)
    LAMBDA          reduce using rule 36 (expr -> { member_list } .)
    DEC             reduce using rule 36 (expr -> { member_list } .)
    INC             reduce using rule 36 (expr -> { member_list } .)
    CLASS           reduce using rule 36 (expr -> { member_list } .)
    STRUCT          reduce using rule 36 (expr -> { member_list } .)
    IF              reduce using rule 36 (expr -> { member_list } .)
    FOR             reduce using rule 36 (expr -> { member_list } .)
    WHILE           reduce using rule 36 (expr -> { member_list } .)
    RETURN          reduce using rule 36 (expr -> { member_list } .)
    FN              reduce using rule 36 (expr -> { member_list } .)
    IMPORT          reduce using rule 36 (expr -> { member_list } .)
    [               reduce using rule 36 (expr -> { member_list } .)
    :               reduce using rule 36 (expr -> { member_list } .)
    }               reduce using rule 36 (expr -> { member_list } .)


state 158

    (115) member_list -> member_list , . member
    (118) member -> . STRING : expr
    STRING          shift and go to state 93

    member                         shift and go to state 198

state 159

    (118) member -> STRING : . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 199
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 160

    (98) list_val -> [ exprs ] .
    SEP             reduce using rule 98 (list_val -> [ exprs ] .)
    %               reduce using rule 98 (list_val -> [ exprs ] .)
    /               reduce using rule 98 (list_val -> [ exprs ] .)
    *               reduce using rule 98 (list_val -> [ exprs ] .)
    -               reduce using rule 98 (list_val -> [ exprs ] .)
    +               reduce using rule 98 (list_val -> [ exprs ] .)
    |               reduce using rule 98 (list_val -> [ exprs ] .)
    ^               reduce using rule 98 (list_val -> [ exprs ] .)
    &               reduce using rule 98 (list_val -> [ exprs ] .)
    SHR             reduce using rule 98 (list_val -> [ exprs ] .)
    SHL             reduce using rule 98 (list_val -> [ exprs ] .)
    GREATER         reduce using rule 98 (list_val -> [ exprs ] .)
    LESS            reduce using rule 98 (list_val -> [ exprs ] .)
    OR              reduce using rule 98 (list_val -> [ exprs ] .)
    AND             reduce using rule 98 (list_val -> [ exprs ] .)
    GREATEREQ       reduce using rule 98 (list_val -> [ exprs ] .)
    LESSEQ          reduce using rule 98 (list_val -> [ exprs ] .)
    NOTEQ           reduce using rule 98 (list_val -> [ exprs ] .)
    EQEQ            reduce using rule 98 (list_val -> [ exprs ] .)
    PIPE            reduce using rule 98 (list_val -> [ exprs ] .)
    ?               reduce using rule 98 (list_val -> [ exprs ] .)
    ]               reduce using rule 98 (list_val -> [ exprs ] .)
    ,               reduce using rule 98 (list_val -> [ exprs ] .)
    )               reduce using rule 98 (list_val -> [ exprs ] .)
    {               reduce using rule 98 (list_val -> [ exprs ] .)
    LET             reduce using rule 98 (list_val -> [ exprs ] .)
    END             reduce using rule 98 (list_val -> [ exprs ] .)
    BEGIN           reduce using rule 98 (list_val -> [ exprs ] .)
    NIL             reduce using rule 98 (list_val -> [ exprs ] .)
    FALSE           reduce using rule 98 (list_val -> [ exprs ] .)
    TRUE            reduce using rule 98 (list_val -> [ exprs ] .)
    STRING          reduce using rule 98 (list_val -> [ exprs ] .)
    FLOAT           reduce using rule 98 (list_val -> [ exprs ] .)
    INT             reduce using rule 98 (list_val -> [ exprs ] .)
    (               reduce using rule 98 (list_val -> [ exprs ] .)
    !               reduce using rule 98 (list_val -> [ exprs ] .)
    ~               reduce using rule 98 (list_val -> [ exprs ] .)
    ID              reduce using rule 98 (list_val -> [ exprs ] .)
    TYPEOF          reduce using rule 98 (list_val -> [ exprs ] .)
    LAMBDA          reduce using rule 98 (list_val -> [ exprs ] .)
    DEC             reduce using rule 98 (list_val -> [ exprs ] .)
    INC             reduce using rule 98 (list_val -> [ exprs ] .)
    CLASS           reduce using rule 98 (list_val -> [ exprs ] .)
    STRUCT          reduce using rule 98 (list_val -> [ exprs ] .)
    IF              reduce using rule 98 (list_val -> [ exprs ] .)
    FOR             reduce using rule 98 (list_val -> [ exprs ] .)
    WHILE           reduce using rule 98 (list_val -> [ exprs ] .)
    RETURN          reduce using rule 98 (list_val -> [ exprs ] .)
    FN              reduce using rule 98 (list_val -> [ exprs ] .)
    IMPORT          reduce using rule 98 (list_val -> [ exprs ] .)
    [               reduce using rule 98 (list_val -> [ exprs ] .)
    :               reduce using rule 98 (list_val -> [ exprs ] .)
    }               reduce using rule 98 (list_val -> [ exprs ] .)


state 161

    (99) exprs -> exprs , . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 200
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 162

    (46) expr -> ( expr ) .
    SEP             reduce using rule 46 (expr -> ( expr ) .)
    %               reduce using rule 46 (expr -> ( expr ) .)
    /               reduce using rule 46 (expr -> ( expr ) .)
    *               reduce using rule 46 (expr -> ( expr ) .)
    -               reduce using rule 46 (expr -> ( expr ) .)
    +               reduce using rule 46 (expr -> ( expr ) .)
    |               reduce using rule 46 (expr -> ( expr ) .)
    ^               reduce using rule 46 (expr -> ( expr ) .)
    &               reduce using rule 46 (expr -> ( expr ) .)
    SHR             reduce using rule 46 (expr -> ( expr ) .)
    SHL             reduce using rule 46 (expr -> ( expr ) .)
    GREATER         reduce using rule 46 (expr -> ( expr ) .)
    LESS            reduce using rule 46 (expr -> ( expr ) .)
    OR              reduce using rule 46 (expr -> ( expr ) .)
    AND             reduce using rule 46 (expr -> ( expr ) .)
    GREATEREQ       reduce using rule 46 (expr -> ( expr ) .)
    LESSEQ          reduce using rule 46 (expr -> ( expr ) .)
    NOTEQ           reduce using rule 46 (expr -> ( expr ) .)
    EQEQ            reduce using rule 46 (expr -> ( expr ) .)
    PIPE            reduce using rule 46 (expr -> ( expr ) .)
    ?               reduce using rule 46 (expr -> ( expr ) .)
    ]               reduce using rule 46 (expr -> ( expr ) .)
    ,               reduce using rule 46 (expr -> ( expr ) .)
    )               reduce using rule 46 (expr -> ( expr ) .)
    {               reduce using rule 46 (expr -> ( expr ) .)
    LET             reduce using rule 46 (expr -> ( expr ) .)
    END             reduce using rule 46 (expr -> ( expr ) .)
    BEGIN           reduce using rule 46 (expr -> ( expr ) .)
    NIL             reduce using rule 46 (expr -> ( expr ) .)
    FALSE           reduce using rule 46 (expr -> ( expr ) .)
    TRUE            reduce using rule 46 (expr -> ( expr ) .)
    STRING          reduce using rule 46 (expr -> ( expr ) .)
    FLOAT           reduce using rule 46 (expr -> ( expr ) .)
    INT             reduce using rule 46 (expr -> ( expr ) .)
    (               reduce using rule 46 (expr -> ( expr ) .)
    !               reduce using rule 46 (expr -> ( expr ) .)
    ~               reduce using rule 46 (expr -> ( expr ) .)
    ID              reduce using rule 46 (expr -> ( expr ) .)
    TYPEOF          reduce using rule 46 (expr -> ( expr ) .)
    LAMBDA          reduce using rule 46 (expr -> ( expr ) .)
    DEC             reduce using rule 46 (expr -> ( expr ) .)
    INC             reduce using rule 46 (expr -> ( expr ) .)
    CLASS           reduce using rule 46 (expr -> ( expr ) .)
    STRUCT          reduce using rule 46 (expr -> ( expr ) .)
    IF              reduce using rule 46 (expr -> ( expr ) .)
    FOR             reduce using rule 46 (expr -> ( expr ) .)
    WHILE           reduce using rule 46 (expr -> ( expr ) .)
    RETURN          reduce using rule 46 (expr -> ( expr ) .)
    FN              reduce using rule 46 (expr -> ( expr ) .)
    IMPORT          reduce using rule 46 (expr -> ( expr ) .)
    [               reduce using rule 46 (expr -> ( expr ) .)
    :               reduce using rule 46 (expr -> ( expr ) .)
    }               reduce using rule 46 (expr -> ( expr ) .)


state 163

    (70) expr -> ID DOUBLECOLON ID . ( args )
    (               shift and go to state 201


state 164

    (71) expr -> ID ( args . )
    (113) args -> args . , arg
    )               shift and go to state 202
    ,               shift and go to state 203


state 165

    (111) args -> empty .
    )               reduce using rule 111 (args -> empty .)
    ,               reduce using rule 111 (args -> empty .)


state 166

    (112) args -> arg .
    )               reduce using rule 112 (args -> arg .)
    ,               reduce using rule 112 (args -> arg .)


state 167

    (114) arg -> expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    )               reduce using rule 114 (arg -> expr .)
    ,               reduce using rule 114 (arg -> expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 168

    (75) expr -> ID LEFTARROW { . struct_init_exprs }
    (76) struct_init_exprs -> . struct_init_exprs , expr
    (77) struct_init_exprs -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    struct_init_exprs              shift and go to state 204
    expr                           shift and go to state 205
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 169

    (74) expr -> LAMBDA ( params . ) ARROW expr
    (109) params -> params . , param
    )               shift and go to state 206
    ,               shift and go to state 207


state 170

    (107) params -> empty .
    )               reduce using rule 107 (params -> empty .)
    ,               reduce using rule 107 (params -> empty .)


state 171

    (108) params -> param .
    )               reduce using rule 108 (params -> param .)
    ,               reduce using rule 108 (params -> param .)


state 172

    (110) param -> ID . : var_type
    :               shift and go to state 208


state 173

    (19) class_definition -> CLASS ID { . function_definitions }
    (20) function_definitions -> . function_definitions function_definition
    (21) function_definitions -> . function_definition
    (22) function_definitions -> . empty
    (34) function_definition -> . FN ID ( params ) block
    (104) empty -> .
  ! shift/reduce conflict for FN resolved as shift
    FN              shift and go to state 48
    }               reduce using rule 104 (empty -> .)

    function_definitions           shift and go to state 209
    function_definition            shift and go to state 210
    empty                          shift and go to state 211

state 174

    (23) struct_definition -> STRUCT ID { . struct_fields } SEP
    (24) struct_fields -> . struct_fields struct_field
    (25) struct_fields -> . struct_field
    (26) struct_field -> . LET ID : var_type SEP
    LET             shift and go to state 214

    struct_fields                  shift and go to state 212
    struct_field                   shift and go to state 213

state 175

    (94) if_statement -> IF expr block .
    (95) if_statement -> IF expr block . ELSE block
  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 94 (if_statement -> IF expr block .)
    END             reduce using rule 94 (if_statement -> IF expr block .)
    BEGIN           reduce using rule 94 (if_statement -> IF expr block .)
    {               reduce using rule 94 (if_statement -> IF expr block .)
    NIL             reduce using rule 94 (if_statement -> IF expr block .)
    FALSE           reduce using rule 94 (if_statement -> IF expr block .)
    TRUE            reduce using rule 94 (if_statement -> IF expr block .)
    STRING          reduce using rule 94 (if_statement -> IF expr block .)
    FLOAT           reduce using rule 94 (if_statement -> IF expr block .)
    INT             reduce using rule 94 (if_statement -> IF expr block .)
    (               reduce using rule 94 (if_statement -> IF expr block .)
    !               reduce using rule 94 (if_statement -> IF expr block .)
    +               reduce using rule 94 (if_statement -> IF expr block .)
    -               reduce using rule 94 (if_statement -> IF expr block .)
    ~               reduce using rule 94 (if_statement -> IF expr block .)
    ID              reduce using rule 94 (if_statement -> IF expr block .)
    TYPEOF          reduce using rule 94 (if_statement -> IF expr block .)
    LAMBDA          reduce using rule 94 (if_statement -> IF expr block .)
    DEC             reduce using rule 94 (if_statement -> IF expr block .)
    INC             reduce using rule 94 (if_statement -> IF expr block .)
    CLASS           reduce using rule 94 (if_statement -> IF expr block .)
    STRUCT          reduce using rule 94 (if_statement -> IF expr block .)
    IF              reduce using rule 94 (if_statement -> IF expr block .)
    FOR             reduce using rule 94 (if_statement -> IF expr block .)
    WHILE           reduce using rule 94 (if_statement -> IF expr block .)
    RETURN          reduce using rule 94 (if_statement -> IF expr block .)
    FN              reduce using rule 94 (if_statement -> IF expr block .)
    IMPORT          reduce using rule 94 (if_statement -> IF expr block .)
    [               reduce using rule 94 (if_statement -> IF expr block .)
    $end            reduce using rule 94 (if_statement -> IF expr block .)
    }               reduce using rule 94 (if_statement -> IF expr block .)
    ELSE            shift and go to state 215


state 176

    (50) expr -> expr - . expr
    (54) expr -> - . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 216
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 177

    (51) expr -> expr + . expr
    (53) expr -> + . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 217
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 178

    (105) block -> statement .
    ELSE            reduce using rule 105 (block -> statement .)
    LET             reduce using rule 105 (block -> statement .)
    END             reduce using rule 105 (block -> statement .)
    BEGIN           reduce using rule 105 (block -> statement .)
    {               reduce using rule 105 (block -> statement .)
    NIL             reduce using rule 105 (block -> statement .)
    FALSE           reduce using rule 105 (block -> statement .)
    TRUE            reduce using rule 105 (block -> statement .)
    STRING          reduce using rule 105 (block -> statement .)
    FLOAT           reduce using rule 105 (block -> statement .)
    INT             reduce using rule 105 (block -> statement .)
    (               reduce using rule 105 (block -> statement .)
    !               reduce using rule 105 (block -> statement .)
    +               reduce using rule 105 (block -> statement .)
    -               reduce using rule 105 (block -> statement .)
    ~               reduce using rule 105 (block -> statement .)
    ID              reduce using rule 105 (block -> statement .)
    TYPEOF          reduce using rule 105 (block -> statement .)
    LAMBDA          reduce using rule 105 (block -> statement .)
    DEC             reduce using rule 105 (block -> statement .)
    INC             reduce using rule 105 (block -> statement .)
    CLASS           reduce using rule 105 (block -> statement .)
    STRUCT          reduce using rule 105 (block -> statement .)
    IF              reduce using rule 105 (block -> statement .)
    FOR             reduce using rule 105 (block -> statement .)
    WHILE           reduce using rule 105 (block -> statement .)
    RETURN          reduce using rule 105 (block -> statement .)
    FN              reduce using rule 105 (block -> statement .)
    IMPORT          reduce using rule 105 (block -> statement .)
    [               reduce using rule 105 (block -> statement .)
    $end            reduce using rule 105 (block -> statement .)
    }               reduce using rule 105 (block -> statement .)


state 179

    (106) block -> { . program }
    (36) expr -> { . member_list }
    (1) program -> . empty
    (2) program -> . statements
    (115) member_list -> . member_list , member
    (116) member_list -> . member
    (117) member_list -> . empty
    (104) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (118) member -> . STRING : expr
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    }               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    STRING          shift and go to state 220
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    program                        shift and go to state 218
    member_list                    shift and go to state 90
    empty                          shift and go to state 219
    statements                     shift and go to state 3
    member                         shift and go to state 91
    statement                      shift and go to state 4
    expr                           shift and go to state 7
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 180

    (97) for_statement -> FOR var_assign SEP . expr SEP var_assign block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 221
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 181

    (96) while_statement -> WHILE expr block .
    LET             reduce using rule 96 (while_statement -> WHILE expr block .)
    END             reduce using rule 96 (while_statement -> WHILE expr block .)
    BEGIN           reduce using rule 96 (while_statement -> WHILE expr block .)
    {               reduce using rule 96 (while_statement -> WHILE expr block .)
    NIL             reduce using rule 96 (while_statement -> WHILE expr block .)
    FALSE           reduce using rule 96 (while_statement -> WHILE expr block .)
    TRUE            reduce using rule 96 (while_statement -> WHILE expr block .)
    STRING          reduce using rule 96 (while_statement -> WHILE expr block .)
    FLOAT           reduce using rule 96 (while_statement -> WHILE expr block .)
    INT             reduce using rule 96 (while_statement -> WHILE expr block .)
    (               reduce using rule 96 (while_statement -> WHILE expr block .)
    !               reduce using rule 96 (while_statement -> WHILE expr block .)
    +               reduce using rule 96 (while_statement -> WHILE expr block .)
    -               reduce using rule 96 (while_statement -> WHILE expr block .)
    ~               reduce using rule 96 (while_statement -> WHILE expr block .)
    ID              reduce using rule 96 (while_statement -> WHILE expr block .)
    TYPEOF          reduce using rule 96 (while_statement -> WHILE expr block .)
    LAMBDA          reduce using rule 96 (while_statement -> WHILE expr block .)
    DEC             reduce using rule 96 (while_statement -> WHILE expr block .)
    INC             reduce using rule 96 (while_statement -> WHILE expr block .)
    CLASS           reduce using rule 96 (while_statement -> WHILE expr block .)
    STRUCT          reduce using rule 96 (while_statement -> WHILE expr block .)
    IF              reduce using rule 96 (while_statement -> WHILE expr block .)
    FOR             reduce using rule 96 (while_statement -> WHILE expr block .)
    WHILE           reduce using rule 96 (while_statement -> WHILE expr block .)
    RETURN          reduce using rule 96 (while_statement -> WHILE expr block .)
    FN              reduce using rule 96 (while_statement -> WHILE expr block .)
    IMPORT          reduce using rule 96 (while_statement -> WHILE expr block .)
    [               reduce using rule 96 (while_statement -> WHILE expr block .)
    $end            reduce using rule 96 (while_statement -> WHILE expr block .)
    }               reduce using rule 96 (while_statement -> WHILE expr block .)
    ELSE            reduce using rule 96 (while_statement -> WHILE expr block .)


state 182

    (80) return_statement -> RETURN expr SEP .
    LET             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    END             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    BEGIN           reduce using rule 80 (return_statement -> RETURN expr SEP .)
    {               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    NIL             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    FALSE           reduce using rule 80 (return_statement -> RETURN expr SEP .)
    TRUE            reduce using rule 80 (return_statement -> RETURN expr SEP .)
    STRING          reduce using rule 80 (return_statement -> RETURN expr SEP .)
    FLOAT           reduce using rule 80 (return_statement -> RETURN expr SEP .)
    INT             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    (               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    !               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    +               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    -               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    ~               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    ID              reduce using rule 80 (return_statement -> RETURN expr SEP .)
    TYPEOF          reduce using rule 80 (return_statement -> RETURN expr SEP .)
    LAMBDA          reduce using rule 80 (return_statement -> RETURN expr SEP .)
    DEC             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    INC             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    CLASS           reduce using rule 80 (return_statement -> RETURN expr SEP .)
    STRUCT          reduce using rule 80 (return_statement -> RETURN expr SEP .)
    IF              reduce using rule 80 (return_statement -> RETURN expr SEP .)
    FOR             reduce using rule 80 (return_statement -> RETURN expr SEP .)
    WHILE           reduce using rule 80 (return_statement -> RETURN expr SEP .)
    RETURN          reduce using rule 80 (return_statement -> RETURN expr SEP .)
    FN              reduce using rule 80 (return_statement -> RETURN expr SEP .)
    IMPORT          reduce using rule 80 (return_statement -> RETURN expr SEP .)
    [               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    $end            reduce using rule 80 (return_statement -> RETURN expr SEP .)
    }               reduce using rule 80 (return_statement -> RETURN expr SEP .)
    ELSE            reduce using rule 80 (return_statement -> RETURN expr SEP .)


state 183

    (34) function_definition -> FN ID ( . params ) block
    (107) params -> . empty
    (108) params -> . param
    (109) params -> . params , param
    (104) empty -> .
    (110) param -> . ID : var_type
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    ID              shift and go to state 172

    params                         shift and go to state 222
    empty                          shift and go to state 170
    param                          shift and go to state 171

state 184

    (33) import_statement -> IMPORT STRING SEP .
    LET             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    END             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    BEGIN           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    {               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    NIL             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FALSE           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    TRUE            reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    STRING          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FLOAT           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    INT             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    (               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    !               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    +               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    -               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    ~               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    ID              reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    TYPEOF          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    LAMBDA          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    DEC             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    INC             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    CLASS           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    STRUCT          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    IF              reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FOR             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    WHILE           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    RETURN          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FN              reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    IMPORT          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    [               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    $end            reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    }               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    ELSE            reduce using rule 33 (import_statement -> IMPORT STRING SEP .)


state 185

    (69) expr -> expr PIPE ID ( . args )
    (111) args -> . empty
    (112) args -> . arg
    (113) args -> . args , arg
    (104) empty -> .
    (114) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 167
    args                           shift and go to state 223
    empty                          shift and go to state 165
    arg                            shift and go to state 166
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 186

    (72) expr -> expr ? expr : . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 224
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 187

    (9) statement -> LET var : var_type . SEP
    SEP             shift and go to state 225


state 188

    (27) var_type -> DICT_TYPE .
    SEP             reduce using rule 27 (var_type -> DICT_TYPE .)
    )               reduce using rule 27 (var_type -> DICT_TYPE .)
    ,               reduce using rule 27 (var_type -> DICT_TYPE .)


state 189

    (28) var_type -> LIST_TYPE .
    SEP             reduce using rule 28 (var_type -> LIST_TYPE .)
    )               reduce using rule 28 (var_type -> LIST_TYPE .)
    ,               reduce using rule 28 (var_type -> LIST_TYPE .)


state 190

    (29) var_type -> BOOL_TYPE .
    SEP             reduce using rule 29 (var_type -> BOOL_TYPE .)
    )               reduce using rule 29 (var_type -> BOOL_TYPE .)
    ,               reduce using rule 29 (var_type -> BOOL_TYPE .)


state 191

    (30) var_type -> STRING_TYPE .
    SEP             reduce using rule 30 (var_type -> STRING_TYPE .)
    )               reduce using rule 30 (var_type -> STRING_TYPE .)
    ,               reduce using rule 30 (var_type -> STRING_TYPE .)


state 192

    (31) var_type -> FLOAT_TYPE .
    SEP             reduce using rule 31 (var_type -> FLOAT_TYPE .)
    )               reduce using rule 31 (var_type -> FLOAT_TYPE .)
    ,               reduce using rule 31 (var_type -> FLOAT_TYPE .)


state 193

    (32) var_type -> INT_TYPE .
    SEP             reduce using rule 32 (var_type -> INT_TYPE .)
    )               reduce using rule 32 (var_type -> INT_TYPE .)
    ,               reduce using rule 32 (var_type -> INT_TYPE .)


state 194

    (79) var_define -> LET var ASSIGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 79 (var_define -> LET var ASSIGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 195

    (102) var -> var [ expr . ]
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    ]               shift and go to state 226
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 196

    (78) var_define -> LET getter ASSIGN expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             reduce using rule 78 (var_define -> LET getter ASSIGN expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 197

    (39) expr -> var [ expr ] .
    (102) var -> var [ expr ] .
  ! reduce/reduce conflict for [ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SEP resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for % resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for / resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for * resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for - resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for + resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for | resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ^ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for & resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SHR resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SHL resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for GREATER resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LESS resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for OR resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for AND resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for EQEQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for PIPE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ? resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ] resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for , resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ) resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for { resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LET resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for END resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for BEGIN resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for NIL resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FALSE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TRUE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for STRING resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FLOAT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for INT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ( resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ! resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ~ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ID resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TYPEOF resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LAMBDA resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for DEC resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for INC resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for CLASS resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for STRUCT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for IF resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FOR resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for WHILE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for RETURN resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FN resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for IMPORT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for : resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for } resolved using rule 39 (expr -> var [ expr ] .)
    SEP             reduce using rule 39 (expr -> var [ expr ] .)
    %               reduce using rule 39 (expr -> var [ expr ] .)
    /               reduce using rule 39 (expr -> var [ expr ] .)
    *               reduce using rule 39 (expr -> var [ expr ] .)
    -               reduce using rule 39 (expr -> var [ expr ] .)
    +               reduce using rule 39 (expr -> var [ expr ] .)
    |               reduce using rule 39 (expr -> var [ expr ] .)
    ^               reduce using rule 39 (expr -> var [ expr ] .)
    &               reduce using rule 39 (expr -> var [ expr ] .)
    SHR             reduce using rule 39 (expr -> var [ expr ] .)
    SHL             reduce using rule 39 (expr -> var [ expr ] .)
    GREATER         reduce using rule 39 (expr -> var [ expr ] .)
    LESS            reduce using rule 39 (expr -> var [ expr ] .)
    OR              reduce using rule 39 (expr -> var [ expr ] .)
    AND             reduce using rule 39 (expr -> var [ expr ] .)
    GREATEREQ       reduce using rule 39 (expr -> var [ expr ] .)
    LESSEQ          reduce using rule 39 (expr -> var [ expr ] .)
    NOTEQ           reduce using rule 39 (expr -> var [ expr ] .)
    EQEQ            reduce using rule 39 (expr -> var [ expr ] .)
    PIPE            reduce using rule 39 (expr -> var [ expr ] .)
    ?               reduce using rule 39 (expr -> var [ expr ] .)
    ]               reduce using rule 39 (expr -> var [ expr ] .)
    ,               reduce using rule 39 (expr -> var [ expr ] .)
    )               reduce using rule 39 (expr -> var [ expr ] .)
    {               reduce using rule 39 (expr -> var [ expr ] .)
    LET             reduce using rule 39 (expr -> var [ expr ] .)
    END             reduce using rule 39 (expr -> var [ expr ] .)
    BEGIN           reduce using rule 39 (expr -> var [ expr ] .)
    NIL             reduce using rule 39 (expr -> var [ expr ] .)
    FALSE           reduce using rule 39 (expr -> var [ expr ] .)
    TRUE            reduce using rule 39 (expr -> var [ expr ] .)
    STRING          reduce using rule 39 (expr -> var [ expr ] .)
    FLOAT           reduce using rule 39 (expr -> var [ expr ] .)
    INT             reduce using rule 39 (expr -> var [ expr ] .)
    (               reduce using rule 39 (expr -> var [ expr ] .)
    !               reduce using rule 39 (expr -> var [ expr ] .)
    ~               reduce using rule 39 (expr -> var [ expr ] .)
    ID              reduce using rule 39 (expr -> var [ expr ] .)
    TYPEOF          reduce using rule 39 (expr -> var [ expr ] .)
    LAMBDA          reduce using rule 39 (expr -> var [ expr ] .)
    DEC             reduce using rule 39 (expr -> var [ expr ] .)
    INC             reduce using rule 39 (expr -> var [ expr ] .)
    CLASS           reduce using rule 39 (expr -> var [ expr ] .)
    STRUCT          reduce using rule 39 (expr -> var [ expr ] .)
    IF              reduce using rule 39 (expr -> var [ expr ] .)
    FOR             reduce using rule 39 (expr -> var [ expr ] .)
    WHILE           reduce using rule 39 (expr -> var [ expr ] .)
    RETURN          reduce using rule 39 (expr -> var [ expr ] .)
    FN              reduce using rule 39 (expr -> var [ expr ] .)
    IMPORT          reduce using rule 39 (expr -> var [ expr ] .)
    [               reduce using rule 39 (expr -> var [ expr ] .)
    :               reduce using rule 39 (expr -> var [ expr ] .)
    }               reduce using rule 39 (expr -> var [ expr ] .)
    SHRASGN         reduce using rule 102 (var -> var [ expr ] .)
    SHLASGN         reduce using rule 102 (var -> var [ expr ] .)
    XORASGN         reduce using rule 102 (var -> var [ expr ] .)
    ORASGN          reduce using rule 102 (var -> var [ expr ] .)
    ANDASGN         reduce using rule 102 (var -> var [ expr ] .)
    MODULOASGN      reduce using rule 102 (var -> var [ expr ] .)
    SLASHASGN       reduce using rule 102 (var -> var [ expr ] .)
    STARASGN        reduce using rule 102 (var -> var [ expr ] .)
    MINUSASGN       reduce using rule 102 (var -> var [ expr ] .)
    PLUSASGN        reduce using rule 102 (var -> var [ expr ] .)
    ASSIGN          reduce using rule 102 (var -> var [ expr ] .)


state 198

    (115) member_list -> member_list , member .
    }               reduce using rule 115 (member_list -> member_list , member .)
    ,               reduce using rule 115 (member_list -> member_list , member .)


state 199

    (118) member -> STRING : expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    }               reduce using rule 118 (member -> STRING : expr .)
    ,               reduce using rule 118 (member -> STRING : expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 200

    (99) exprs -> exprs , expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    ]               reduce using rule 99 (exprs -> exprs , expr .)
    ,               reduce using rule 99 (exprs -> exprs , expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 201

    (70) expr -> ID DOUBLECOLON ID ( . args )
    (111) args -> . empty
    (112) args -> . arg
    (113) args -> . args , arg
    (104) empty -> .
    (114) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    )               reduce using rule 104 (empty -> .)
    ,               reduce using rule 104 (empty -> .)
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    args                           shift and go to state 227
    empty                          shift and go to state 165
    arg                            shift and go to state 166
    expr                           shift and go to state 167
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 202

    (71) expr -> ID ( args ) .
    SEP             reduce using rule 71 (expr -> ID ( args ) .)
    %               reduce using rule 71 (expr -> ID ( args ) .)
    /               reduce using rule 71 (expr -> ID ( args ) .)
    *               reduce using rule 71 (expr -> ID ( args ) .)
    -               reduce using rule 71 (expr -> ID ( args ) .)
    +               reduce using rule 71 (expr -> ID ( args ) .)
    |               reduce using rule 71 (expr -> ID ( args ) .)
    ^               reduce using rule 71 (expr -> ID ( args ) .)
    &               reduce using rule 71 (expr -> ID ( args ) .)
    SHR             reduce using rule 71 (expr -> ID ( args ) .)
    SHL             reduce using rule 71 (expr -> ID ( args ) .)
    GREATER         reduce using rule 71 (expr -> ID ( args ) .)
    LESS            reduce using rule 71 (expr -> ID ( args ) .)
    OR              reduce using rule 71 (expr -> ID ( args ) .)
    AND             reduce using rule 71 (expr -> ID ( args ) .)
    GREATEREQ       reduce using rule 71 (expr -> ID ( args ) .)
    LESSEQ          reduce using rule 71 (expr -> ID ( args ) .)
    NOTEQ           reduce using rule 71 (expr -> ID ( args ) .)
    EQEQ            reduce using rule 71 (expr -> ID ( args ) .)
    PIPE            reduce using rule 71 (expr -> ID ( args ) .)
    ?               reduce using rule 71 (expr -> ID ( args ) .)
    ]               reduce using rule 71 (expr -> ID ( args ) .)
    ,               reduce using rule 71 (expr -> ID ( args ) .)
    )               reduce using rule 71 (expr -> ID ( args ) .)
    {               reduce using rule 71 (expr -> ID ( args ) .)
    LET             reduce using rule 71 (expr -> ID ( args ) .)
    END             reduce using rule 71 (expr -> ID ( args ) .)
    BEGIN           reduce using rule 71 (expr -> ID ( args ) .)
    NIL             reduce using rule 71 (expr -> ID ( args ) .)
    FALSE           reduce using rule 71 (expr -> ID ( args ) .)
    TRUE            reduce using rule 71 (expr -> ID ( args ) .)
    STRING          reduce using rule 71 (expr -> ID ( args ) .)
    FLOAT           reduce using rule 71 (expr -> ID ( args ) .)
    INT             reduce using rule 71 (expr -> ID ( args ) .)
    (               reduce using rule 71 (expr -> ID ( args ) .)
    !               reduce using rule 71 (expr -> ID ( args ) .)
    ~               reduce using rule 71 (expr -> ID ( args ) .)
    ID              reduce using rule 71 (expr -> ID ( args ) .)
    TYPEOF          reduce using rule 71 (expr -> ID ( args ) .)
    LAMBDA          reduce using rule 71 (expr -> ID ( args ) .)
    DEC             reduce using rule 71 (expr -> ID ( args ) .)
    INC             reduce using rule 71 (expr -> ID ( args ) .)
    CLASS           reduce using rule 71 (expr -> ID ( args ) .)
    STRUCT          reduce using rule 71 (expr -> ID ( args ) .)
    IF              reduce using rule 71 (expr -> ID ( args ) .)
    FOR             reduce using rule 71 (expr -> ID ( args ) .)
    WHILE           reduce using rule 71 (expr -> ID ( args ) .)
    RETURN          reduce using rule 71 (expr -> ID ( args ) .)
    FN              reduce using rule 71 (expr -> ID ( args ) .)
    IMPORT          reduce using rule 71 (expr -> ID ( args ) .)
    [               reduce using rule 71 (expr -> ID ( args ) .)
    :               reduce using rule 71 (expr -> ID ( args ) .)
    }               reduce using rule 71 (expr -> ID ( args ) .)


state 203

    (113) args -> args , . arg
    (114) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    arg                            shift and go to state 228
    expr                           shift and go to state 167
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 204

    (75) expr -> ID LEFTARROW { struct_init_exprs . }
    (76) struct_init_exprs -> struct_init_exprs . , expr
    }               shift and go to state 229
    ,               shift and go to state 230


state 205

    (77) struct_init_exprs -> expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    }               reduce using rule 77 (struct_init_exprs -> expr .)
    ,               reduce using rule 77 (struct_init_exprs -> expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 206

    (74) expr -> LAMBDA ( params ) . ARROW expr
    ARROW           shift and go to state 231


state 207

    (109) params -> params , . param
    (110) param -> . ID : var_type
    ID              shift and go to state 172

    param                          shift and go to state 232

state 208

    (110) param -> ID : . var_type
    (27) var_type -> . DICT_TYPE
    (28) var_type -> . LIST_TYPE
    (29) var_type -> . BOOL_TYPE
    (30) var_type -> . STRING_TYPE
    (31) var_type -> . FLOAT_TYPE
    (32) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 188
    LIST_TYPE       shift and go to state 189
    BOOL_TYPE       shift and go to state 190
    STRING_TYPE     shift and go to state 191
    FLOAT_TYPE      shift and go to state 192
    INT_TYPE        shift and go to state 193

    var_type                       shift and go to state 233

state 209

    (19) class_definition -> CLASS ID { function_definitions . }
    (20) function_definitions -> function_definitions . function_definition
    (34) function_definition -> . FN ID ( params ) block
    }               shift and go to state 234
    FN              shift and go to state 48

    function_definition            shift and go to state 235

state 210

    (21) function_definitions -> function_definition .
    }               reduce using rule 21 (function_definitions -> function_definition .)
    FN              reduce using rule 21 (function_definitions -> function_definition .)


state 211

    (22) function_definitions -> empty .
    }               reduce using rule 22 (function_definitions -> empty .)
    FN              reduce using rule 22 (function_definitions -> empty .)


state 212

    (23) struct_definition -> STRUCT ID { struct_fields . } SEP
    (24) struct_fields -> struct_fields . struct_field
    (26) struct_field -> . LET ID : var_type SEP
    }               shift and go to state 236
    LET             shift and go to state 214

    struct_field                   shift and go to state 237

state 213

    (25) struct_fields -> struct_field .
    }               reduce using rule 25 (struct_fields -> struct_field .)
    LET             reduce using rule 25 (struct_fields -> struct_field .)


state 214

    (26) struct_field -> LET . ID : var_type SEP
    ID              shift and go to state 238


state 215

    (95) if_statement -> IF expr block ELSE . block
    (105) block -> . statement
    (106) block -> . { program }
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 179
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    expr                           shift and go to state 7
    block                          shift and go to state 239
    statement                      shift and go to state 178
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 216

    (50) expr -> expr - expr .
    (54) expr -> - expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for % resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for / resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for * resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for - resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for + resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for | resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for ^ resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for & resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for SHR resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for SHL resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for LESS resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for OR resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for AND resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for PIPE resolved using rule 54 (expr -> - expr .)
  ! reduce/reduce conflict for ? resolved using rule 54 (expr -> - expr .)
    {               reduce using rule 50 (expr -> expr - expr .)
    LET             reduce using rule 50 (expr -> expr - expr .)
    END             reduce using rule 50 (expr -> expr - expr .)
    BEGIN           reduce using rule 50 (expr -> expr - expr .)
    NIL             reduce using rule 50 (expr -> expr - expr .)
    FALSE           reduce using rule 50 (expr -> expr - expr .)
    TRUE            reduce using rule 50 (expr -> expr - expr .)
    STRING          reduce using rule 50 (expr -> expr - expr .)
    FLOAT           reduce using rule 50 (expr -> expr - expr .)
    INT             reduce using rule 50 (expr -> expr - expr .)
    (               reduce using rule 50 (expr -> expr - expr .)
    !               reduce using rule 50 (expr -> expr - expr .)
    ~               reduce using rule 50 (expr -> expr - expr .)
    ID              reduce using rule 50 (expr -> expr - expr .)
    TYPEOF          reduce using rule 50 (expr -> expr - expr .)
    LAMBDA          reduce using rule 50 (expr -> expr - expr .)
    DEC             reduce using rule 50 (expr -> expr - expr .)
    INC             reduce using rule 50 (expr -> expr - expr .)
    CLASS           reduce using rule 50 (expr -> expr - expr .)
    STRUCT          reduce using rule 50 (expr -> expr - expr .)
    IF              reduce using rule 50 (expr -> expr - expr .)
    FOR             reduce using rule 50 (expr -> expr - expr .)
    WHILE           reduce using rule 50 (expr -> expr - expr .)
    RETURN          reduce using rule 50 (expr -> expr - expr .)
    FN              reduce using rule 50 (expr -> expr - expr .)
    IMPORT          reduce using rule 50 (expr -> expr - expr .)
    [               reduce using rule 50 (expr -> expr - expr .)
    SEP             reduce using rule 54 (expr -> - expr .)
    %               reduce using rule 54 (expr -> - expr .)
    /               reduce using rule 54 (expr -> - expr .)
    *               reduce using rule 54 (expr -> - expr .)
    -               reduce using rule 54 (expr -> - expr .)
    +               reduce using rule 54 (expr -> - expr .)
    |               reduce using rule 54 (expr -> - expr .)
    ^               reduce using rule 54 (expr -> - expr .)
    &               reduce using rule 54 (expr -> - expr .)
    SHR             reduce using rule 54 (expr -> - expr .)
    SHL             reduce using rule 54 (expr -> - expr .)
    GREATER         reduce using rule 54 (expr -> - expr .)
    LESS            reduce using rule 54 (expr -> - expr .)
    OR              reduce using rule 54 (expr -> - expr .)
    AND             reduce using rule 54 (expr -> - expr .)
    GREATEREQ       reduce using rule 54 (expr -> - expr .)
    LESSEQ          reduce using rule 54 (expr -> - expr .)
    NOTEQ           reduce using rule 54 (expr -> - expr .)
    EQEQ            reduce using rule 54 (expr -> - expr .)
    PIPE            reduce using rule 54 (expr -> - expr .)
    ?               reduce using rule 54 (expr -> - expr .)


state 217

    (51) expr -> expr + expr .
    (53) expr -> + expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for % resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for / resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for * resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for - resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for + resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for | resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for ^ resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for & resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for SHR resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for SHL resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for LESS resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for OR resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for AND resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for PIPE resolved using rule 53 (expr -> + expr .)
  ! reduce/reduce conflict for ? resolved using rule 53 (expr -> + expr .)
    {               reduce using rule 51 (expr -> expr + expr .)
    LET             reduce using rule 51 (expr -> expr + expr .)
    END             reduce using rule 51 (expr -> expr + expr .)
    BEGIN           reduce using rule 51 (expr -> expr + expr .)
    NIL             reduce using rule 51 (expr -> expr + expr .)
    FALSE           reduce using rule 51 (expr -> expr + expr .)
    TRUE            reduce using rule 51 (expr -> expr + expr .)
    STRING          reduce using rule 51 (expr -> expr + expr .)
    FLOAT           reduce using rule 51 (expr -> expr + expr .)
    INT             reduce using rule 51 (expr -> expr + expr .)
    (               reduce using rule 51 (expr -> expr + expr .)
    !               reduce using rule 51 (expr -> expr + expr .)
    ~               reduce using rule 51 (expr -> expr + expr .)
    ID              reduce using rule 51 (expr -> expr + expr .)
    TYPEOF          reduce using rule 51 (expr -> expr + expr .)
    LAMBDA          reduce using rule 51 (expr -> expr + expr .)
    DEC             reduce using rule 51 (expr -> expr + expr .)
    INC             reduce using rule 51 (expr -> expr + expr .)
    CLASS           reduce using rule 51 (expr -> expr + expr .)
    STRUCT          reduce using rule 51 (expr -> expr + expr .)
    IF              reduce using rule 51 (expr -> expr + expr .)
    FOR             reduce using rule 51 (expr -> expr + expr .)
    WHILE           reduce using rule 51 (expr -> expr + expr .)
    RETURN          reduce using rule 51 (expr -> expr + expr .)
    FN              reduce using rule 51 (expr -> expr + expr .)
    IMPORT          reduce using rule 51 (expr -> expr + expr .)
    [               reduce using rule 51 (expr -> expr + expr .)
    SEP             reduce using rule 53 (expr -> + expr .)
    %               reduce using rule 53 (expr -> + expr .)
    /               reduce using rule 53 (expr -> + expr .)
    *               reduce using rule 53 (expr -> + expr .)
    -               reduce using rule 53 (expr -> + expr .)
    +               reduce using rule 53 (expr -> + expr .)
    |               reduce using rule 53 (expr -> + expr .)
    ^               reduce using rule 53 (expr -> + expr .)
    &               reduce using rule 53 (expr -> + expr .)
    SHR             reduce using rule 53 (expr -> + expr .)
    SHL             reduce using rule 53 (expr -> + expr .)
    GREATER         reduce using rule 53 (expr -> + expr .)
    LESS            reduce using rule 53 (expr -> + expr .)
    OR              reduce using rule 53 (expr -> + expr .)
    AND             reduce using rule 53 (expr -> + expr .)
    GREATEREQ       reduce using rule 53 (expr -> + expr .)
    LESSEQ          reduce using rule 53 (expr -> + expr .)
    NOTEQ           reduce using rule 53 (expr -> + expr .)
    EQEQ            reduce using rule 53 (expr -> + expr .)
    PIPE            reduce using rule 53 (expr -> + expr .)
    ?               reduce using rule 53 (expr -> + expr .)


state 218

    (106) block -> { program . }
    }               shift and go to state 240


state 219

    (1) program -> empty .
    (117) member_list -> empty .
  ! reduce/reduce conflict for } resolved using rule 1 (program -> empty .)
    }               reduce using rule 1 (program -> empty .)
    ,               reduce using rule 117 (member_list -> empty .)


state 220

    (118) member -> STRING . : expr
    (43) expr -> STRING .
    :               shift and go to state 159
    SEP             reduce using rule 43 (expr -> STRING .)
    %               reduce using rule 43 (expr -> STRING .)
    /               reduce using rule 43 (expr -> STRING .)
    *               reduce using rule 43 (expr -> STRING .)
    -               reduce using rule 43 (expr -> STRING .)
    +               reduce using rule 43 (expr -> STRING .)
    |               reduce using rule 43 (expr -> STRING .)
    ^               reduce using rule 43 (expr -> STRING .)
    &               reduce using rule 43 (expr -> STRING .)
    SHR             reduce using rule 43 (expr -> STRING .)
    SHL             reduce using rule 43 (expr -> STRING .)
    GREATER         reduce using rule 43 (expr -> STRING .)
    LESS            reduce using rule 43 (expr -> STRING .)
    OR              reduce using rule 43 (expr -> STRING .)
    AND             reduce using rule 43 (expr -> STRING .)
    GREATEREQ       reduce using rule 43 (expr -> STRING .)
    LESSEQ          reduce using rule 43 (expr -> STRING .)
    NOTEQ           reduce using rule 43 (expr -> STRING .)
    EQEQ            reduce using rule 43 (expr -> STRING .)
    PIPE            reduce using rule 43 (expr -> STRING .)
    ?               reduce using rule 43 (expr -> STRING .)


state 221

    (97) for_statement -> FOR var_assign SEP expr . SEP var_assign block
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    SEP             shift and go to state 241
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 222

    (34) function_definition -> FN ID ( params . ) block
    (109) params -> params . , param
    )               shift and go to state 242
    ,               shift and go to state 207


state 223

    (69) expr -> expr PIPE ID ( args . )
    (113) args -> args . , arg
    )               shift and go to state 243
    ,               shift and go to state 203


state 224

    (72) expr -> expr ? expr : expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 72 (expr -> expr ? expr : expr .)
    ]               reduce using rule 72 (expr -> expr ? expr : expr .)
    ,               reduce using rule 72 (expr -> expr ? expr : expr .)
    )               reduce using rule 72 (expr -> expr ? expr : expr .)
    {               reduce using rule 72 (expr -> expr ? expr : expr .)
    LET             reduce using rule 72 (expr -> expr ? expr : expr .)
    END             reduce using rule 72 (expr -> expr ? expr : expr .)
    BEGIN           reduce using rule 72 (expr -> expr ? expr : expr .)
    NIL             reduce using rule 72 (expr -> expr ? expr : expr .)
    FALSE           reduce using rule 72 (expr -> expr ? expr : expr .)
    TRUE            reduce using rule 72 (expr -> expr ? expr : expr .)
    STRING          reduce using rule 72 (expr -> expr ? expr : expr .)
    FLOAT           reduce using rule 72 (expr -> expr ? expr : expr .)
    INT             reduce using rule 72 (expr -> expr ? expr : expr .)
    (               reduce using rule 72 (expr -> expr ? expr : expr .)
    !               reduce using rule 72 (expr -> expr ? expr : expr .)
    ~               reduce using rule 72 (expr -> expr ? expr : expr .)
    ID              reduce using rule 72 (expr -> expr ? expr : expr .)
    TYPEOF          reduce using rule 72 (expr -> expr ? expr : expr .)
    LAMBDA          reduce using rule 72 (expr -> expr ? expr : expr .)
    DEC             reduce using rule 72 (expr -> expr ? expr : expr .)
    INC             reduce using rule 72 (expr -> expr ? expr : expr .)
    CLASS           reduce using rule 72 (expr -> expr ? expr : expr .)
    STRUCT          reduce using rule 72 (expr -> expr ? expr : expr .)
    IF              reduce using rule 72 (expr -> expr ? expr : expr .)
    FOR             reduce using rule 72 (expr -> expr ? expr : expr .)
    WHILE           reduce using rule 72 (expr -> expr ? expr : expr .)
    RETURN          reduce using rule 72 (expr -> expr ? expr : expr .)
    FN              reduce using rule 72 (expr -> expr ? expr : expr .)
    IMPORT          reduce using rule 72 (expr -> expr ? expr : expr .)
    [               reduce using rule 72 (expr -> expr ? expr : expr .)
    :               reduce using rule 72 (expr -> expr ? expr : expr .)
    }               reduce using rule 72 (expr -> expr ? expr : expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 225

    (9) statement -> LET var : var_type SEP .
    LET             reduce using rule 9 (statement -> LET var : var_type SEP .)
    END             reduce using rule 9 (statement -> LET var : var_type SEP .)
    BEGIN           reduce using rule 9 (statement -> LET var : var_type SEP .)
    {               reduce using rule 9 (statement -> LET var : var_type SEP .)
    NIL             reduce using rule 9 (statement -> LET var : var_type SEP .)
    FALSE           reduce using rule 9 (statement -> LET var : var_type SEP .)
    TRUE            reduce using rule 9 (statement -> LET var : var_type SEP .)
    STRING          reduce using rule 9 (statement -> LET var : var_type SEP .)
    FLOAT           reduce using rule 9 (statement -> LET var : var_type SEP .)
    INT             reduce using rule 9 (statement -> LET var : var_type SEP .)
    (               reduce using rule 9 (statement -> LET var : var_type SEP .)
    !               reduce using rule 9 (statement -> LET var : var_type SEP .)
    +               reduce using rule 9 (statement -> LET var : var_type SEP .)
    -               reduce using rule 9 (statement -> LET var : var_type SEP .)
    ~               reduce using rule 9 (statement -> LET var : var_type SEP .)
    ID              reduce using rule 9 (statement -> LET var : var_type SEP .)
    TYPEOF          reduce using rule 9 (statement -> LET var : var_type SEP .)
    LAMBDA          reduce using rule 9 (statement -> LET var : var_type SEP .)
    DEC             reduce using rule 9 (statement -> LET var : var_type SEP .)
    INC             reduce using rule 9 (statement -> LET var : var_type SEP .)
    CLASS           reduce using rule 9 (statement -> LET var : var_type SEP .)
    STRUCT          reduce using rule 9 (statement -> LET var : var_type SEP .)
    IF              reduce using rule 9 (statement -> LET var : var_type SEP .)
    FOR             reduce using rule 9 (statement -> LET var : var_type SEP .)
    WHILE           reduce using rule 9 (statement -> LET var : var_type SEP .)
    RETURN          reduce using rule 9 (statement -> LET var : var_type SEP .)
    FN              reduce using rule 9 (statement -> LET var : var_type SEP .)
    IMPORT          reduce using rule 9 (statement -> LET var : var_type SEP .)
    [               reduce using rule 9 (statement -> LET var : var_type SEP .)
    $end            reduce using rule 9 (statement -> LET var : var_type SEP .)
    }               reduce using rule 9 (statement -> LET var : var_type SEP .)
    ELSE            reduce using rule 9 (statement -> LET var : var_type SEP .)


state 226

    (102) var -> var [ expr ] .
    :               reduce using rule 102 (var -> var [ expr ] .)
    ASSIGN          reduce using rule 102 (var -> var [ expr ] .)
    [               reduce using rule 102 (var -> var [ expr ] .)
    SEP             reduce using rule 102 (var -> var [ expr ] .)
    {               reduce using rule 102 (var -> var [ expr ] .)
    LET             reduce using rule 102 (var -> var [ expr ] .)
    END             reduce using rule 102 (var -> var [ expr ] .)
    BEGIN           reduce using rule 102 (var -> var [ expr ] .)
    NIL             reduce using rule 102 (var -> var [ expr ] .)
    FALSE           reduce using rule 102 (var -> var [ expr ] .)
    TRUE            reduce using rule 102 (var -> var [ expr ] .)
    STRING          reduce using rule 102 (var -> var [ expr ] .)
    FLOAT           reduce using rule 102 (var -> var [ expr ] .)
    INT             reduce using rule 102 (var -> var [ expr ] .)
    (               reduce using rule 102 (var -> var [ expr ] .)
    !               reduce using rule 102 (var -> var [ expr ] .)
    +               reduce using rule 102 (var -> var [ expr ] .)
    -               reduce using rule 102 (var -> var [ expr ] .)
    ~               reduce using rule 102 (var -> var [ expr ] .)
    ID              reduce using rule 102 (var -> var [ expr ] .)
    TYPEOF          reduce using rule 102 (var -> var [ expr ] .)
    LAMBDA          reduce using rule 102 (var -> var [ expr ] .)
    DEC             reduce using rule 102 (var -> var [ expr ] .)
    INC             reduce using rule 102 (var -> var [ expr ] .)
    CLASS           reduce using rule 102 (var -> var [ expr ] .)
    STRUCT          reduce using rule 102 (var -> var [ expr ] .)
    IF              reduce using rule 102 (var -> var [ expr ] .)
    FOR             reduce using rule 102 (var -> var [ expr ] .)
    WHILE           reduce using rule 102 (var -> var [ expr ] .)
    RETURN          reduce using rule 102 (var -> var [ expr ] .)
    FN              reduce using rule 102 (var -> var [ expr ] .)
    IMPORT          reduce using rule 102 (var -> var [ expr ] .)
    SHRASGN         reduce using rule 102 (var -> var [ expr ] .)
    SHLASGN         reduce using rule 102 (var -> var [ expr ] .)
    XORASGN         reduce using rule 102 (var -> var [ expr ] .)
    ORASGN          reduce using rule 102 (var -> var [ expr ] .)
    ANDASGN         reduce using rule 102 (var -> var [ expr ] .)
    MODULOASGN      reduce using rule 102 (var -> var [ expr ] .)
    SLASHASGN       reduce using rule 102 (var -> var [ expr ] .)
    STARASGN        reduce using rule 102 (var -> var [ expr ] .)
    MINUSASGN       reduce using rule 102 (var -> var [ expr ] .)
    PLUSASGN        reduce using rule 102 (var -> var [ expr ] .)


state 227

    (70) expr -> ID DOUBLECOLON ID ( args . )
    (113) args -> args . , arg
    )               shift and go to state 244
    ,               shift and go to state 203


state 228

    (113) args -> args , arg .
    )               reduce using rule 113 (args -> args , arg .)
    ,               reduce using rule 113 (args -> args , arg .)


state 229

    (75) expr -> ID LEFTARROW { struct_init_exprs } .
    SEP             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    %               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    /               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    *               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    -               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    +               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    |               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ^               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    &               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SHR             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SHL             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    GREATER         reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LESS            reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    OR              reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    AND             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    GREATEREQ       reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LESSEQ          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    NOTEQ           reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    EQEQ            reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    PIPE            reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ?               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ]               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ,               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    )               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    {               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LET             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    END             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    BEGIN           reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    NIL             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FALSE           reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TRUE            reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    STRING          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FLOAT           reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    INT             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    (               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    !               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ~               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ID              reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TYPEOF          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LAMBDA          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    DEC             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    INC             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    CLASS           reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    STRUCT          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    IF              reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FOR             reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    WHILE           reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    RETURN          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FN              reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    IMPORT          reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    [               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    :               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)
    }               reduce using rule 75 (expr -> ID LEFTARROW { struct_init_exprs } .)


state 230

    (76) struct_init_exprs -> struct_init_exprs , . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 245
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 231

    (74) expr -> LAMBDA ( params ) ARROW . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 23
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    [               shift and go to state 25

    expr                           shift and go to state 246
    getter                         shift and go to state 22
    var                            shift and go to state 97
    list_val                       shift and go to state 26

state 232

    (109) params -> params , param .
    )               reduce using rule 109 (params -> params , param .)
    ,               reduce using rule 109 (params -> params , param .)


state 233

    (110) param -> ID : var_type .
    )               reduce using rule 110 (param -> ID : var_type .)
    ,               reduce using rule 110 (param -> ID : var_type .)


state 234

    (19) class_definition -> CLASS ID { function_definitions } .
    LET             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    END             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    BEGIN           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    {               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    NIL             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FALSE           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    TRUE            reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    STRING          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FLOAT           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    INT             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    (               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    !               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    +               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    -               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    ~               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    ID              reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    TYPEOF          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    LAMBDA          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    DEC             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    INC             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    CLASS           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    STRUCT          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    IF              reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FOR             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    WHILE           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    RETURN          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FN              reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    IMPORT          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    [               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    $end            reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    }               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    ELSE            reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)


state 235

    (20) function_definitions -> function_definitions function_definition .
    }               reduce using rule 20 (function_definitions -> function_definitions function_definition .)
    FN              reduce using rule 20 (function_definitions -> function_definitions function_definition .)


state 236

    (23) struct_definition -> STRUCT ID { struct_fields } . SEP
    SEP             shift and go to state 247


state 237

    (24) struct_fields -> struct_fields struct_field .
    }               reduce using rule 24 (struct_fields -> struct_fields struct_field .)
    LET             reduce using rule 24 (struct_fields -> struct_fields struct_field .)


state 238

    (26) struct_field -> LET ID . : var_type SEP
    :               shift and go to state 248


state 239

    (95) if_statement -> IF expr block ELSE block .
    LET             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    END             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    BEGIN           reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    {               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    NIL             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    FALSE           reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    TRUE            reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    STRING          reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    FLOAT           reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    INT             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    (               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    !               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    +               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    -               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    ~               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    ID              reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    TYPEOF          reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    LAMBDA          reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    DEC             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    INC             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    CLASS           reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    STRUCT          reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    IF              reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    FOR             reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    FN              reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    IMPORT          reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    [               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    $end            reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    }               reduce using rule 95 (if_statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 95 (if_statement -> IF expr block ELSE block .)


state 240

    (106) block -> { program } .
    ELSE            reduce using rule 106 (block -> { program } .)
    LET             reduce using rule 106 (block -> { program } .)
    END             reduce using rule 106 (block -> { program } .)
    BEGIN           reduce using rule 106 (block -> { program } .)
    {               reduce using rule 106 (block -> { program } .)
    NIL             reduce using rule 106 (block -> { program } .)
    FALSE           reduce using rule 106 (block -> { program } .)
    TRUE            reduce using rule 106 (block -> { program } .)
    STRING          reduce using rule 106 (block -> { program } .)
    FLOAT           reduce using rule 106 (block -> { program } .)
    INT             reduce using rule 106 (block -> { program } .)
    (               reduce using rule 106 (block -> { program } .)
    !               reduce using rule 106 (block -> { program } .)
    +               reduce using rule 106 (block -> { program } .)
    -               reduce using rule 106 (block -> { program } .)
    ~               reduce using rule 106 (block -> { program } .)
    ID              reduce using rule 106 (block -> { program } .)
    TYPEOF          reduce using rule 106 (block -> { program } .)
    LAMBDA          reduce using rule 106 (block -> { program } .)
    DEC             reduce using rule 106 (block -> { program } .)
    INC             reduce using rule 106 (block -> { program } .)
    CLASS           reduce using rule 106 (block -> { program } .)
    STRUCT          reduce using rule 106 (block -> { program } .)
    IF              reduce using rule 106 (block -> { program } .)
    FOR             reduce using rule 106 (block -> { program } .)
    WHILE           reduce using rule 106 (block -> { program } .)
    RETURN          reduce using rule 106 (block -> { program } .)
    FN              reduce using rule 106 (block -> { program } .)
    IMPORT          reduce using rule 106 (block -> { program } .)
    [               reduce using rule 106 (block -> { program } .)
    $end            reduce using rule 106 (block -> { program } .)
    }               reduce using rule 106 (block -> { program } .)


state 241

    (97) for_statement -> FOR var_assign SEP expr SEP . var_assign block
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (102) var -> . var [ expr ]
    (103) var -> . ID
    DEC             shift and go to state 40
    INC             shift and go to state 41
    ID              shift and go to state 109

    var_assign                     shift and go to state 249
    var                            shift and go to state 115

state 242

    (34) function_definition -> FN ID ( params ) . block
    (105) block -> . statement
    (106) block -> . { program }
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 179
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    block                          shift and go to state 250
    statement                      shift and go to state 178
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    expr                           shift and go to state 7
    var_assign                     shift and go to state 8
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 243

    (69) expr -> expr PIPE ID ( args ) .
    SEP             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    %               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    /               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    *               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    -               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    +               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    |               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    ^               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    &               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    SHR             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    SHL             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    GREATER         reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    LESS            reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    OR              reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    AND             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    GREATEREQ       reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    LESSEQ          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    NOTEQ           reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    EQEQ            reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    PIPE            reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    ?               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    ]               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    ,               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    )               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    {               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    LET             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    END             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    BEGIN           reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    NIL             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    FALSE           reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    TRUE            reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    STRING          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    FLOAT           reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    INT             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    (               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    !               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    ~               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    ID              reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    TYPEOF          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    LAMBDA          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    DEC             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    INC             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    CLASS           reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    STRUCT          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    IF              reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    FOR             reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    WHILE           reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    RETURN          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    FN              reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    IMPORT          reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    [               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    :               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)
    }               reduce using rule 69 (expr -> expr PIPE ID ( args ) .)


state 244

    (70) expr -> ID DOUBLECOLON ID ( args ) .
    SEP             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    %               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    /               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    *               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    -               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    +               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    |               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    ^               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    &               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    SHR             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    SHL             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    GREATER         reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    LESS            reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    OR              reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    AND             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    GREATEREQ       reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    LESSEQ          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    NOTEQ           reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    EQEQ            reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    PIPE            reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    ?               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    ]               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    ,               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    )               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    {               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    LET             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    END             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    BEGIN           reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    NIL             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    FALSE           reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    TRUE            reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    STRING          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    FLOAT           reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    INT             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    (               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    !               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    ~               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    ID              reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    TYPEOF          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    LAMBDA          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    DEC             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    INC             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    CLASS           reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    STRUCT          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    IF              reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    FOR             reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    WHILE           reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    RETURN          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    FN              reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    IMPORT          reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    [               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    :               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)
    }               reduce using rule 70 (expr -> ID DOUBLECOLON ID ( args ) .)


state 245

    (76) struct_init_exprs -> struct_init_exprs , expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
    }               reduce using rule 76 (struct_init_exprs -> struct_init_exprs , expr .)
    ,               reduce using rule 76 (struct_init_exprs -> struct_init_exprs , expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 246

    (74) expr -> LAMBDA ( params ) ARROW expr .
    (47) expr -> expr . % expr
    (48) expr -> expr . / expr
    (49) expr -> expr . * expr
    (50) expr -> expr . - expr
    (51) expr -> expr . + expr
    (56) expr -> expr . | expr
    (57) expr -> expr . ^ expr
    (58) expr -> expr . & expr
    (59) expr -> expr . SHR expr
    (60) expr -> expr . SHL expr
    (61) expr -> expr . GREATER expr
    (62) expr -> expr . LESS expr
    (63) expr -> expr . OR expr
    (64) expr -> expr . AND expr
    (65) expr -> expr . GREATEREQ expr
    (66) expr -> expr . LESSEQ expr
    (67) expr -> expr . NOTEQ expr
    (68) expr -> expr . EQEQ expr
    (69) expr -> expr . PIPE ID ( args )
    (72) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    ]               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    ,               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    )               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    {               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    LET             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    END             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    BEGIN           reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    NIL             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    FALSE           reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    TRUE            reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    STRING          reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    FLOAT           reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    INT             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    (               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    !               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    ~               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    ID              reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    TYPEOF          reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    LAMBDA          reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    DEC             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    INC             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    CLASS           reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    STRUCT          reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    IF              reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    FOR             reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    WHILE           reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    RETURN          reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    FN              reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    IMPORT          reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    [               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    :               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    }               reduce using rule 74 (expr -> LAMBDA ( params ) ARROW expr .)
    %               shift and go to state 52
    /               shift and go to state 53
    *               shift and go to state 54
    -               shift and go to state 55
    +               shift and go to state 56
    |               shift and go to state 57
    ^               shift and go to state 58
    &               shift and go to state 59
    SHR             shift and go to state 60
    SHL             shift and go to state 61
    GREATER         shift and go to state 62
    LESS            shift and go to state 63
    OR              shift and go to state 64
    AND             shift and go to state 65
    GREATEREQ       shift and go to state 66
    LESSEQ          shift and go to state 67
    NOTEQ           shift and go to state 68
    EQEQ            shift and go to state 69
    PIPE            shift and go to state 70
    ?               shift and go to state 71


state 247

    (23) struct_definition -> STRUCT ID { struct_fields } SEP .
    LET             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    END             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    BEGIN           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    {               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    NIL             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FALSE           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    TRUE            reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    STRING          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FLOAT           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    INT             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    (               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    !               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    +               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    -               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ~               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ID              reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    TYPEOF          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    LAMBDA          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    DEC             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    INC             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    CLASS           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    STRUCT          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    IF              reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FOR             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    WHILE           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    RETURN          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FN              reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    IMPORT          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    [               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    $end            reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    }               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ELSE            reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)


state 248

    (26) struct_field -> LET ID : . var_type SEP
    (27) var_type -> . DICT_TYPE
    (28) var_type -> . LIST_TYPE
    (29) var_type -> . BOOL_TYPE
    (30) var_type -> . STRING_TYPE
    (31) var_type -> . FLOAT_TYPE
    (32) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 188
    LIST_TYPE       shift and go to state 189
    BOOL_TYPE       shift and go to state 190
    STRING_TYPE     shift and go to state 191
    FLOAT_TYPE      shift and go to state 192
    INT_TYPE        shift and go to state 193

    var_type                       shift and go to state 251

state 249

    (97) for_statement -> FOR var_assign SEP expr SEP var_assign . block
    (105) block -> . statement
    (106) block -> . { program }
    (5) statement -> . end_statement
    (6) statement -> . begin_statement
    (7) statement -> . expr SEP
    (8) statement -> . var_assign SEP
    (9) statement -> . LET var : var_type SEP
    (10) statement -> . var_define SEP
    (11) statement -> . class_definition
    (12) statement -> . struct_definition
    (13) statement -> . if_statement
    (14) statement -> . for_statement
    (15) statement -> . while_statement
    (16) statement -> . return_statement
    (17) statement -> . function_definition
    (18) statement -> . import_statement
    (122) end_statement -> . END
    (121) begin_statement -> . BEGIN
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr % expr
    (48) expr -> . expr / expr
    (49) expr -> . expr * expr
    (50) expr -> . expr - expr
    (51) expr -> . expr + expr
    (52) expr -> . ! expr
    (53) expr -> . + expr
    (54) expr -> . - expr
    (55) expr -> . ~ expr
    (56) expr -> . expr | expr
    (57) expr -> . expr ^ expr
    (58) expr -> . expr & expr
    (59) expr -> . expr SHR expr
    (60) expr -> . expr SHL expr
    (61) expr -> . expr GREATER expr
    (62) expr -> . expr LESS expr
    (63) expr -> . expr OR expr
    (64) expr -> . expr AND expr
    (65) expr -> . expr GREATEREQ expr
    (66) expr -> . expr LESSEQ expr
    (67) expr -> . expr NOTEQ expr
    (68) expr -> . expr EQEQ expr
    (69) expr -> . expr PIPE ID ( args )
    (70) expr -> . ID DOUBLECOLON ID ( args )
    (71) expr -> . ID ( args )
    (72) expr -> . expr ? expr : expr
    (73) expr -> . TYPEOF expr
    (74) expr -> . LAMBDA ( params ) ARROW expr
    (75) expr -> . ID LEFTARROW { struct_init_exprs }
    (81) var_assign -> . DEC var
    (82) var_assign -> . INC var
    (83) var_assign -> . var SHRASGN expr
    (84) var_assign -> . var SHLASGN expr
    (85) var_assign -> . var XORASGN expr
    (86) var_assign -> . var ORASGN expr
    (87) var_assign -> . var ANDASGN expr
    (88) var_assign -> . var MODULOASGN expr
    (89) var_assign -> . var SLASHASGN expr
    (90) var_assign -> . var STARASGN expr
    (91) var_assign -> . var MINUSASGN expr
    (92) var_assign -> . var PLUSASGN expr
    (93) var_assign -> . var ASSIGN expr
    (78) var_define -> . LET getter ASSIGN expr
    (79) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (94) if_statement -> . IF expr block
    (95) if_statement -> . IF expr block ELSE block
    (97) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (96) while_statement -> . WHILE expr block
    (80) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (119) getter -> . ID
    (120) getter -> . getter . ID
    (102) var -> . var [ expr ]
    (103) var -> . ID
    (98) list_val -> . [ exprs ]
    {               shift and go to state 179
    LET             shift and go to state 9
    END             shift and go to state 20
    BEGIN           shift and go to state 21
    NIL             shift and go to state 24
    FALSE           shift and go to state 27
    TRUE            shift and go to state 28
    STRING          shift and go to state 29
    FLOAT           shift and go to state 30
    INT             shift and go to state 31
    (               shift and go to state 32
    !               shift and go to state 35
    +               shift and go to state 34
    -               shift and go to state 33
    ~               shift and go to state 36
    ID              shift and go to state 37
    TYPEOF          shift and go to state 38
    LAMBDA          shift and go to state 39
    DEC             shift and go to state 40
    INC             shift and go to state 41
    CLASS           shift and go to state 42
    STRUCT          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    RETURN          shift and go to state 47
    FN              shift and go to state 48
    IMPORT          shift and go to state 49
    [               shift and go to state 25

    var_assign                     shift and go to state 8
    expr                           shift and go to state 7
    block                          shift and go to state 252
    statement                      shift and go to state 178
    end_statement                  shift and go to state 5
    begin_statement                shift and go to state 6
    var                            shift and go to state 10
    var_define                     shift and go to state 11
    class_definition               shift and go to state 12
    struct_definition              shift and go to state 13
    if_statement                   shift and go to state 14
    for_statement                  shift and go to state 15
    while_statement                shift and go to state 16
    return_statement               shift and go to state 17
    function_definition            shift and go to state 18
    import_statement               shift and go to state 19
    getter                         shift and go to state 22
    list_val                       shift and go to state 26

state 250

    (34) function_definition -> FN ID ( params ) block .
    LET             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    END             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    BEGIN           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    {               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    NIL             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FALSE           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    TRUE            reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    STRING          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FLOAT           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    INT             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    (               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    !               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    +               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    -               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    ~               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    ID              reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    TYPEOF          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    LAMBDA          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    DEC             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    INC             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    CLASS           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    STRUCT          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    IF              reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FOR             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    WHILE           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    RETURN          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FN              reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    IMPORT          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    [               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    $end            reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    }               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    ELSE            reduce using rule 34 (function_definition -> FN ID ( params ) block .)


state 251

    (26) struct_field -> LET ID : var_type . SEP
    SEP             shift and go to state 253


state 252

    (97) for_statement -> FOR var_assign SEP expr SEP var_assign block .
    LET             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    END             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    BEGIN           reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    {               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    NIL             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FALSE           reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    TRUE            reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    STRING          reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FLOAT           reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    INT             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    (               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    !               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    +               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    -               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ~               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ID              reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    TYPEOF          reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    LAMBDA          reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    DEC             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    INC             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    CLASS           reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    STRUCT          reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    IF              reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FOR             reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    WHILE           reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    RETURN          reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FN              reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    IMPORT          reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    [               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    $end            reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    }               reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ELSE            reduce using rule 97 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)


state 253

    (26) struct_field -> LET ID : var_type SEP .
    }               reduce using rule 26 (struct_field -> LET ID : var_type SEP .)
    LET             reduce using rule 26 (struct_field -> LET ID : var_type SEP .)


Conflicts:

shift/reduce conflict for ( in state 37 resolved as shift
shift/reduce conflict for ( in state 37 resolved as shift
shift/reduce conflict for [ in state 97 resolved as shift
shift/reduce conflict for % in state 106 resolved as shift
shift/reduce conflict for / in state 106 resolved as shift
shift/reduce conflict for * in state 106 resolved as shift
shift/reduce conflict for - in state 106 resolved as shift
shift/reduce conflict for + in state 106 resolved as shift
shift/reduce conflict for | in state 106 resolved as shift
shift/reduce conflict for ^ in state 106 resolved as shift
shift/reduce conflict for & in state 106 resolved as shift
shift/reduce conflict for SHR in state 106 resolved as shift
shift/reduce conflict for SHL in state 106 resolved as shift
shift/reduce conflict for GREATER in state 106 resolved as shift
shift/reduce conflict for LESS in state 106 resolved as shift
shift/reduce conflict for OR in state 106 resolved as shift
shift/reduce conflict for AND in state 106 resolved as shift
shift/reduce conflict for GREATEREQ in state 106 resolved as shift
shift/reduce conflict for LESSEQ in state 106 resolved as shift
shift/reduce conflict for NOTEQ in state 106 resolved as shift
shift/reduce conflict for EQEQ in state 106 resolved as shift
shift/reduce conflict for PIPE in state 106 resolved as shift
shift/reduce conflict for ? in state 106 resolved as shift
shift/reduce conflict for - in state 155 resolved as shift
shift/reduce conflict for + in state 155 resolved as shift
shift/reduce conflict for FN in state 173 resolved as shift
shift/reduce conflict for ELSE in state 175 resolved as shift
shift/reduce conflict for % in state 224 resolved as shift
shift/reduce conflict for / in state 224 resolved as shift
shift/reduce conflict for * in state 224 resolved as shift
shift/reduce conflict for - in state 224 resolved as shift
shift/reduce conflict for + in state 224 resolved as shift
shift/reduce conflict for | in state 224 resolved as shift
shift/reduce conflict for ^ in state 224 resolved as shift
shift/reduce conflict for & in state 224 resolved as shift
shift/reduce conflict for SHR in state 224 resolved as shift
shift/reduce conflict for SHL in state 224 resolved as shift
shift/reduce conflict for GREATER in state 224 resolved as shift
shift/reduce conflict for LESS in state 224 resolved as shift
shift/reduce conflict for OR in state 224 resolved as shift
shift/reduce conflict for AND in state 224 resolved as shift
shift/reduce conflict for GREATEREQ in state 224 resolved as shift
shift/reduce conflict for LESSEQ in state 224 resolved as shift
shift/reduce conflict for NOTEQ in state 224 resolved as shift
shift/reduce conflict for EQEQ in state 224 resolved as shift
shift/reduce conflict for PIPE in state 224 resolved as shift
shift/reduce conflict for ? in state 224 resolved as shift
shift/reduce conflict for % in state 246 resolved as shift
shift/reduce conflict for / in state 246 resolved as shift
shift/reduce conflict for * in state 246 resolved as shift
shift/reduce conflict for - in state 246 resolved as shift
shift/reduce conflict for + in state 246 resolved as shift
shift/reduce conflict for | in state 246 resolved as shift
shift/reduce conflict for ^ in state 246 resolved as shift
shift/reduce conflict for & in state 246 resolved as shift
shift/reduce conflict for SHR in state 246 resolved as shift
shift/reduce conflict for SHL in state 246 resolved as shift
shift/reduce conflict for GREATER in state 246 resolved as shift
shift/reduce conflict for LESS in state 246 resolved as shift
shift/reduce conflict for OR in state 246 resolved as shift
shift/reduce conflict for AND in state 246 resolved as shift
shift/reduce conflict for GREATEREQ in state 246 resolved as shift
shift/reduce conflict for LESSEQ in state 246 resolved as shift
shift/reduce conflict for NOTEQ in state 246 resolved as shift
shift/reduce conflict for EQEQ in state 246 resolved as shift
shift/reduce conflict for PIPE in state 246 resolved as shift
shift/reduce conflict for ? in state 246 resolved as shift
reduce/reduce conflict in state 37 resolved using rule var -> ID
rejected rule (getter -> ID) in state 37
reduce/reduce conflict in state 75 resolved using rule var -> ID
rejected rule (getter -> ID) in state 75
reduce/reduce conflict in state 197 resolved using rule expr -> var [ expr ]
rejected rule (var -> var [ expr ]) in state 197
reduce/reduce conflict in state 216 resolved using rule expr -> - expr  [precedence=right, level=12]
rejected rule (expr -> expr - expr  [precedence=left, level=10]) in state 216
reduce/reduce conflict in state 217 resolved using rule expr -> + expr  [precedence=right, level=12]
rejected rule (expr -> expr + expr  [precedence=left, level=10]) in state 217
reduce/reduce conflict in state 219 resolved using rule program -> empty
rejected rule (member_list -> empty) in state 219
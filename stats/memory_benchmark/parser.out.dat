Grammar:

Rule 0     S' -> program
Rule 1     program -> empty
Rule 2     program -> statements
Rule 3     statements -> statements statement
Rule 4     statements -> statement
Rule 5     statement -> expr SEP
Rule 6     statement -> var_assign SEP
Rule 7     statement -> LET var : var_type SEP
Rule 8     statement -> var_define SEP
Rule 9     statement -> class_definition
Rule 10    statement -> struct_definition
Rule 11    statement -> if_statement
Rule 12    statement -> for_statement
Rule 13    statement -> while_statement
Rule 14    statement -> return_statement
Rule 15    statement -> function_definition
Rule 16    statement -> import_statement
Rule 17    class_definition -> CLASS ID { function_definitions }
Rule 18    function_definitions -> function_definitions function_definition
Rule 19    function_definitions -> function_definition
Rule 20    function_definitions -> empty
Rule 21    struct_definition -> STRUCT ID { struct_fields } SEP
Rule 22    struct_fields -> struct_fields struct_field
Rule 23    struct_fields -> struct_field
Rule 24    struct_field -> LET ID : var_type SEP
Rule 25    var_type -> DICT_TYPE
Rule 26    var_type -> LIST_TYPE
Rule 27    var_type -> BOOL_TYPE
Rule 28    var_type -> STRING_TYPE
Rule 29    var_type -> FLOAT_TYPE
Rule 30    var_type -> INT_TYPE
Rule 31    import_statement -> IMPORT STRING SEP
Rule 32    function_definition -> FN ID ( params ) block
Rule 33    expr -> getter
Rule 34    expr -> { member_list }
Rule 35    expr -> NIL
Rule 36    expr -> var
Rule 37    expr -> var [ expr ]
Rule 38    expr -> list_val
Rule 39    expr -> FALSE
Rule 40    expr -> TRUE
Rule 41    expr -> STRING
Rule 42    expr -> FLOAT
Rule 43    expr -> INT
Rule 44    expr -> ( expr )
Rule 45    expr -> expr % expr  [precedence=left, level=11]
Rule 46    expr -> expr / expr  [precedence=left, level=11]
Rule 47    expr -> expr * expr  [precedence=left, level=11]
Rule 48    expr -> expr - expr  [precedence=left, level=10]
Rule 49    expr -> expr + expr  [precedence=left, level=10]
Rule 50    expr -> ! expr  [precedence=right, level=13]
Rule 51    expr -> + expr  [precedence=right, level=12]
Rule 52    expr -> - expr  [precedence=right, level=12]
Rule 53    expr -> ~ expr  [precedence=right, level=12]
Rule 54    expr -> expr | expr  [precedence=left, level=4]
Rule 55    expr -> expr ^ expr  [precedence=left, level=5]
Rule 56    expr -> expr & expr  [precedence=left, level=6]
Rule 57    expr -> expr SHR expr  [precedence=left, level=9]
Rule 58    expr -> expr SHL expr  [precedence=left, level=9]
Rule 59    expr -> expr GREATER expr  [precedence=left, level=8]
Rule 60    expr -> expr LESS expr  [precedence=left, level=8]
Rule 61    expr -> expr OR expr  [precedence=left, level=2]
Rule 62    expr -> expr AND expr  [precedence=left, level=3]
Rule 63    expr -> expr GREATEREQ expr  [precedence=left, level=8]
Rule 64    expr -> expr LESSEQ expr  [precedence=left, level=8]
Rule 65    expr -> expr NOTEQ expr  [precedence=left, level=7]
Rule 66    expr -> expr EQEQ expr  [precedence=left, level=7]
Rule 67    expr -> expr PIPE ID ( args )
Rule 68    expr -> ID DOUBLECOLON ID ( args )
Rule 69    expr -> ID ( args )
Rule 70    expr -> expr ? expr : expr
Rule 71    expr -> TYPEOF expr
Rule 72    expr -> LAMBDA ( params ) ARROW expr
Rule 73    expr -> ID LEFTARROW { struct_init_exprs }
Rule 74    struct_init_exprs -> struct_init_exprs , expr
Rule 75    struct_init_exprs -> expr
Rule 76    var_define -> LET getter ASSIGN expr
Rule 77    var_define -> LET var ASSIGN expr
Rule 78    return_statement -> RETURN expr SEP
Rule 79    var_assign -> DEC var  [precedence=right, level=12]
Rule 80    var_assign -> INC var  [precedence=right, level=12]
Rule 81    var_assign -> var SHRASGN expr  [precedence=right, level=1]
Rule 82    var_assign -> var SHLASGN expr  [precedence=right, level=1]
Rule 83    var_assign -> var XORASGN expr  [precedence=right, level=1]
Rule 84    var_assign -> var ORASGN expr  [precedence=right, level=1]
Rule 85    var_assign -> var ANDASGN expr  [precedence=right, level=1]
Rule 86    var_assign -> var MODULOASGN expr  [precedence=right, level=1]
Rule 87    var_assign -> var SLASHASGN expr  [precedence=right, level=1]
Rule 88    var_assign -> var STARASGN expr  [precedence=right, level=1]
Rule 89    var_assign -> var MINUSASGN expr  [precedence=right, level=1]
Rule 90    var_assign -> var PLUSASGN expr  [precedence=right, level=1]
Rule 91    var_assign -> var ASSIGN expr
Rule 92    if_statement -> IF expr block
Rule 93    if_statement -> IF expr block ELSE block
Rule 94    while_statement -> WHILE expr block
Rule 95    for_statement -> FOR var_assign SEP expr SEP var_assign block
Rule 96    list_val -> [ exprs ]
Rule 97    exprs -> exprs , expr
Rule 98    exprs -> expr
Rule 99    exprs -> empty
Rule 100   var -> var [ expr ]
Rule 101   var -> ID
Rule 102   empty -> <empty>
Rule 103   block -> statement
Rule 104   block -> { program }
Rule 105   params -> empty
Rule 106   params -> param
Rule 107   params -> params , param
Rule 108   param -> ID : var_type
Rule 109   args -> empty
Rule 110   args -> arg
Rule 111   args -> args , arg
Rule 112   arg -> expr
Rule 113   member_list -> member_list , member
Rule 114   member_list -> member
Rule 115   member_list -> empty
Rule 116   member -> STRING : expr
Rule 117   getter -> ID
Rule 118   getter -> getter . ID

Terminals, with rules where they appear:

!                    : 50
%                    : 45
&                    : 56
(                    : 32 44 67 68 69 72
)                    : 32 44 67 68 69 72
*                    : 47
+                    : 49 51
,                    : 74 97 107 111 113
-                    : 48 52
.                    : 118
/                    : 46
:                    : 7 24 70 108 116
?                    : 70
AND                  : 62
ANDASGN              : 85
ARROW                : 72
ASSIGN               : 76 77 91
BOOL_TYPE            : 27
CLASS                : 17
DEC                  : 79
DICT_TYPE            : 25
DOUBLECOLON          : 68
ELSE                 : 93
EQEQ                 : 66
FALSE                : 39
FLOAT                : 42
FLOAT_TYPE           : 29
FN                   : 32
FOR                  : 95
GREATER              : 59
GREATEREQ            : 63
ID                   : 17 21 24 32 67 68 68 69 73 101 108 117 118
IF                   : 92 93
IMPORT               : 31
INC                  : 80
INT                  : 43
INT_TYPE             : 30
LAMBDA               : 72
LEFTARROW            : 73
LESS                 : 60
LESSEQ               : 64
LET                  : 7 24 76 77
LIST_TYPE            : 26
MINUSASGN            : 89
MODULOASGN           : 86
NIL                  : 35
NOTEQ                : 65
OR                   : 61
ORASGN               : 84
PIPE                 : 67
PLUSASGN             : 90
RETURN               : 78
SEP                  : 5 6 7 8 21 24 31 78 95 95
SHL                  : 58
SHLASGN              : 82
SHR                  : 57
SHRASGN              : 81
SLASHASGN            : 87
STARASGN             : 88
STRING               : 31 41 116
STRING_TYPE          : 28
STRUCT               : 21
TRUE                 : 40
TYPEOF               : 71
WHILE                : 94
XORASGN              : 83
[                    : 37 96 100
]                    : 37 96 100
^                    : 55
error                : 
{                    : 17 21 34 73 104
|                    : 54
}                    : 17 21 34 73 104
~                    : 53

Nonterminals, with rules where they appear:

arg                  : 110 111
args                 : 67 68 69 111
block                : 32 92 93 93 94 95
class_definition     : 9
empty                : 1 20 99 105 109 115
expr                 : 5 37 44 45 45 46 46 47 47 48 48 49 49 50 51 52 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 70 70 70 71 72 74 75 76 77 78 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 97 98 100 112 116
exprs                : 96 97
for_statement        : 12
function_definition  : 15 18 19
function_definitions : 17 18
getter               : 33 76 118
if_statement         : 11
import_statement     : 16
list_val             : 38
member               : 113 114
member_list          : 34 113
param                : 106 107
params               : 32 72 107
program              : 104 0
return_statement     : 14
statement            : 3 4 103
statements           : 2 3
struct_definition    : 10
struct_field         : 22 23
struct_fields        : 21 22
struct_init_exprs    : 73 74
var                  : 7 36 37 77 79 80 81 82 83 84 85 86 87 88 89 90 91 100
var_assign           : 6 95 95
var_define           : 8
var_type             : 7 24 108
while_statement      : 13


state 0

    (0) S' -> . program
    (1) program -> . empty
    (2) program -> . statements
    (102) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    $end            reduce using rule 102 (empty -> .)
    LET             shift and go to state 7
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    program                        shift and go to state 1
    empty                          shift and go to state 2
    statements                     shift and go to state 3
    statement                      shift and go to state 4
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 1

    (0) S' -> program .


state 2

    (1) program -> empty .
    $end            reduce using rule 1 (program -> empty .)


state 3

    (2) program -> statements .
    (3) statements -> statements . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    $end            reduce using rule 2 (program -> statements .)
    }               reduce using rule 2 (program -> statements .)
    LET             shift and go to state 7
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    statement                      shift and go to state 46
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 4

    (4) statements -> statement .
    LET             reduce using rule 4 (statements -> statement .)
    {               reduce using rule 4 (statements -> statement .)
    NIL             reduce using rule 4 (statements -> statement .)
    FALSE           reduce using rule 4 (statements -> statement .)
    TRUE            reduce using rule 4 (statements -> statement .)
    STRING          reduce using rule 4 (statements -> statement .)
    FLOAT           reduce using rule 4 (statements -> statement .)
    INT             reduce using rule 4 (statements -> statement .)
    (               reduce using rule 4 (statements -> statement .)
    !               reduce using rule 4 (statements -> statement .)
    +               reduce using rule 4 (statements -> statement .)
    -               reduce using rule 4 (statements -> statement .)
    ~               reduce using rule 4 (statements -> statement .)
    ID              reduce using rule 4 (statements -> statement .)
    TYPEOF          reduce using rule 4 (statements -> statement .)
    LAMBDA          reduce using rule 4 (statements -> statement .)
    DEC             reduce using rule 4 (statements -> statement .)
    INC             reduce using rule 4 (statements -> statement .)
    CLASS           reduce using rule 4 (statements -> statement .)
    STRUCT          reduce using rule 4 (statements -> statement .)
    IF              reduce using rule 4 (statements -> statement .)
    FOR             reduce using rule 4 (statements -> statement .)
    WHILE           reduce using rule 4 (statements -> statement .)
    RETURN          reduce using rule 4 (statements -> statement .)
    FN              reduce using rule 4 (statements -> statement .)
    IMPORT          reduce using rule 4 (statements -> statement .)
    [               reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)
    }               reduce using rule 4 (statements -> statement .)


state 5

    (5) statement -> expr . SEP
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             shift and go to state 47
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 6

    (6) statement -> var_assign . SEP
    SEP             shift and go to state 68


state 7

    (7) statement -> LET . var : var_type SEP
    (76) var_define -> LET . getter ASSIGN expr
    (77) var_define -> LET . var ASSIGN expr
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (117) getter -> . ID
    (118) getter -> . getter . ID
    ID              shift and go to state 71

    var                            shift and go to state 69
    getter                         shift and go to state 70

state 8

    (36) expr -> var .
    (37) expr -> var . [ expr ]
    (81) var_assign -> var . SHRASGN expr
    (82) var_assign -> var . SHLASGN expr
    (83) var_assign -> var . XORASGN expr
    (84) var_assign -> var . ORASGN expr
    (85) var_assign -> var . ANDASGN expr
    (86) var_assign -> var . MODULOASGN expr
    (87) var_assign -> var . SLASHASGN expr
    (88) var_assign -> var . STARASGN expr
    (89) var_assign -> var . MINUSASGN expr
    (90) var_assign -> var . PLUSASGN expr
    (91) var_assign -> var . ASSIGN expr
    (100) var -> var . [ expr ]
    SEP             reduce using rule 36 (expr -> var .)
    %               reduce using rule 36 (expr -> var .)
    /               reduce using rule 36 (expr -> var .)
    *               reduce using rule 36 (expr -> var .)
    -               reduce using rule 36 (expr -> var .)
    +               reduce using rule 36 (expr -> var .)
    |               reduce using rule 36 (expr -> var .)
    ^               reduce using rule 36 (expr -> var .)
    &               reduce using rule 36 (expr -> var .)
    SHR             reduce using rule 36 (expr -> var .)
    SHL             reduce using rule 36 (expr -> var .)
    GREATER         reduce using rule 36 (expr -> var .)
    LESS            reduce using rule 36 (expr -> var .)
    OR              reduce using rule 36 (expr -> var .)
    AND             reduce using rule 36 (expr -> var .)
    GREATEREQ       reduce using rule 36 (expr -> var .)
    LESSEQ          reduce using rule 36 (expr -> var .)
    NOTEQ           reduce using rule 36 (expr -> var .)
    EQEQ            reduce using rule 36 (expr -> var .)
    PIPE            reduce using rule 36 (expr -> var .)
    ?               reduce using rule 36 (expr -> var .)
    [               shift and go to state 72
    SHRASGN         shift and go to state 73
    SHLASGN         shift and go to state 74
    XORASGN         shift and go to state 75
    ORASGN          shift and go to state 76
    ANDASGN         shift and go to state 77
    MODULOASGN      shift and go to state 78
    SLASHASGN       shift and go to state 79
    STARASGN        shift and go to state 80
    MINUSASGN       shift and go to state 81
    PLUSASGN        shift and go to state 82
    ASSIGN          shift and go to state 83


state 9

    (8) statement -> var_define . SEP
    SEP             shift and go to state 84


state 10

    (9) statement -> class_definition .
    LET             reduce using rule 9 (statement -> class_definition .)
    {               reduce using rule 9 (statement -> class_definition .)
    NIL             reduce using rule 9 (statement -> class_definition .)
    FALSE           reduce using rule 9 (statement -> class_definition .)
    TRUE            reduce using rule 9 (statement -> class_definition .)
    STRING          reduce using rule 9 (statement -> class_definition .)
    FLOAT           reduce using rule 9 (statement -> class_definition .)
    INT             reduce using rule 9 (statement -> class_definition .)
    (               reduce using rule 9 (statement -> class_definition .)
    !               reduce using rule 9 (statement -> class_definition .)
    +               reduce using rule 9 (statement -> class_definition .)
    -               reduce using rule 9 (statement -> class_definition .)
    ~               reduce using rule 9 (statement -> class_definition .)
    ID              reduce using rule 9 (statement -> class_definition .)
    TYPEOF          reduce using rule 9 (statement -> class_definition .)
    LAMBDA          reduce using rule 9 (statement -> class_definition .)
    DEC             reduce using rule 9 (statement -> class_definition .)
    INC             reduce using rule 9 (statement -> class_definition .)
    CLASS           reduce using rule 9 (statement -> class_definition .)
    STRUCT          reduce using rule 9 (statement -> class_definition .)
    IF              reduce using rule 9 (statement -> class_definition .)
    FOR             reduce using rule 9 (statement -> class_definition .)
    WHILE           reduce using rule 9 (statement -> class_definition .)
    RETURN          reduce using rule 9 (statement -> class_definition .)
    FN              reduce using rule 9 (statement -> class_definition .)
    IMPORT          reduce using rule 9 (statement -> class_definition .)
    [               reduce using rule 9 (statement -> class_definition .)
    $end            reduce using rule 9 (statement -> class_definition .)
    }               reduce using rule 9 (statement -> class_definition .)
    ELSE            reduce using rule 9 (statement -> class_definition .)


state 11

    (10) statement -> struct_definition .
    LET             reduce using rule 10 (statement -> struct_definition .)
    {               reduce using rule 10 (statement -> struct_definition .)
    NIL             reduce using rule 10 (statement -> struct_definition .)
    FALSE           reduce using rule 10 (statement -> struct_definition .)
    TRUE            reduce using rule 10 (statement -> struct_definition .)
    STRING          reduce using rule 10 (statement -> struct_definition .)
    FLOAT           reduce using rule 10 (statement -> struct_definition .)
    INT             reduce using rule 10 (statement -> struct_definition .)
    (               reduce using rule 10 (statement -> struct_definition .)
    !               reduce using rule 10 (statement -> struct_definition .)
    +               reduce using rule 10 (statement -> struct_definition .)
    -               reduce using rule 10 (statement -> struct_definition .)
    ~               reduce using rule 10 (statement -> struct_definition .)
    ID              reduce using rule 10 (statement -> struct_definition .)
    TYPEOF          reduce using rule 10 (statement -> struct_definition .)
    LAMBDA          reduce using rule 10 (statement -> struct_definition .)
    DEC             reduce using rule 10 (statement -> struct_definition .)
    INC             reduce using rule 10 (statement -> struct_definition .)
    CLASS           reduce using rule 10 (statement -> struct_definition .)
    STRUCT          reduce using rule 10 (statement -> struct_definition .)
    IF              reduce using rule 10 (statement -> struct_definition .)
    FOR             reduce using rule 10 (statement -> struct_definition .)
    WHILE           reduce using rule 10 (statement -> struct_definition .)
    RETURN          reduce using rule 10 (statement -> struct_definition .)
    FN              reduce using rule 10 (statement -> struct_definition .)
    IMPORT          reduce using rule 10 (statement -> struct_definition .)
    [               reduce using rule 10 (statement -> struct_definition .)
    $end            reduce using rule 10 (statement -> struct_definition .)
    }               reduce using rule 10 (statement -> struct_definition .)
    ELSE            reduce using rule 10 (statement -> struct_definition .)


state 12

    (11) statement -> if_statement .
    LET             reduce using rule 11 (statement -> if_statement .)
    {               reduce using rule 11 (statement -> if_statement .)
    NIL             reduce using rule 11 (statement -> if_statement .)
    FALSE           reduce using rule 11 (statement -> if_statement .)
    TRUE            reduce using rule 11 (statement -> if_statement .)
    STRING          reduce using rule 11 (statement -> if_statement .)
    FLOAT           reduce using rule 11 (statement -> if_statement .)
    INT             reduce using rule 11 (statement -> if_statement .)
    (               reduce using rule 11 (statement -> if_statement .)
    !               reduce using rule 11 (statement -> if_statement .)
    +               reduce using rule 11 (statement -> if_statement .)
    -               reduce using rule 11 (statement -> if_statement .)
    ~               reduce using rule 11 (statement -> if_statement .)
    ID              reduce using rule 11 (statement -> if_statement .)
    TYPEOF          reduce using rule 11 (statement -> if_statement .)
    LAMBDA          reduce using rule 11 (statement -> if_statement .)
    DEC             reduce using rule 11 (statement -> if_statement .)
    INC             reduce using rule 11 (statement -> if_statement .)
    CLASS           reduce using rule 11 (statement -> if_statement .)
    STRUCT          reduce using rule 11 (statement -> if_statement .)
    IF              reduce using rule 11 (statement -> if_statement .)
    FOR             reduce using rule 11 (statement -> if_statement .)
    WHILE           reduce using rule 11 (statement -> if_statement .)
    RETURN          reduce using rule 11 (statement -> if_statement .)
    FN              reduce using rule 11 (statement -> if_statement .)
    IMPORT          reduce using rule 11 (statement -> if_statement .)
    [               reduce using rule 11 (statement -> if_statement .)
    $end            reduce using rule 11 (statement -> if_statement .)
    }               reduce using rule 11 (statement -> if_statement .)
    ELSE            reduce using rule 11 (statement -> if_statement .)


state 13

    (12) statement -> for_statement .
    LET             reduce using rule 12 (statement -> for_statement .)
    {               reduce using rule 12 (statement -> for_statement .)
    NIL             reduce using rule 12 (statement -> for_statement .)
    FALSE           reduce using rule 12 (statement -> for_statement .)
    TRUE            reduce using rule 12 (statement -> for_statement .)
    STRING          reduce using rule 12 (statement -> for_statement .)
    FLOAT           reduce using rule 12 (statement -> for_statement .)
    INT             reduce using rule 12 (statement -> for_statement .)
    (               reduce using rule 12 (statement -> for_statement .)
    !               reduce using rule 12 (statement -> for_statement .)
    +               reduce using rule 12 (statement -> for_statement .)
    -               reduce using rule 12 (statement -> for_statement .)
    ~               reduce using rule 12 (statement -> for_statement .)
    ID              reduce using rule 12 (statement -> for_statement .)
    TYPEOF          reduce using rule 12 (statement -> for_statement .)
    LAMBDA          reduce using rule 12 (statement -> for_statement .)
    DEC             reduce using rule 12 (statement -> for_statement .)
    INC             reduce using rule 12 (statement -> for_statement .)
    CLASS           reduce using rule 12 (statement -> for_statement .)
    STRUCT          reduce using rule 12 (statement -> for_statement .)
    IF              reduce using rule 12 (statement -> for_statement .)
    FOR             reduce using rule 12 (statement -> for_statement .)
    WHILE           reduce using rule 12 (statement -> for_statement .)
    RETURN          reduce using rule 12 (statement -> for_statement .)
    FN              reduce using rule 12 (statement -> for_statement .)
    IMPORT          reduce using rule 12 (statement -> for_statement .)
    [               reduce using rule 12 (statement -> for_statement .)
    $end            reduce using rule 12 (statement -> for_statement .)
    }               reduce using rule 12 (statement -> for_statement .)
    ELSE            reduce using rule 12 (statement -> for_statement .)


state 14

    (13) statement -> while_statement .
    LET             reduce using rule 13 (statement -> while_statement .)
    {               reduce using rule 13 (statement -> while_statement .)
    NIL             reduce using rule 13 (statement -> while_statement .)
    FALSE           reduce using rule 13 (statement -> while_statement .)
    TRUE            reduce using rule 13 (statement -> while_statement .)
    STRING          reduce using rule 13 (statement -> while_statement .)
    FLOAT           reduce using rule 13 (statement -> while_statement .)
    INT             reduce using rule 13 (statement -> while_statement .)
    (               reduce using rule 13 (statement -> while_statement .)
    !               reduce using rule 13 (statement -> while_statement .)
    +               reduce using rule 13 (statement -> while_statement .)
    -               reduce using rule 13 (statement -> while_statement .)
    ~               reduce using rule 13 (statement -> while_statement .)
    ID              reduce using rule 13 (statement -> while_statement .)
    TYPEOF          reduce using rule 13 (statement -> while_statement .)
    LAMBDA          reduce using rule 13 (statement -> while_statement .)
    DEC             reduce using rule 13 (statement -> while_statement .)
    INC             reduce using rule 13 (statement -> while_statement .)
    CLASS           reduce using rule 13 (statement -> while_statement .)
    STRUCT          reduce using rule 13 (statement -> while_statement .)
    IF              reduce using rule 13 (statement -> while_statement .)
    FOR             reduce using rule 13 (statement -> while_statement .)
    WHILE           reduce using rule 13 (statement -> while_statement .)
    RETURN          reduce using rule 13 (statement -> while_statement .)
    FN              reduce using rule 13 (statement -> while_statement .)
    IMPORT          reduce using rule 13 (statement -> while_statement .)
    [               reduce using rule 13 (statement -> while_statement .)
    $end            reduce using rule 13 (statement -> while_statement .)
    }               reduce using rule 13 (statement -> while_statement .)
    ELSE            reduce using rule 13 (statement -> while_statement .)


state 15

    (14) statement -> return_statement .
    LET             reduce using rule 14 (statement -> return_statement .)
    {               reduce using rule 14 (statement -> return_statement .)
    NIL             reduce using rule 14 (statement -> return_statement .)
    FALSE           reduce using rule 14 (statement -> return_statement .)
    TRUE            reduce using rule 14 (statement -> return_statement .)
    STRING          reduce using rule 14 (statement -> return_statement .)
    FLOAT           reduce using rule 14 (statement -> return_statement .)
    INT             reduce using rule 14 (statement -> return_statement .)
    (               reduce using rule 14 (statement -> return_statement .)
    !               reduce using rule 14 (statement -> return_statement .)
    +               reduce using rule 14 (statement -> return_statement .)
    -               reduce using rule 14 (statement -> return_statement .)
    ~               reduce using rule 14 (statement -> return_statement .)
    ID              reduce using rule 14 (statement -> return_statement .)
    TYPEOF          reduce using rule 14 (statement -> return_statement .)
    LAMBDA          reduce using rule 14 (statement -> return_statement .)
    DEC             reduce using rule 14 (statement -> return_statement .)
    INC             reduce using rule 14 (statement -> return_statement .)
    CLASS           reduce using rule 14 (statement -> return_statement .)
    STRUCT          reduce using rule 14 (statement -> return_statement .)
    IF              reduce using rule 14 (statement -> return_statement .)
    FOR             reduce using rule 14 (statement -> return_statement .)
    WHILE           reduce using rule 14 (statement -> return_statement .)
    RETURN          reduce using rule 14 (statement -> return_statement .)
    FN              reduce using rule 14 (statement -> return_statement .)
    IMPORT          reduce using rule 14 (statement -> return_statement .)
    [               reduce using rule 14 (statement -> return_statement .)
    $end            reduce using rule 14 (statement -> return_statement .)
    }               reduce using rule 14 (statement -> return_statement .)
    ELSE            reduce using rule 14 (statement -> return_statement .)


state 16

    (15) statement -> function_definition .
    LET             reduce using rule 15 (statement -> function_definition .)
    {               reduce using rule 15 (statement -> function_definition .)
    NIL             reduce using rule 15 (statement -> function_definition .)
    FALSE           reduce using rule 15 (statement -> function_definition .)
    TRUE            reduce using rule 15 (statement -> function_definition .)
    STRING          reduce using rule 15 (statement -> function_definition .)
    FLOAT           reduce using rule 15 (statement -> function_definition .)
    INT             reduce using rule 15 (statement -> function_definition .)
    (               reduce using rule 15 (statement -> function_definition .)
    !               reduce using rule 15 (statement -> function_definition .)
    +               reduce using rule 15 (statement -> function_definition .)
    -               reduce using rule 15 (statement -> function_definition .)
    ~               reduce using rule 15 (statement -> function_definition .)
    ID              reduce using rule 15 (statement -> function_definition .)
    TYPEOF          reduce using rule 15 (statement -> function_definition .)
    LAMBDA          reduce using rule 15 (statement -> function_definition .)
    DEC             reduce using rule 15 (statement -> function_definition .)
    INC             reduce using rule 15 (statement -> function_definition .)
    CLASS           reduce using rule 15 (statement -> function_definition .)
    STRUCT          reduce using rule 15 (statement -> function_definition .)
    IF              reduce using rule 15 (statement -> function_definition .)
    FOR             reduce using rule 15 (statement -> function_definition .)
    WHILE           reduce using rule 15 (statement -> function_definition .)
    RETURN          reduce using rule 15 (statement -> function_definition .)
    FN              reduce using rule 15 (statement -> function_definition .)
    IMPORT          reduce using rule 15 (statement -> function_definition .)
    [               reduce using rule 15 (statement -> function_definition .)
    $end            reduce using rule 15 (statement -> function_definition .)
    }               reduce using rule 15 (statement -> function_definition .)
    ELSE            reduce using rule 15 (statement -> function_definition .)


state 17

    (16) statement -> import_statement .
    LET             reduce using rule 16 (statement -> import_statement .)
    {               reduce using rule 16 (statement -> import_statement .)
    NIL             reduce using rule 16 (statement -> import_statement .)
    FALSE           reduce using rule 16 (statement -> import_statement .)
    TRUE            reduce using rule 16 (statement -> import_statement .)
    STRING          reduce using rule 16 (statement -> import_statement .)
    FLOAT           reduce using rule 16 (statement -> import_statement .)
    INT             reduce using rule 16 (statement -> import_statement .)
    (               reduce using rule 16 (statement -> import_statement .)
    !               reduce using rule 16 (statement -> import_statement .)
    +               reduce using rule 16 (statement -> import_statement .)
    -               reduce using rule 16 (statement -> import_statement .)
    ~               reduce using rule 16 (statement -> import_statement .)
    ID              reduce using rule 16 (statement -> import_statement .)
    TYPEOF          reduce using rule 16 (statement -> import_statement .)
    LAMBDA          reduce using rule 16 (statement -> import_statement .)
    DEC             reduce using rule 16 (statement -> import_statement .)
    INC             reduce using rule 16 (statement -> import_statement .)
    CLASS           reduce using rule 16 (statement -> import_statement .)
    STRUCT          reduce using rule 16 (statement -> import_statement .)
    IF              reduce using rule 16 (statement -> import_statement .)
    FOR             reduce using rule 16 (statement -> import_statement .)
    WHILE           reduce using rule 16 (statement -> import_statement .)
    RETURN          reduce using rule 16 (statement -> import_statement .)
    FN              reduce using rule 16 (statement -> import_statement .)
    IMPORT          reduce using rule 16 (statement -> import_statement .)
    [               reduce using rule 16 (statement -> import_statement .)
    $end            reduce using rule 16 (statement -> import_statement .)
    }               reduce using rule 16 (statement -> import_statement .)
    ELSE            reduce using rule 16 (statement -> import_statement .)


state 18

    (33) expr -> getter .
    (118) getter -> getter . . ID
    SEP             reduce using rule 33 (expr -> getter .)
    %               reduce using rule 33 (expr -> getter .)
    /               reduce using rule 33 (expr -> getter .)
    *               reduce using rule 33 (expr -> getter .)
    -               reduce using rule 33 (expr -> getter .)
    +               reduce using rule 33 (expr -> getter .)
    |               reduce using rule 33 (expr -> getter .)
    ^               reduce using rule 33 (expr -> getter .)
    &               reduce using rule 33 (expr -> getter .)
    SHR             reduce using rule 33 (expr -> getter .)
    SHL             reduce using rule 33 (expr -> getter .)
    GREATER         reduce using rule 33 (expr -> getter .)
    LESS            reduce using rule 33 (expr -> getter .)
    OR              reduce using rule 33 (expr -> getter .)
    AND             reduce using rule 33 (expr -> getter .)
    GREATEREQ       reduce using rule 33 (expr -> getter .)
    LESSEQ          reduce using rule 33 (expr -> getter .)
    NOTEQ           reduce using rule 33 (expr -> getter .)
    EQEQ            reduce using rule 33 (expr -> getter .)
    PIPE            reduce using rule 33 (expr -> getter .)
    ?               reduce using rule 33 (expr -> getter .)
    ]               reduce using rule 33 (expr -> getter .)
    ,               reduce using rule 33 (expr -> getter .)
    )               reduce using rule 33 (expr -> getter .)
    {               reduce using rule 33 (expr -> getter .)
    LET             reduce using rule 33 (expr -> getter .)
    NIL             reduce using rule 33 (expr -> getter .)
    FALSE           reduce using rule 33 (expr -> getter .)
    TRUE            reduce using rule 33 (expr -> getter .)
    STRING          reduce using rule 33 (expr -> getter .)
    FLOAT           reduce using rule 33 (expr -> getter .)
    INT             reduce using rule 33 (expr -> getter .)
    (               reduce using rule 33 (expr -> getter .)
    !               reduce using rule 33 (expr -> getter .)
    ~               reduce using rule 33 (expr -> getter .)
    ID              reduce using rule 33 (expr -> getter .)
    TYPEOF          reduce using rule 33 (expr -> getter .)
    LAMBDA          reduce using rule 33 (expr -> getter .)
    DEC             reduce using rule 33 (expr -> getter .)
    INC             reduce using rule 33 (expr -> getter .)
    CLASS           reduce using rule 33 (expr -> getter .)
    STRUCT          reduce using rule 33 (expr -> getter .)
    IF              reduce using rule 33 (expr -> getter .)
    FOR             reduce using rule 33 (expr -> getter .)
    WHILE           reduce using rule 33 (expr -> getter .)
    RETURN          reduce using rule 33 (expr -> getter .)
    FN              reduce using rule 33 (expr -> getter .)
    IMPORT          reduce using rule 33 (expr -> getter .)
    [               reduce using rule 33 (expr -> getter .)
    :               reduce using rule 33 (expr -> getter .)
    }               reduce using rule 33 (expr -> getter .)
    .               shift and go to state 85


state 19

    (34) expr -> { . member_list }
    (113) member_list -> . member_list , member
    (114) member_list -> . member
    (115) member_list -> . empty
    (116) member -> . STRING : expr
    (102) empty -> .
    STRING          shift and go to state 89
    }               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)

    member_list                    shift and go to state 86
    member                         shift and go to state 87
    empty                          shift and go to state 88

state 20

    (35) expr -> NIL .
    SEP             reduce using rule 35 (expr -> NIL .)
    %               reduce using rule 35 (expr -> NIL .)
    /               reduce using rule 35 (expr -> NIL .)
    *               reduce using rule 35 (expr -> NIL .)
    -               reduce using rule 35 (expr -> NIL .)
    +               reduce using rule 35 (expr -> NIL .)
    |               reduce using rule 35 (expr -> NIL .)
    ^               reduce using rule 35 (expr -> NIL .)
    &               reduce using rule 35 (expr -> NIL .)
    SHR             reduce using rule 35 (expr -> NIL .)
    SHL             reduce using rule 35 (expr -> NIL .)
    GREATER         reduce using rule 35 (expr -> NIL .)
    LESS            reduce using rule 35 (expr -> NIL .)
    OR              reduce using rule 35 (expr -> NIL .)
    AND             reduce using rule 35 (expr -> NIL .)
    GREATEREQ       reduce using rule 35 (expr -> NIL .)
    LESSEQ          reduce using rule 35 (expr -> NIL .)
    NOTEQ           reduce using rule 35 (expr -> NIL .)
    EQEQ            reduce using rule 35 (expr -> NIL .)
    PIPE            reduce using rule 35 (expr -> NIL .)
    ?               reduce using rule 35 (expr -> NIL .)
    ]               reduce using rule 35 (expr -> NIL .)
    ,               reduce using rule 35 (expr -> NIL .)
    )               reduce using rule 35 (expr -> NIL .)
    {               reduce using rule 35 (expr -> NIL .)
    LET             reduce using rule 35 (expr -> NIL .)
    NIL             reduce using rule 35 (expr -> NIL .)
    FALSE           reduce using rule 35 (expr -> NIL .)
    TRUE            reduce using rule 35 (expr -> NIL .)
    STRING          reduce using rule 35 (expr -> NIL .)
    FLOAT           reduce using rule 35 (expr -> NIL .)
    INT             reduce using rule 35 (expr -> NIL .)
    (               reduce using rule 35 (expr -> NIL .)
    !               reduce using rule 35 (expr -> NIL .)
    ~               reduce using rule 35 (expr -> NIL .)
    ID              reduce using rule 35 (expr -> NIL .)
    TYPEOF          reduce using rule 35 (expr -> NIL .)
    LAMBDA          reduce using rule 35 (expr -> NIL .)
    DEC             reduce using rule 35 (expr -> NIL .)
    INC             reduce using rule 35 (expr -> NIL .)
    CLASS           reduce using rule 35 (expr -> NIL .)
    STRUCT          reduce using rule 35 (expr -> NIL .)
    IF              reduce using rule 35 (expr -> NIL .)
    FOR             reduce using rule 35 (expr -> NIL .)
    WHILE           reduce using rule 35 (expr -> NIL .)
    RETURN          reduce using rule 35 (expr -> NIL .)
    FN              reduce using rule 35 (expr -> NIL .)
    IMPORT          reduce using rule 35 (expr -> NIL .)
    [               reduce using rule 35 (expr -> NIL .)
    :               reduce using rule 35 (expr -> NIL .)
    }               reduce using rule 35 (expr -> NIL .)


state 21

    (96) list_val -> [ . exprs ]
    (97) exprs -> . exprs , expr
    (98) exprs -> . expr
    (99) exprs -> . empty
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (102) empty -> .
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    ]               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    [               shift and go to state 21

    exprs                          shift and go to state 90
    expr                           shift and go to state 91
    empty                          shift and go to state 92
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 22

    (38) expr -> list_val .
    SEP             reduce using rule 38 (expr -> list_val .)
    %               reduce using rule 38 (expr -> list_val .)
    /               reduce using rule 38 (expr -> list_val .)
    *               reduce using rule 38 (expr -> list_val .)
    -               reduce using rule 38 (expr -> list_val .)
    +               reduce using rule 38 (expr -> list_val .)
    |               reduce using rule 38 (expr -> list_val .)
    ^               reduce using rule 38 (expr -> list_val .)
    &               reduce using rule 38 (expr -> list_val .)
    SHR             reduce using rule 38 (expr -> list_val .)
    SHL             reduce using rule 38 (expr -> list_val .)
    GREATER         reduce using rule 38 (expr -> list_val .)
    LESS            reduce using rule 38 (expr -> list_val .)
    OR              reduce using rule 38 (expr -> list_val .)
    AND             reduce using rule 38 (expr -> list_val .)
    GREATEREQ       reduce using rule 38 (expr -> list_val .)
    LESSEQ          reduce using rule 38 (expr -> list_val .)
    NOTEQ           reduce using rule 38 (expr -> list_val .)
    EQEQ            reduce using rule 38 (expr -> list_val .)
    PIPE            reduce using rule 38 (expr -> list_val .)
    ?               reduce using rule 38 (expr -> list_val .)
    ]               reduce using rule 38 (expr -> list_val .)
    ,               reduce using rule 38 (expr -> list_val .)
    )               reduce using rule 38 (expr -> list_val .)
    {               reduce using rule 38 (expr -> list_val .)
    LET             reduce using rule 38 (expr -> list_val .)
    NIL             reduce using rule 38 (expr -> list_val .)
    FALSE           reduce using rule 38 (expr -> list_val .)
    TRUE            reduce using rule 38 (expr -> list_val .)
    STRING          reduce using rule 38 (expr -> list_val .)
    FLOAT           reduce using rule 38 (expr -> list_val .)
    INT             reduce using rule 38 (expr -> list_val .)
    (               reduce using rule 38 (expr -> list_val .)
    !               reduce using rule 38 (expr -> list_val .)
    ~               reduce using rule 38 (expr -> list_val .)
    ID              reduce using rule 38 (expr -> list_val .)
    TYPEOF          reduce using rule 38 (expr -> list_val .)
    LAMBDA          reduce using rule 38 (expr -> list_val .)
    DEC             reduce using rule 38 (expr -> list_val .)
    INC             reduce using rule 38 (expr -> list_val .)
    CLASS           reduce using rule 38 (expr -> list_val .)
    STRUCT          reduce using rule 38 (expr -> list_val .)
    IF              reduce using rule 38 (expr -> list_val .)
    FOR             reduce using rule 38 (expr -> list_val .)
    WHILE           reduce using rule 38 (expr -> list_val .)
    RETURN          reduce using rule 38 (expr -> list_val .)
    FN              reduce using rule 38 (expr -> list_val .)
    IMPORT          reduce using rule 38 (expr -> list_val .)
    [               reduce using rule 38 (expr -> list_val .)
    :               reduce using rule 38 (expr -> list_val .)
    }               reduce using rule 38 (expr -> list_val .)


state 23

    (39) expr -> FALSE .
    SEP             reduce using rule 39 (expr -> FALSE .)
    %               reduce using rule 39 (expr -> FALSE .)
    /               reduce using rule 39 (expr -> FALSE .)
    *               reduce using rule 39 (expr -> FALSE .)
    -               reduce using rule 39 (expr -> FALSE .)
    +               reduce using rule 39 (expr -> FALSE .)
    |               reduce using rule 39 (expr -> FALSE .)
    ^               reduce using rule 39 (expr -> FALSE .)
    &               reduce using rule 39 (expr -> FALSE .)
    SHR             reduce using rule 39 (expr -> FALSE .)
    SHL             reduce using rule 39 (expr -> FALSE .)
    GREATER         reduce using rule 39 (expr -> FALSE .)
    LESS            reduce using rule 39 (expr -> FALSE .)
    OR              reduce using rule 39 (expr -> FALSE .)
    AND             reduce using rule 39 (expr -> FALSE .)
    GREATEREQ       reduce using rule 39 (expr -> FALSE .)
    LESSEQ          reduce using rule 39 (expr -> FALSE .)
    NOTEQ           reduce using rule 39 (expr -> FALSE .)
    EQEQ            reduce using rule 39 (expr -> FALSE .)
    PIPE            reduce using rule 39 (expr -> FALSE .)
    ?               reduce using rule 39 (expr -> FALSE .)
    ]               reduce using rule 39 (expr -> FALSE .)
    ,               reduce using rule 39 (expr -> FALSE .)
    )               reduce using rule 39 (expr -> FALSE .)
    {               reduce using rule 39 (expr -> FALSE .)
    LET             reduce using rule 39 (expr -> FALSE .)
    NIL             reduce using rule 39 (expr -> FALSE .)
    FALSE           reduce using rule 39 (expr -> FALSE .)
    TRUE            reduce using rule 39 (expr -> FALSE .)
    STRING          reduce using rule 39 (expr -> FALSE .)
    FLOAT           reduce using rule 39 (expr -> FALSE .)
    INT             reduce using rule 39 (expr -> FALSE .)
    (               reduce using rule 39 (expr -> FALSE .)
    !               reduce using rule 39 (expr -> FALSE .)
    ~               reduce using rule 39 (expr -> FALSE .)
    ID              reduce using rule 39 (expr -> FALSE .)
    TYPEOF          reduce using rule 39 (expr -> FALSE .)
    LAMBDA          reduce using rule 39 (expr -> FALSE .)
    DEC             reduce using rule 39 (expr -> FALSE .)
    INC             reduce using rule 39 (expr -> FALSE .)
    CLASS           reduce using rule 39 (expr -> FALSE .)
    STRUCT          reduce using rule 39 (expr -> FALSE .)
    IF              reduce using rule 39 (expr -> FALSE .)
    FOR             reduce using rule 39 (expr -> FALSE .)
    WHILE           reduce using rule 39 (expr -> FALSE .)
    RETURN          reduce using rule 39 (expr -> FALSE .)
    FN              reduce using rule 39 (expr -> FALSE .)
    IMPORT          reduce using rule 39 (expr -> FALSE .)
    [               reduce using rule 39 (expr -> FALSE .)
    :               reduce using rule 39 (expr -> FALSE .)
    }               reduce using rule 39 (expr -> FALSE .)


state 24

    (40) expr -> TRUE .
    SEP             reduce using rule 40 (expr -> TRUE .)
    %               reduce using rule 40 (expr -> TRUE .)
    /               reduce using rule 40 (expr -> TRUE .)
    *               reduce using rule 40 (expr -> TRUE .)
    -               reduce using rule 40 (expr -> TRUE .)
    +               reduce using rule 40 (expr -> TRUE .)
    |               reduce using rule 40 (expr -> TRUE .)
    ^               reduce using rule 40 (expr -> TRUE .)
    &               reduce using rule 40 (expr -> TRUE .)
    SHR             reduce using rule 40 (expr -> TRUE .)
    SHL             reduce using rule 40 (expr -> TRUE .)
    GREATER         reduce using rule 40 (expr -> TRUE .)
    LESS            reduce using rule 40 (expr -> TRUE .)
    OR              reduce using rule 40 (expr -> TRUE .)
    AND             reduce using rule 40 (expr -> TRUE .)
    GREATEREQ       reduce using rule 40 (expr -> TRUE .)
    LESSEQ          reduce using rule 40 (expr -> TRUE .)
    NOTEQ           reduce using rule 40 (expr -> TRUE .)
    EQEQ            reduce using rule 40 (expr -> TRUE .)
    PIPE            reduce using rule 40 (expr -> TRUE .)
    ?               reduce using rule 40 (expr -> TRUE .)
    ]               reduce using rule 40 (expr -> TRUE .)
    ,               reduce using rule 40 (expr -> TRUE .)
    )               reduce using rule 40 (expr -> TRUE .)
    {               reduce using rule 40 (expr -> TRUE .)
    LET             reduce using rule 40 (expr -> TRUE .)
    NIL             reduce using rule 40 (expr -> TRUE .)
    FALSE           reduce using rule 40 (expr -> TRUE .)
    TRUE            reduce using rule 40 (expr -> TRUE .)
    STRING          reduce using rule 40 (expr -> TRUE .)
    FLOAT           reduce using rule 40 (expr -> TRUE .)
    INT             reduce using rule 40 (expr -> TRUE .)
    (               reduce using rule 40 (expr -> TRUE .)
    !               reduce using rule 40 (expr -> TRUE .)
    ~               reduce using rule 40 (expr -> TRUE .)
    ID              reduce using rule 40 (expr -> TRUE .)
    TYPEOF          reduce using rule 40 (expr -> TRUE .)
    LAMBDA          reduce using rule 40 (expr -> TRUE .)
    DEC             reduce using rule 40 (expr -> TRUE .)
    INC             reduce using rule 40 (expr -> TRUE .)
    CLASS           reduce using rule 40 (expr -> TRUE .)
    STRUCT          reduce using rule 40 (expr -> TRUE .)
    IF              reduce using rule 40 (expr -> TRUE .)
    FOR             reduce using rule 40 (expr -> TRUE .)
    WHILE           reduce using rule 40 (expr -> TRUE .)
    RETURN          reduce using rule 40 (expr -> TRUE .)
    FN              reduce using rule 40 (expr -> TRUE .)
    IMPORT          reduce using rule 40 (expr -> TRUE .)
    [               reduce using rule 40 (expr -> TRUE .)
    :               reduce using rule 40 (expr -> TRUE .)
    }               reduce using rule 40 (expr -> TRUE .)


state 25

    (41) expr -> STRING .
    SEP             reduce using rule 41 (expr -> STRING .)
    %               reduce using rule 41 (expr -> STRING .)
    /               reduce using rule 41 (expr -> STRING .)
    *               reduce using rule 41 (expr -> STRING .)
    -               reduce using rule 41 (expr -> STRING .)
    +               reduce using rule 41 (expr -> STRING .)
    |               reduce using rule 41 (expr -> STRING .)
    ^               reduce using rule 41 (expr -> STRING .)
    &               reduce using rule 41 (expr -> STRING .)
    SHR             reduce using rule 41 (expr -> STRING .)
    SHL             reduce using rule 41 (expr -> STRING .)
    GREATER         reduce using rule 41 (expr -> STRING .)
    LESS            reduce using rule 41 (expr -> STRING .)
    OR              reduce using rule 41 (expr -> STRING .)
    AND             reduce using rule 41 (expr -> STRING .)
    GREATEREQ       reduce using rule 41 (expr -> STRING .)
    LESSEQ          reduce using rule 41 (expr -> STRING .)
    NOTEQ           reduce using rule 41 (expr -> STRING .)
    EQEQ            reduce using rule 41 (expr -> STRING .)
    PIPE            reduce using rule 41 (expr -> STRING .)
    ?               reduce using rule 41 (expr -> STRING .)
    ]               reduce using rule 41 (expr -> STRING .)
    ,               reduce using rule 41 (expr -> STRING .)
    )               reduce using rule 41 (expr -> STRING .)
    {               reduce using rule 41 (expr -> STRING .)
    LET             reduce using rule 41 (expr -> STRING .)
    NIL             reduce using rule 41 (expr -> STRING .)
    FALSE           reduce using rule 41 (expr -> STRING .)
    TRUE            reduce using rule 41 (expr -> STRING .)
    STRING          reduce using rule 41 (expr -> STRING .)
    FLOAT           reduce using rule 41 (expr -> STRING .)
    INT             reduce using rule 41 (expr -> STRING .)
    (               reduce using rule 41 (expr -> STRING .)
    !               reduce using rule 41 (expr -> STRING .)
    ~               reduce using rule 41 (expr -> STRING .)
    ID              reduce using rule 41 (expr -> STRING .)
    TYPEOF          reduce using rule 41 (expr -> STRING .)
    LAMBDA          reduce using rule 41 (expr -> STRING .)
    DEC             reduce using rule 41 (expr -> STRING .)
    INC             reduce using rule 41 (expr -> STRING .)
    CLASS           reduce using rule 41 (expr -> STRING .)
    STRUCT          reduce using rule 41 (expr -> STRING .)
    IF              reduce using rule 41 (expr -> STRING .)
    FOR             reduce using rule 41 (expr -> STRING .)
    WHILE           reduce using rule 41 (expr -> STRING .)
    RETURN          reduce using rule 41 (expr -> STRING .)
    FN              reduce using rule 41 (expr -> STRING .)
    IMPORT          reduce using rule 41 (expr -> STRING .)
    [               reduce using rule 41 (expr -> STRING .)
    :               reduce using rule 41 (expr -> STRING .)
    }               reduce using rule 41 (expr -> STRING .)


state 26

    (42) expr -> FLOAT .
    SEP             reduce using rule 42 (expr -> FLOAT .)
    %               reduce using rule 42 (expr -> FLOAT .)
    /               reduce using rule 42 (expr -> FLOAT .)
    *               reduce using rule 42 (expr -> FLOAT .)
    -               reduce using rule 42 (expr -> FLOAT .)
    +               reduce using rule 42 (expr -> FLOAT .)
    |               reduce using rule 42 (expr -> FLOAT .)
    ^               reduce using rule 42 (expr -> FLOAT .)
    &               reduce using rule 42 (expr -> FLOAT .)
    SHR             reduce using rule 42 (expr -> FLOAT .)
    SHL             reduce using rule 42 (expr -> FLOAT .)
    GREATER         reduce using rule 42 (expr -> FLOAT .)
    LESS            reduce using rule 42 (expr -> FLOAT .)
    OR              reduce using rule 42 (expr -> FLOAT .)
    AND             reduce using rule 42 (expr -> FLOAT .)
    GREATEREQ       reduce using rule 42 (expr -> FLOAT .)
    LESSEQ          reduce using rule 42 (expr -> FLOAT .)
    NOTEQ           reduce using rule 42 (expr -> FLOAT .)
    EQEQ            reduce using rule 42 (expr -> FLOAT .)
    PIPE            reduce using rule 42 (expr -> FLOAT .)
    ?               reduce using rule 42 (expr -> FLOAT .)
    ]               reduce using rule 42 (expr -> FLOAT .)
    ,               reduce using rule 42 (expr -> FLOAT .)
    )               reduce using rule 42 (expr -> FLOAT .)
    {               reduce using rule 42 (expr -> FLOAT .)
    LET             reduce using rule 42 (expr -> FLOAT .)
    NIL             reduce using rule 42 (expr -> FLOAT .)
    FALSE           reduce using rule 42 (expr -> FLOAT .)
    TRUE            reduce using rule 42 (expr -> FLOAT .)
    STRING          reduce using rule 42 (expr -> FLOAT .)
    FLOAT           reduce using rule 42 (expr -> FLOAT .)
    INT             reduce using rule 42 (expr -> FLOAT .)
    (               reduce using rule 42 (expr -> FLOAT .)
    !               reduce using rule 42 (expr -> FLOAT .)
    ~               reduce using rule 42 (expr -> FLOAT .)
    ID              reduce using rule 42 (expr -> FLOAT .)
    TYPEOF          reduce using rule 42 (expr -> FLOAT .)
    LAMBDA          reduce using rule 42 (expr -> FLOAT .)
    DEC             reduce using rule 42 (expr -> FLOAT .)
    INC             reduce using rule 42 (expr -> FLOAT .)
    CLASS           reduce using rule 42 (expr -> FLOAT .)
    STRUCT          reduce using rule 42 (expr -> FLOAT .)
    IF              reduce using rule 42 (expr -> FLOAT .)
    FOR             reduce using rule 42 (expr -> FLOAT .)
    WHILE           reduce using rule 42 (expr -> FLOAT .)
    RETURN          reduce using rule 42 (expr -> FLOAT .)
    FN              reduce using rule 42 (expr -> FLOAT .)
    IMPORT          reduce using rule 42 (expr -> FLOAT .)
    [               reduce using rule 42 (expr -> FLOAT .)
    :               reduce using rule 42 (expr -> FLOAT .)
    }               reduce using rule 42 (expr -> FLOAT .)


state 27

    (43) expr -> INT .
    SEP             reduce using rule 43 (expr -> INT .)
    %               reduce using rule 43 (expr -> INT .)
    /               reduce using rule 43 (expr -> INT .)
    *               reduce using rule 43 (expr -> INT .)
    -               reduce using rule 43 (expr -> INT .)
    +               reduce using rule 43 (expr -> INT .)
    |               reduce using rule 43 (expr -> INT .)
    ^               reduce using rule 43 (expr -> INT .)
    &               reduce using rule 43 (expr -> INT .)
    SHR             reduce using rule 43 (expr -> INT .)
    SHL             reduce using rule 43 (expr -> INT .)
    GREATER         reduce using rule 43 (expr -> INT .)
    LESS            reduce using rule 43 (expr -> INT .)
    OR              reduce using rule 43 (expr -> INT .)
    AND             reduce using rule 43 (expr -> INT .)
    GREATEREQ       reduce using rule 43 (expr -> INT .)
    LESSEQ          reduce using rule 43 (expr -> INT .)
    NOTEQ           reduce using rule 43 (expr -> INT .)
    EQEQ            reduce using rule 43 (expr -> INT .)
    PIPE            reduce using rule 43 (expr -> INT .)
    ?               reduce using rule 43 (expr -> INT .)
    ]               reduce using rule 43 (expr -> INT .)
    ,               reduce using rule 43 (expr -> INT .)
    )               reduce using rule 43 (expr -> INT .)
    {               reduce using rule 43 (expr -> INT .)
    LET             reduce using rule 43 (expr -> INT .)
    NIL             reduce using rule 43 (expr -> INT .)
    FALSE           reduce using rule 43 (expr -> INT .)
    TRUE            reduce using rule 43 (expr -> INT .)
    STRING          reduce using rule 43 (expr -> INT .)
    FLOAT           reduce using rule 43 (expr -> INT .)
    INT             reduce using rule 43 (expr -> INT .)
    (               reduce using rule 43 (expr -> INT .)
    !               reduce using rule 43 (expr -> INT .)
    ~               reduce using rule 43 (expr -> INT .)
    ID              reduce using rule 43 (expr -> INT .)
    TYPEOF          reduce using rule 43 (expr -> INT .)
    LAMBDA          reduce using rule 43 (expr -> INT .)
    DEC             reduce using rule 43 (expr -> INT .)
    INC             reduce using rule 43 (expr -> INT .)
    CLASS           reduce using rule 43 (expr -> INT .)
    STRUCT          reduce using rule 43 (expr -> INT .)
    IF              reduce using rule 43 (expr -> INT .)
    FOR             reduce using rule 43 (expr -> INT .)
    WHILE           reduce using rule 43 (expr -> INT .)
    RETURN          reduce using rule 43 (expr -> INT .)
    FN              reduce using rule 43 (expr -> INT .)
    IMPORT          reduce using rule 43 (expr -> INT .)
    [               reduce using rule 43 (expr -> INT .)
    :               reduce using rule 43 (expr -> INT .)
    }               reduce using rule 43 (expr -> INT .)


state 28

    (44) expr -> ( . expr )
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 94
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 29

    (52) expr -> - . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 95
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 30

    (51) expr -> + . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 96
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 31

    (50) expr -> ! . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 97
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 32

    (53) expr -> ~ . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 98
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 33

    (68) expr -> ID . DOUBLECOLON ID ( args )
    (69) expr -> ID . ( args )
    (73) expr -> ID . LEFTARROW { struct_init_exprs }
    (117) getter -> ID .
    (101) var -> ID .
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for [ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for SEP resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for % resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for / resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for * resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for - resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for + resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for | resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for & resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for SHR resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for SHL resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for EQEQ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for PIPE resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for ? resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for ] resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for , resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for { resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for LET resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for NIL resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 101 (var -> ID .)
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for ! resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for ~ resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for TYPEOF resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for LAMBDA resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for DEC resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for INC resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for CLASS resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for STRUCT resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for FN resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for IMPORT resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for : resolved using rule 101 (var -> ID .)
  ! reduce/reduce conflict for } resolved using rule 101 (var -> ID .)
    DOUBLECOLON     shift and go to state 99
    (               shift and go to state 100
    LEFTARROW       shift and go to state 101
    .               reduce using rule 117 (getter -> ID .)
    [               reduce using rule 101 (var -> ID .)
    SHRASGN         reduce using rule 101 (var -> ID .)
    SHLASGN         reduce using rule 101 (var -> ID .)
    XORASGN         reduce using rule 101 (var -> ID .)
    ORASGN          reduce using rule 101 (var -> ID .)
    ANDASGN         reduce using rule 101 (var -> ID .)
    MODULOASGN      reduce using rule 101 (var -> ID .)
    SLASHASGN       reduce using rule 101 (var -> ID .)
    STARASGN        reduce using rule 101 (var -> ID .)
    MINUSASGN       reduce using rule 101 (var -> ID .)
    PLUSASGN        reduce using rule 101 (var -> ID .)
    ASSIGN          reduce using rule 101 (var -> ID .)
    SEP             reduce using rule 101 (var -> ID .)
    %               reduce using rule 101 (var -> ID .)
    /               reduce using rule 101 (var -> ID .)
    *               reduce using rule 101 (var -> ID .)
    -               reduce using rule 101 (var -> ID .)
    +               reduce using rule 101 (var -> ID .)
    |               reduce using rule 101 (var -> ID .)
    ^               reduce using rule 101 (var -> ID .)
    &               reduce using rule 101 (var -> ID .)
    SHR             reduce using rule 101 (var -> ID .)
    SHL             reduce using rule 101 (var -> ID .)
    GREATER         reduce using rule 101 (var -> ID .)
    LESS            reduce using rule 101 (var -> ID .)
    OR              reduce using rule 101 (var -> ID .)
    AND             reduce using rule 101 (var -> ID .)
    GREATEREQ       reduce using rule 101 (var -> ID .)
    LESSEQ          reduce using rule 101 (var -> ID .)
    NOTEQ           reduce using rule 101 (var -> ID .)
    EQEQ            reduce using rule 101 (var -> ID .)
    PIPE            reduce using rule 101 (var -> ID .)
    ?               reduce using rule 101 (var -> ID .)
    ]               reduce using rule 101 (var -> ID .)
    ,               reduce using rule 101 (var -> ID .)
    )               reduce using rule 101 (var -> ID .)
    {               reduce using rule 101 (var -> ID .)
    LET             reduce using rule 101 (var -> ID .)
    NIL             reduce using rule 101 (var -> ID .)
    FALSE           reduce using rule 101 (var -> ID .)
    TRUE            reduce using rule 101 (var -> ID .)
    STRING          reduce using rule 101 (var -> ID .)
    FLOAT           reduce using rule 101 (var -> ID .)
    INT             reduce using rule 101 (var -> ID .)
    !               reduce using rule 101 (var -> ID .)
    ~               reduce using rule 101 (var -> ID .)
    ID              reduce using rule 101 (var -> ID .)
    TYPEOF          reduce using rule 101 (var -> ID .)
    LAMBDA          reduce using rule 101 (var -> ID .)
    DEC             reduce using rule 101 (var -> ID .)
    INC             reduce using rule 101 (var -> ID .)
    CLASS           reduce using rule 101 (var -> ID .)
    STRUCT          reduce using rule 101 (var -> ID .)
    IF              reduce using rule 101 (var -> ID .)
    FOR             reduce using rule 101 (var -> ID .)
    WHILE           reduce using rule 101 (var -> ID .)
    RETURN          reduce using rule 101 (var -> ID .)
    FN              reduce using rule 101 (var -> ID .)
    IMPORT          reduce using rule 101 (var -> ID .)
    :               reduce using rule 101 (var -> ID .)
    }               reduce using rule 101 (var -> ID .)


state 34

    (71) expr -> TYPEOF . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 102
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 35

    (72) expr -> LAMBDA . ( params ) ARROW expr
    (               shift and go to state 103


state 36

    (79) var_assign -> DEC . var
    (100) var -> . var [ expr ]
    (101) var -> . ID
    ID              shift and go to state 105

    var                            shift and go to state 104

state 37

    (80) var_assign -> INC . var
    (100) var -> . var [ expr ]
    (101) var -> . ID
    ID              shift and go to state 105

    var                            shift and go to state 106

state 38

    (17) class_definition -> CLASS . ID { function_definitions }
    ID              shift and go to state 107


state 39

    (21) struct_definition -> STRUCT . ID { struct_fields } SEP
    ID              shift and go to state 108


state 40

    (92) if_statement -> IF . expr block
    (93) if_statement -> IF . expr block ELSE block
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 109
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 41

    (95) for_statement -> FOR . var_assign SEP expr SEP var_assign block
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (100) var -> . var [ expr ]
    (101) var -> . ID
    DEC             shift and go to state 36
    INC             shift and go to state 37
    ID              shift and go to state 105

    var_assign                     shift and go to state 110
    var                            shift and go to state 111

state 42

    (94) while_statement -> WHILE . expr block
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 112
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 43

    (78) return_statement -> RETURN . expr SEP
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 113
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 44

    (32) function_definition -> FN . ID ( params ) block
    ID              shift and go to state 114


state 45

    (31) import_statement -> IMPORT . STRING SEP
    STRING          shift and go to state 115


state 46

    (3) statements -> statements statement .
    LET             reduce using rule 3 (statements -> statements statement .)
    {               reduce using rule 3 (statements -> statements statement .)
    NIL             reduce using rule 3 (statements -> statements statement .)
    FALSE           reduce using rule 3 (statements -> statements statement .)
    TRUE            reduce using rule 3 (statements -> statements statement .)
    STRING          reduce using rule 3 (statements -> statements statement .)
    FLOAT           reduce using rule 3 (statements -> statements statement .)
    INT             reduce using rule 3 (statements -> statements statement .)
    (               reduce using rule 3 (statements -> statements statement .)
    !               reduce using rule 3 (statements -> statements statement .)
    +               reduce using rule 3 (statements -> statements statement .)
    -               reduce using rule 3 (statements -> statements statement .)
    ~               reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    TYPEOF          reduce using rule 3 (statements -> statements statement .)
    LAMBDA          reduce using rule 3 (statements -> statements statement .)
    DEC             reduce using rule 3 (statements -> statements statement .)
    INC             reduce using rule 3 (statements -> statements statement .)
    CLASS           reduce using rule 3 (statements -> statements statement .)
    STRUCT          reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    FN              reduce using rule 3 (statements -> statements statement .)
    IMPORT          reduce using rule 3 (statements -> statements statement .)
    [               reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 47

    (5) statement -> expr SEP .
    LET             reduce using rule 5 (statement -> expr SEP .)
    {               reduce using rule 5 (statement -> expr SEP .)
    NIL             reduce using rule 5 (statement -> expr SEP .)
    FALSE           reduce using rule 5 (statement -> expr SEP .)
    TRUE            reduce using rule 5 (statement -> expr SEP .)
    STRING          reduce using rule 5 (statement -> expr SEP .)
    FLOAT           reduce using rule 5 (statement -> expr SEP .)
    INT             reduce using rule 5 (statement -> expr SEP .)
    (               reduce using rule 5 (statement -> expr SEP .)
    !               reduce using rule 5 (statement -> expr SEP .)
    +               reduce using rule 5 (statement -> expr SEP .)
    -               reduce using rule 5 (statement -> expr SEP .)
    ~               reduce using rule 5 (statement -> expr SEP .)
    ID              reduce using rule 5 (statement -> expr SEP .)
    TYPEOF          reduce using rule 5 (statement -> expr SEP .)
    LAMBDA          reduce using rule 5 (statement -> expr SEP .)
    DEC             reduce using rule 5 (statement -> expr SEP .)
    INC             reduce using rule 5 (statement -> expr SEP .)
    CLASS           reduce using rule 5 (statement -> expr SEP .)
    STRUCT          reduce using rule 5 (statement -> expr SEP .)
    IF              reduce using rule 5 (statement -> expr SEP .)
    FOR             reduce using rule 5 (statement -> expr SEP .)
    WHILE           reduce using rule 5 (statement -> expr SEP .)
    RETURN          reduce using rule 5 (statement -> expr SEP .)
    FN              reduce using rule 5 (statement -> expr SEP .)
    IMPORT          reduce using rule 5 (statement -> expr SEP .)
    [               reduce using rule 5 (statement -> expr SEP .)
    $end            reduce using rule 5 (statement -> expr SEP .)
    }               reduce using rule 5 (statement -> expr SEP .)
    ELSE            reduce using rule 5 (statement -> expr SEP .)


state 48

    (45) expr -> expr % . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 116
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 49

    (46) expr -> expr / . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 117
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 50

    (47) expr -> expr * . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 118
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 51

    (48) expr -> expr - . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 119
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 52

    (49) expr -> expr + . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 120
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 53

    (54) expr -> expr | . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 121
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 54

    (55) expr -> expr ^ . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 122
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 55

    (56) expr -> expr & . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 123
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 56

    (57) expr -> expr SHR . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 124
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 57

    (58) expr -> expr SHL . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 125
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 58

    (59) expr -> expr GREATER . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 126
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 59

    (60) expr -> expr LESS . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 127
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 60

    (61) expr -> expr OR . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 128
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 61

    (62) expr -> expr AND . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 129
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 62

    (63) expr -> expr GREATEREQ . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 130
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 63

    (64) expr -> expr LESSEQ . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 131
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 64

    (65) expr -> expr NOTEQ . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 132
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 65

    (66) expr -> expr EQEQ . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 133
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 66

    (67) expr -> expr PIPE . ID ( args )
    ID              shift and go to state 134


state 67

    (70) expr -> expr ? . expr : expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 135
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 68

    (6) statement -> var_assign SEP .
    LET             reduce using rule 6 (statement -> var_assign SEP .)
    {               reduce using rule 6 (statement -> var_assign SEP .)
    NIL             reduce using rule 6 (statement -> var_assign SEP .)
    FALSE           reduce using rule 6 (statement -> var_assign SEP .)
    TRUE            reduce using rule 6 (statement -> var_assign SEP .)
    STRING          reduce using rule 6 (statement -> var_assign SEP .)
    FLOAT           reduce using rule 6 (statement -> var_assign SEP .)
    INT             reduce using rule 6 (statement -> var_assign SEP .)
    (               reduce using rule 6 (statement -> var_assign SEP .)
    !               reduce using rule 6 (statement -> var_assign SEP .)
    +               reduce using rule 6 (statement -> var_assign SEP .)
    -               reduce using rule 6 (statement -> var_assign SEP .)
    ~               reduce using rule 6 (statement -> var_assign SEP .)
    ID              reduce using rule 6 (statement -> var_assign SEP .)
    TYPEOF          reduce using rule 6 (statement -> var_assign SEP .)
    LAMBDA          reduce using rule 6 (statement -> var_assign SEP .)
    DEC             reduce using rule 6 (statement -> var_assign SEP .)
    INC             reduce using rule 6 (statement -> var_assign SEP .)
    CLASS           reduce using rule 6 (statement -> var_assign SEP .)
    STRUCT          reduce using rule 6 (statement -> var_assign SEP .)
    IF              reduce using rule 6 (statement -> var_assign SEP .)
    FOR             reduce using rule 6 (statement -> var_assign SEP .)
    WHILE           reduce using rule 6 (statement -> var_assign SEP .)
    RETURN          reduce using rule 6 (statement -> var_assign SEP .)
    FN              reduce using rule 6 (statement -> var_assign SEP .)
    IMPORT          reduce using rule 6 (statement -> var_assign SEP .)
    [               reduce using rule 6 (statement -> var_assign SEP .)
    $end            reduce using rule 6 (statement -> var_assign SEP .)
    }               reduce using rule 6 (statement -> var_assign SEP .)
    ELSE            reduce using rule 6 (statement -> var_assign SEP .)


state 69

    (7) statement -> LET var . : var_type SEP
    (77) var_define -> LET var . ASSIGN expr
    (100) var -> var . [ expr ]
    :               shift and go to state 136
    ASSIGN          shift and go to state 137
    [               shift and go to state 138


state 70

    (76) var_define -> LET getter . ASSIGN expr
    (118) getter -> getter . . ID
    ASSIGN          shift and go to state 139
    .               shift and go to state 85


state 71

    (101) var -> ID .
    (117) getter -> ID .
  ! reduce/reduce conflict for ASSIGN resolved using rule 101 (var -> ID .)
    :               reduce using rule 101 (var -> ID .)
    ASSIGN          reduce using rule 101 (var -> ID .)
    [               reduce using rule 101 (var -> ID .)
    .               reduce using rule 117 (getter -> ID .)


state 72

    (37) expr -> var [ . expr ]
    (100) var -> var [ . expr ]
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 140
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 73

    (81) var_assign -> var SHRASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 141
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 74

    (82) var_assign -> var SHLASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 142
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 75

    (83) var_assign -> var XORASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 143
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 76

    (84) var_assign -> var ORASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 144
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 77

    (85) var_assign -> var ANDASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 145
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 78

    (86) var_assign -> var MODULOASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 146
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 79

    (87) var_assign -> var SLASHASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 147
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 80

    (88) var_assign -> var STARASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 148
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 81

    (89) var_assign -> var MINUSASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 149
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 82

    (90) var_assign -> var PLUSASGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 150
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 83

    (91) var_assign -> var ASSIGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 151
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 84

    (8) statement -> var_define SEP .
    LET             reduce using rule 8 (statement -> var_define SEP .)
    {               reduce using rule 8 (statement -> var_define SEP .)
    NIL             reduce using rule 8 (statement -> var_define SEP .)
    FALSE           reduce using rule 8 (statement -> var_define SEP .)
    TRUE            reduce using rule 8 (statement -> var_define SEP .)
    STRING          reduce using rule 8 (statement -> var_define SEP .)
    FLOAT           reduce using rule 8 (statement -> var_define SEP .)
    INT             reduce using rule 8 (statement -> var_define SEP .)
    (               reduce using rule 8 (statement -> var_define SEP .)
    !               reduce using rule 8 (statement -> var_define SEP .)
    +               reduce using rule 8 (statement -> var_define SEP .)
    -               reduce using rule 8 (statement -> var_define SEP .)
    ~               reduce using rule 8 (statement -> var_define SEP .)
    ID              reduce using rule 8 (statement -> var_define SEP .)
    TYPEOF          reduce using rule 8 (statement -> var_define SEP .)
    LAMBDA          reduce using rule 8 (statement -> var_define SEP .)
    DEC             reduce using rule 8 (statement -> var_define SEP .)
    INC             reduce using rule 8 (statement -> var_define SEP .)
    CLASS           reduce using rule 8 (statement -> var_define SEP .)
    STRUCT          reduce using rule 8 (statement -> var_define SEP .)
    IF              reduce using rule 8 (statement -> var_define SEP .)
    FOR             reduce using rule 8 (statement -> var_define SEP .)
    WHILE           reduce using rule 8 (statement -> var_define SEP .)
    RETURN          reduce using rule 8 (statement -> var_define SEP .)
    FN              reduce using rule 8 (statement -> var_define SEP .)
    IMPORT          reduce using rule 8 (statement -> var_define SEP .)
    [               reduce using rule 8 (statement -> var_define SEP .)
    $end            reduce using rule 8 (statement -> var_define SEP .)
    }               reduce using rule 8 (statement -> var_define SEP .)
    ELSE            reduce using rule 8 (statement -> var_define SEP .)


state 85

    (118) getter -> getter . . ID
    ID              shift and go to state 152


state 86

    (34) expr -> { member_list . }
    (113) member_list -> member_list . , member
    }               shift and go to state 153
    ,               shift and go to state 154


state 87

    (114) member_list -> member .
    }               reduce using rule 114 (member_list -> member .)
    ,               reduce using rule 114 (member_list -> member .)


state 88

    (115) member_list -> empty .
    }               reduce using rule 115 (member_list -> empty .)
    ,               reduce using rule 115 (member_list -> empty .)


state 89

    (116) member -> STRING . : expr
    :               shift and go to state 155


state 90

    (96) list_val -> [ exprs . ]
    (97) exprs -> exprs . , expr
    ]               shift and go to state 156
    ,               shift and go to state 157


state 91

    (98) exprs -> expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    ]               reduce using rule 98 (exprs -> expr .)
    ,               reduce using rule 98 (exprs -> expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 92

    (99) exprs -> empty .
    ]               reduce using rule 99 (exprs -> empty .)
    ,               reduce using rule 99 (exprs -> empty .)


state 93

    (36) expr -> var .
    (37) expr -> var . [ expr ]
    (100) var -> var . [ expr ]
  ! shift/reduce conflict for [ resolved as shift
    %               reduce using rule 36 (expr -> var .)
    /               reduce using rule 36 (expr -> var .)
    *               reduce using rule 36 (expr -> var .)
    -               reduce using rule 36 (expr -> var .)
    +               reduce using rule 36 (expr -> var .)
    |               reduce using rule 36 (expr -> var .)
    ^               reduce using rule 36 (expr -> var .)
    &               reduce using rule 36 (expr -> var .)
    SHR             reduce using rule 36 (expr -> var .)
    SHL             reduce using rule 36 (expr -> var .)
    GREATER         reduce using rule 36 (expr -> var .)
    LESS            reduce using rule 36 (expr -> var .)
    OR              reduce using rule 36 (expr -> var .)
    AND             reduce using rule 36 (expr -> var .)
    GREATEREQ       reduce using rule 36 (expr -> var .)
    LESSEQ          reduce using rule 36 (expr -> var .)
    NOTEQ           reduce using rule 36 (expr -> var .)
    EQEQ            reduce using rule 36 (expr -> var .)
    PIPE            reduce using rule 36 (expr -> var .)
    ?               reduce using rule 36 (expr -> var .)
    ]               reduce using rule 36 (expr -> var .)
    ,               reduce using rule 36 (expr -> var .)
    )               reduce using rule 36 (expr -> var .)
    SEP             reduce using rule 36 (expr -> var .)
    {               reduce using rule 36 (expr -> var .)
    LET             reduce using rule 36 (expr -> var .)
    NIL             reduce using rule 36 (expr -> var .)
    FALSE           reduce using rule 36 (expr -> var .)
    TRUE            reduce using rule 36 (expr -> var .)
    STRING          reduce using rule 36 (expr -> var .)
    FLOAT           reduce using rule 36 (expr -> var .)
    INT             reduce using rule 36 (expr -> var .)
    (               reduce using rule 36 (expr -> var .)
    !               reduce using rule 36 (expr -> var .)
    ~               reduce using rule 36 (expr -> var .)
    ID              reduce using rule 36 (expr -> var .)
    TYPEOF          reduce using rule 36 (expr -> var .)
    LAMBDA          reduce using rule 36 (expr -> var .)
    DEC             reduce using rule 36 (expr -> var .)
    INC             reduce using rule 36 (expr -> var .)
    CLASS           reduce using rule 36 (expr -> var .)
    STRUCT          reduce using rule 36 (expr -> var .)
    IF              reduce using rule 36 (expr -> var .)
    FOR             reduce using rule 36 (expr -> var .)
    WHILE           reduce using rule 36 (expr -> var .)
    RETURN          reduce using rule 36 (expr -> var .)
    FN              reduce using rule 36 (expr -> var .)
    IMPORT          reduce using rule 36 (expr -> var .)
    :               reduce using rule 36 (expr -> var .)
    }               reduce using rule 36 (expr -> var .)
    [               shift and go to state 72


state 94

    (44) expr -> ( expr . )
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    )               shift and go to state 158
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 95

    (52) expr -> - expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 52 (expr -> - expr .)
    %               reduce using rule 52 (expr -> - expr .)
    /               reduce using rule 52 (expr -> - expr .)
    *               reduce using rule 52 (expr -> - expr .)
    -               reduce using rule 52 (expr -> - expr .)
    +               reduce using rule 52 (expr -> - expr .)
    |               reduce using rule 52 (expr -> - expr .)
    ^               reduce using rule 52 (expr -> - expr .)
    &               reduce using rule 52 (expr -> - expr .)
    SHR             reduce using rule 52 (expr -> - expr .)
    SHL             reduce using rule 52 (expr -> - expr .)
    GREATER         reduce using rule 52 (expr -> - expr .)
    LESS            reduce using rule 52 (expr -> - expr .)
    OR              reduce using rule 52 (expr -> - expr .)
    AND             reduce using rule 52 (expr -> - expr .)
    GREATEREQ       reduce using rule 52 (expr -> - expr .)
    LESSEQ          reduce using rule 52 (expr -> - expr .)
    NOTEQ           reduce using rule 52 (expr -> - expr .)
    EQEQ            reduce using rule 52 (expr -> - expr .)
    PIPE            reduce using rule 52 (expr -> - expr .)
    ?               reduce using rule 52 (expr -> - expr .)
    ]               reduce using rule 52 (expr -> - expr .)
    ,               reduce using rule 52 (expr -> - expr .)
    )               reduce using rule 52 (expr -> - expr .)
    {               reduce using rule 52 (expr -> - expr .)
    LET             reduce using rule 52 (expr -> - expr .)
    NIL             reduce using rule 52 (expr -> - expr .)
    FALSE           reduce using rule 52 (expr -> - expr .)
    TRUE            reduce using rule 52 (expr -> - expr .)
    STRING          reduce using rule 52 (expr -> - expr .)
    FLOAT           reduce using rule 52 (expr -> - expr .)
    INT             reduce using rule 52 (expr -> - expr .)
    (               reduce using rule 52 (expr -> - expr .)
    !               reduce using rule 52 (expr -> - expr .)
    ~               reduce using rule 52 (expr -> - expr .)
    ID              reduce using rule 52 (expr -> - expr .)
    TYPEOF          reduce using rule 52 (expr -> - expr .)
    LAMBDA          reduce using rule 52 (expr -> - expr .)
    DEC             reduce using rule 52 (expr -> - expr .)
    INC             reduce using rule 52 (expr -> - expr .)
    CLASS           reduce using rule 52 (expr -> - expr .)
    STRUCT          reduce using rule 52 (expr -> - expr .)
    IF              reduce using rule 52 (expr -> - expr .)
    FOR             reduce using rule 52 (expr -> - expr .)
    WHILE           reduce using rule 52 (expr -> - expr .)
    RETURN          reduce using rule 52 (expr -> - expr .)
    FN              reduce using rule 52 (expr -> - expr .)
    IMPORT          reduce using rule 52 (expr -> - expr .)
    [               reduce using rule 52 (expr -> - expr .)
    :               reduce using rule 52 (expr -> - expr .)
    }               reduce using rule 52 (expr -> - expr .)


state 96

    (51) expr -> + expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 51 (expr -> + expr .)
    %               reduce using rule 51 (expr -> + expr .)
    /               reduce using rule 51 (expr -> + expr .)
    *               reduce using rule 51 (expr -> + expr .)
    -               reduce using rule 51 (expr -> + expr .)
    +               reduce using rule 51 (expr -> + expr .)
    |               reduce using rule 51 (expr -> + expr .)
    ^               reduce using rule 51 (expr -> + expr .)
    &               reduce using rule 51 (expr -> + expr .)
    SHR             reduce using rule 51 (expr -> + expr .)
    SHL             reduce using rule 51 (expr -> + expr .)
    GREATER         reduce using rule 51 (expr -> + expr .)
    LESS            reduce using rule 51 (expr -> + expr .)
    OR              reduce using rule 51 (expr -> + expr .)
    AND             reduce using rule 51 (expr -> + expr .)
    GREATEREQ       reduce using rule 51 (expr -> + expr .)
    LESSEQ          reduce using rule 51 (expr -> + expr .)
    NOTEQ           reduce using rule 51 (expr -> + expr .)
    EQEQ            reduce using rule 51 (expr -> + expr .)
    PIPE            reduce using rule 51 (expr -> + expr .)
    ?               reduce using rule 51 (expr -> + expr .)
    ]               reduce using rule 51 (expr -> + expr .)
    ,               reduce using rule 51 (expr -> + expr .)
    )               reduce using rule 51 (expr -> + expr .)
    {               reduce using rule 51 (expr -> + expr .)
    LET             reduce using rule 51 (expr -> + expr .)
    NIL             reduce using rule 51 (expr -> + expr .)
    FALSE           reduce using rule 51 (expr -> + expr .)
    TRUE            reduce using rule 51 (expr -> + expr .)
    STRING          reduce using rule 51 (expr -> + expr .)
    FLOAT           reduce using rule 51 (expr -> + expr .)
    INT             reduce using rule 51 (expr -> + expr .)
    (               reduce using rule 51 (expr -> + expr .)
    !               reduce using rule 51 (expr -> + expr .)
    ~               reduce using rule 51 (expr -> + expr .)
    ID              reduce using rule 51 (expr -> + expr .)
    TYPEOF          reduce using rule 51 (expr -> + expr .)
    LAMBDA          reduce using rule 51 (expr -> + expr .)
    DEC             reduce using rule 51 (expr -> + expr .)
    INC             reduce using rule 51 (expr -> + expr .)
    CLASS           reduce using rule 51 (expr -> + expr .)
    STRUCT          reduce using rule 51 (expr -> + expr .)
    IF              reduce using rule 51 (expr -> + expr .)
    FOR             reduce using rule 51 (expr -> + expr .)
    WHILE           reduce using rule 51 (expr -> + expr .)
    RETURN          reduce using rule 51 (expr -> + expr .)
    FN              reduce using rule 51 (expr -> + expr .)
    IMPORT          reduce using rule 51 (expr -> + expr .)
    [               reduce using rule 51 (expr -> + expr .)
    :               reduce using rule 51 (expr -> + expr .)
    }               reduce using rule 51 (expr -> + expr .)


state 97

    (50) expr -> ! expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 50 (expr -> ! expr .)
    %               reduce using rule 50 (expr -> ! expr .)
    /               reduce using rule 50 (expr -> ! expr .)
    *               reduce using rule 50 (expr -> ! expr .)
    -               reduce using rule 50 (expr -> ! expr .)
    +               reduce using rule 50 (expr -> ! expr .)
    |               reduce using rule 50 (expr -> ! expr .)
    ^               reduce using rule 50 (expr -> ! expr .)
    &               reduce using rule 50 (expr -> ! expr .)
    SHR             reduce using rule 50 (expr -> ! expr .)
    SHL             reduce using rule 50 (expr -> ! expr .)
    GREATER         reduce using rule 50 (expr -> ! expr .)
    LESS            reduce using rule 50 (expr -> ! expr .)
    OR              reduce using rule 50 (expr -> ! expr .)
    AND             reduce using rule 50 (expr -> ! expr .)
    GREATEREQ       reduce using rule 50 (expr -> ! expr .)
    LESSEQ          reduce using rule 50 (expr -> ! expr .)
    NOTEQ           reduce using rule 50 (expr -> ! expr .)
    EQEQ            reduce using rule 50 (expr -> ! expr .)
    PIPE            reduce using rule 50 (expr -> ! expr .)
    ?               reduce using rule 50 (expr -> ! expr .)
    ]               reduce using rule 50 (expr -> ! expr .)
    ,               reduce using rule 50 (expr -> ! expr .)
    )               reduce using rule 50 (expr -> ! expr .)
    {               reduce using rule 50 (expr -> ! expr .)
    LET             reduce using rule 50 (expr -> ! expr .)
    NIL             reduce using rule 50 (expr -> ! expr .)
    FALSE           reduce using rule 50 (expr -> ! expr .)
    TRUE            reduce using rule 50 (expr -> ! expr .)
    STRING          reduce using rule 50 (expr -> ! expr .)
    FLOAT           reduce using rule 50 (expr -> ! expr .)
    INT             reduce using rule 50 (expr -> ! expr .)
    (               reduce using rule 50 (expr -> ! expr .)
    !               reduce using rule 50 (expr -> ! expr .)
    ~               reduce using rule 50 (expr -> ! expr .)
    ID              reduce using rule 50 (expr -> ! expr .)
    TYPEOF          reduce using rule 50 (expr -> ! expr .)
    LAMBDA          reduce using rule 50 (expr -> ! expr .)
    DEC             reduce using rule 50 (expr -> ! expr .)
    INC             reduce using rule 50 (expr -> ! expr .)
    CLASS           reduce using rule 50 (expr -> ! expr .)
    STRUCT          reduce using rule 50 (expr -> ! expr .)
    IF              reduce using rule 50 (expr -> ! expr .)
    FOR             reduce using rule 50 (expr -> ! expr .)
    WHILE           reduce using rule 50 (expr -> ! expr .)
    RETURN          reduce using rule 50 (expr -> ! expr .)
    FN              reduce using rule 50 (expr -> ! expr .)
    IMPORT          reduce using rule 50 (expr -> ! expr .)
    [               reduce using rule 50 (expr -> ! expr .)
    :               reduce using rule 50 (expr -> ! expr .)
    }               reduce using rule 50 (expr -> ! expr .)


state 98

    (53) expr -> ~ expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 53 (expr -> ~ expr .)
    %               reduce using rule 53 (expr -> ~ expr .)
    /               reduce using rule 53 (expr -> ~ expr .)
    *               reduce using rule 53 (expr -> ~ expr .)
    -               reduce using rule 53 (expr -> ~ expr .)
    +               reduce using rule 53 (expr -> ~ expr .)
    |               reduce using rule 53 (expr -> ~ expr .)
    ^               reduce using rule 53 (expr -> ~ expr .)
    &               reduce using rule 53 (expr -> ~ expr .)
    SHR             reduce using rule 53 (expr -> ~ expr .)
    SHL             reduce using rule 53 (expr -> ~ expr .)
    GREATER         reduce using rule 53 (expr -> ~ expr .)
    LESS            reduce using rule 53 (expr -> ~ expr .)
    OR              reduce using rule 53 (expr -> ~ expr .)
    AND             reduce using rule 53 (expr -> ~ expr .)
    GREATEREQ       reduce using rule 53 (expr -> ~ expr .)
    LESSEQ          reduce using rule 53 (expr -> ~ expr .)
    NOTEQ           reduce using rule 53 (expr -> ~ expr .)
    EQEQ            reduce using rule 53 (expr -> ~ expr .)
    PIPE            reduce using rule 53 (expr -> ~ expr .)
    ?               reduce using rule 53 (expr -> ~ expr .)
    ]               reduce using rule 53 (expr -> ~ expr .)
    ,               reduce using rule 53 (expr -> ~ expr .)
    )               reduce using rule 53 (expr -> ~ expr .)
    {               reduce using rule 53 (expr -> ~ expr .)
    LET             reduce using rule 53 (expr -> ~ expr .)
    NIL             reduce using rule 53 (expr -> ~ expr .)
    FALSE           reduce using rule 53 (expr -> ~ expr .)
    TRUE            reduce using rule 53 (expr -> ~ expr .)
    STRING          reduce using rule 53 (expr -> ~ expr .)
    FLOAT           reduce using rule 53 (expr -> ~ expr .)
    INT             reduce using rule 53 (expr -> ~ expr .)
    (               reduce using rule 53 (expr -> ~ expr .)
    !               reduce using rule 53 (expr -> ~ expr .)
    ~               reduce using rule 53 (expr -> ~ expr .)
    ID              reduce using rule 53 (expr -> ~ expr .)
    TYPEOF          reduce using rule 53 (expr -> ~ expr .)
    LAMBDA          reduce using rule 53 (expr -> ~ expr .)
    DEC             reduce using rule 53 (expr -> ~ expr .)
    INC             reduce using rule 53 (expr -> ~ expr .)
    CLASS           reduce using rule 53 (expr -> ~ expr .)
    STRUCT          reduce using rule 53 (expr -> ~ expr .)
    IF              reduce using rule 53 (expr -> ~ expr .)
    FOR             reduce using rule 53 (expr -> ~ expr .)
    WHILE           reduce using rule 53 (expr -> ~ expr .)
    RETURN          reduce using rule 53 (expr -> ~ expr .)
    FN              reduce using rule 53 (expr -> ~ expr .)
    IMPORT          reduce using rule 53 (expr -> ~ expr .)
    [               reduce using rule 53 (expr -> ~ expr .)
    :               reduce using rule 53 (expr -> ~ expr .)
    }               reduce using rule 53 (expr -> ~ expr .)


state 99

    (68) expr -> ID DOUBLECOLON . ID ( args )
    ID              shift and go to state 159


state 100

    (69) expr -> ID ( . args )
    (109) args -> . empty
    (110) args -> . arg
    (111) args -> . args , arg
    (102) empty -> .
    (112) arg -> . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    )               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    args                           shift and go to state 160
    empty                          shift and go to state 161
    arg                            shift and go to state 162
    expr                           shift and go to state 163
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 101

    (73) expr -> ID LEFTARROW . { struct_init_exprs }
    {               shift and go to state 164


state 102

    (71) expr -> TYPEOF expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 71 (expr -> TYPEOF expr .)
    ]               reduce using rule 71 (expr -> TYPEOF expr .)
    ,               reduce using rule 71 (expr -> TYPEOF expr .)
    )               reduce using rule 71 (expr -> TYPEOF expr .)
    {               reduce using rule 71 (expr -> TYPEOF expr .)
    LET             reduce using rule 71 (expr -> TYPEOF expr .)
    NIL             reduce using rule 71 (expr -> TYPEOF expr .)
    FALSE           reduce using rule 71 (expr -> TYPEOF expr .)
    TRUE            reduce using rule 71 (expr -> TYPEOF expr .)
    STRING          reduce using rule 71 (expr -> TYPEOF expr .)
    FLOAT           reduce using rule 71 (expr -> TYPEOF expr .)
    INT             reduce using rule 71 (expr -> TYPEOF expr .)
    (               reduce using rule 71 (expr -> TYPEOF expr .)
    !               reduce using rule 71 (expr -> TYPEOF expr .)
    ~               reduce using rule 71 (expr -> TYPEOF expr .)
    ID              reduce using rule 71 (expr -> TYPEOF expr .)
    TYPEOF          reduce using rule 71 (expr -> TYPEOF expr .)
    LAMBDA          reduce using rule 71 (expr -> TYPEOF expr .)
    DEC             reduce using rule 71 (expr -> TYPEOF expr .)
    INC             reduce using rule 71 (expr -> TYPEOF expr .)
    CLASS           reduce using rule 71 (expr -> TYPEOF expr .)
    STRUCT          reduce using rule 71 (expr -> TYPEOF expr .)
    IF              reduce using rule 71 (expr -> TYPEOF expr .)
    FOR             reduce using rule 71 (expr -> TYPEOF expr .)
    WHILE           reduce using rule 71 (expr -> TYPEOF expr .)
    RETURN          reduce using rule 71 (expr -> TYPEOF expr .)
    FN              reduce using rule 71 (expr -> TYPEOF expr .)
    IMPORT          reduce using rule 71 (expr -> TYPEOF expr .)
    [               reduce using rule 71 (expr -> TYPEOF expr .)
    :               reduce using rule 71 (expr -> TYPEOF expr .)
    }               reduce using rule 71 (expr -> TYPEOF expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 103

    (72) expr -> LAMBDA ( . params ) ARROW expr
    (105) params -> . empty
    (106) params -> . param
    (107) params -> . params , param
    (102) empty -> .
    (108) param -> . ID : var_type
    )               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    ID              shift and go to state 168

    params                         shift and go to state 165
    empty                          shift and go to state 166
    param                          shift and go to state 167

state 104

    (79) var_assign -> DEC var .
    (100) var -> var . [ expr ]
    SEP             reduce using rule 79 (var_assign -> DEC var .)
    {               reduce using rule 79 (var_assign -> DEC var .)
    LET             reduce using rule 79 (var_assign -> DEC var .)
    NIL             reduce using rule 79 (var_assign -> DEC var .)
    FALSE           reduce using rule 79 (var_assign -> DEC var .)
    TRUE            reduce using rule 79 (var_assign -> DEC var .)
    STRING          reduce using rule 79 (var_assign -> DEC var .)
    FLOAT           reduce using rule 79 (var_assign -> DEC var .)
    INT             reduce using rule 79 (var_assign -> DEC var .)
    (               reduce using rule 79 (var_assign -> DEC var .)
    !               reduce using rule 79 (var_assign -> DEC var .)
    +               reduce using rule 79 (var_assign -> DEC var .)
    -               reduce using rule 79 (var_assign -> DEC var .)
    ~               reduce using rule 79 (var_assign -> DEC var .)
    ID              reduce using rule 79 (var_assign -> DEC var .)
    TYPEOF          reduce using rule 79 (var_assign -> DEC var .)
    LAMBDA          reduce using rule 79 (var_assign -> DEC var .)
    DEC             reduce using rule 79 (var_assign -> DEC var .)
    INC             reduce using rule 79 (var_assign -> DEC var .)
    CLASS           reduce using rule 79 (var_assign -> DEC var .)
    STRUCT          reduce using rule 79 (var_assign -> DEC var .)
    IF              reduce using rule 79 (var_assign -> DEC var .)
    FOR             reduce using rule 79 (var_assign -> DEC var .)
    WHILE           reduce using rule 79 (var_assign -> DEC var .)
    RETURN          reduce using rule 79 (var_assign -> DEC var .)
    FN              reduce using rule 79 (var_assign -> DEC var .)
    IMPORT          reduce using rule 79 (var_assign -> DEC var .)
    [               reduce using rule 79 (var_assign -> DEC var .)


state 105

    (101) var -> ID .
    [               reduce using rule 101 (var -> ID .)
    SEP             reduce using rule 101 (var -> ID .)
    {               reduce using rule 101 (var -> ID .)
    LET             reduce using rule 101 (var -> ID .)
    NIL             reduce using rule 101 (var -> ID .)
    FALSE           reduce using rule 101 (var -> ID .)
    TRUE            reduce using rule 101 (var -> ID .)
    STRING          reduce using rule 101 (var -> ID .)
    FLOAT           reduce using rule 101 (var -> ID .)
    INT             reduce using rule 101 (var -> ID .)
    (               reduce using rule 101 (var -> ID .)
    !               reduce using rule 101 (var -> ID .)
    +               reduce using rule 101 (var -> ID .)
    -               reduce using rule 101 (var -> ID .)
    ~               reduce using rule 101 (var -> ID .)
    ID              reduce using rule 101 (var -> ID .)
    TYPEOF          reduce using rule 101 (var -> ID .)
    LAMBDA          reduce using rule 101 (var -> ID .)
    DEC             reduce using rule 101 (var -> ID .)
    INC             reduce using rule 101 (var -> ID .)
    CLASS           reduce using rule 101 (var -> ID .)
    STRUCT          reduce using rule 101 (var -> ID .)
    IF              reduce using rule 101 (var -> ID .)
    FOR             reduce using rule 101 (var -> ID .)
    WHILE           reduce using rule 101 (var -> ID .)
    RETURN          reduce using rule 101 (var -> ID .)
    FN              reduce using rule 101 (var -> ID .)
    IMPORT          reduce using rule 101 (var -> ID .)
    SHRASGN         reduce using rule 101 (var -> ID .)
    SHLASGN         reduce using rule 101 (var -> ID .)
    XORASGN         reduce using rule 101 (var -> ID .)
    ORASGN          reduce using rule 101 (var -> ID .)
    ANDASGN         reduce using rule 101 (var -> ID .)
    MODULOASGN      reduce using rule 101 (var -> ID .)
    SLASHASGN       reduce using rule 101 (var -> ID .)
    STARASGN        reduce using rule 101 (var -> ID .)
    MINUSASGN       reduce using rule 101 (var -> ID .)
    PLUSASGN        reduce using rule 101 (var -> ID .)
    ASSIGN          reduce using rule 101 (var -> ID .)


state 106

    (80) var_assign -> INC var .
    (100) var -> var . [ expr ]
    SEP             reduce using rule 80 (var_assign -> INC var .)
    {               reduce using rule 80 (var_assign -> INC var .)
    LET             reduce using rule 80 (var_assign -> INC var .)
    NIL             reduce using rule 80 (var_assign -> INC var .)
    FALSE           reduce using rule 80 (var_assign -> INC var .)
    TRUE            reduce using rule 80 (var_assign -> INC var .)
    STRING          reduce using rule 80 (var_assign -> INC var .)
    FLOAT           reduce using rule 80 (var_assign -> INC var .)
    INT             reduce using rule 80 (var_assign -> INC var .)
    (               reduce using rule 80 (var_assign -> INC var .)
    !               reduce using rule 80 (var_assign -> INC var .)
    +               reduce using rule 80 (var_assign -> INC var .)
    -               reduce using rule 80 (var_assign -> INC var .)
    ~               reduce using rule 80 (var_assign -> INC var .)
    ID              reduce using rule 80 (var_assign -> INC var .)
    TYPEOF          reduce using rule 80 (var_assign -> INC var .)
    LAMBDA          reduce using rule 80 (var_assign -> INC var .)
    DEC             reduce using rule 80 (var_assign -> INC var .)
    INC             reduce using rule 80 (var_assign -> INC var .)
    CLASS           reduce using rule 80 (var_assign -> INC var .)
    STRUCT          reduce using rule 80 (var_assign -> INC var .)
    IF              reduce using rule 80 (var_assign -> INC var .)
    FOR             reduce using rule 80 (var_assign -> INC var .)
    WHILE           reduce using rule 80 (var_assign -> INC var .)
    RETURN          reduce using rule 80 (var_assign -> INC var .)
    FN              reduce using rule 80 (var_assign -> INC var .)
    IMPORT          reduce using rule 80 (var_assign -> INC var .)
    [               reduce using rule 80 (var_assign -> INC var .)


state 107

    (17) class_definition -> CLASS ID . { function_definitions }
    {               shift and go to state 169


state 108

    (21) struct_definition -> STRUCT ID . { struct_fields } SEP
    {               shift and go to state 170


state 109

    (92) if_statement -> IF expr . block
    (93) if_statement -> IF expr . block ELSE block
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    (103) block -> . statement
    (104) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 172
    +               shift and go to state 173
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67
    {               shift and go to state 175
    LET             shift and go to state 7
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    expr                           shift and go to state 5
    block                          shift and go to state 171
    statement                      shift and go to state 174
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 110

    (95) for_statement -> FOR var_assign . SEP expr SEP var_assign block
    SEP             shift and go to state 176


state 111

    (81) var_assign -> var . SHRASGN expr
    (82) var_assign -> var . SHLASGN expr
    (83) var_assign -> var . XORASGN expr
    (84) var_assign -> var . ORASGN expr
    (85) var_assign -> var . ANDASGN expr
    (86) var_assign -> var . MODULOASGN expr
    (87) var_assign -> var . SLASHASGN expr
    (88) var_assign -> var . STARASGN expr
    (89) var_assign -> var . MINUSASGN expr
    (90) var_assign -> var . PLUSASGN expr
    (91) var_assign -> var . ASSIGN expr
    (100) var -> var . [ expr ]
    SHRASGN         shift and go to state 73
    SHLASGN         shift and go to state 74
    XORASGN         shift and go to state 75
    ORASGN          shift and go to state 76
    ANDASGN         shift and go to state 77
    MODULOASGN      shift and go to state 78
    SLASHASGN       shift and go to state 79
    STARASGN        shift and go to state 80
    MINUSASGN       shift and go to state 81
    PLUSASGN        shift and go to state 82
    ASSIGN          shift and go to state 83
    [               shift and go to state 138


state 112

    (94) while_statement -> WHILE expr . block
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    (103) block -> . statement
    (104) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 172
    +               shift and go to state 173
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67
    {               shift and go to state 175
    LET             shift and go to state 7
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    expr                           shift and go to state 5
    block                          shift and go to state 177
    statement                      shift and go to state 174
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 113

    (78) return_statement -> RETURN expr . SEP
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             shift and go to state 178
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 114

    (32) function_definition -> FN ID . ( params ) block
    (               shift and go to state 179


state 115

    (31) import_statement -> IMPORT STRING . SEP
    SEP             shift and go to state 180


state 116

    (45) expr -> expr % expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 45 (expr -> expr % expr .)
    %               reduce using rule 45 (expr -> expr % expr .)
    /               reduce using rule 45 (expr -> expr % expr .)
    *               reduce using rule 45 (expr -> expr % expr .)
    -               reduce using rule 45 (expr -> expr % expr .)
    +               reduce using rule 45 (expr -> expr % expr .)
    |               reduce using rule 45 (expr -> expr % expr .)
    ^               reduce using rule 45 (expr -> expr % expr .)
    &               reduce using rule 45 (expr -> expr % expr .)
    SHR             reduce using rule 45 (expr -> expr % expr .)
    SHL             reduce using rule 45 (expr -> expr % expr .)
    GREATER         reduce using rule 45 (expr -> expr % expr .)
    LESS            reduce using rule 45 (expr -> expr % expr .)
    OR              reduce using rule 45 (expr -> expr % expr .)
    AND             reduce using rule 45 (expr -> expr % expr .)
    GREATEREQ       reduce using rule 45 (expr -> expr % expr .)
    LESSEQ          reduce using rule 45 (expr -> expr % expr .)
    NOTEQ           reduce using rule 45 (expr -> expr % expr .)
    EQEQ            reduce using rule 45 (expr -> expr % expr .)
    PIPE            reduce using rule 45 (expr -> expr % expr .)
    ?               reduce using rule 45 (expr -> expr % expr .)
    ]               reduce using rule 45 (expr -> expr % expr .)
    ,               reduce using rule 45 (expr -> expr % expr .)
    )               reduce using rule 45 (expr -> expr % expr .)
    {               reduce using rule 45 (expr -> expr % expr .)
    LET             reduce using rule 45 (expr -> expr % expr .)
    NIL             reduce using rule 45 (expr -> expr % expr .)
    FALSE           reduce using rule 45 (expr -> expr % expr .)
    TRUE            reduce using rule 45 (expr -> expr % expr .)
    STRING          reduce using rule 45 (expr -> expr % expr .)
    FLOAT           reduce using rule 45 (expr -> expr % expr .)
    INT             reduce using rule 45 (expr -> expr % expr .)
    (               reduce using rule 45 (expr -> expr % expr .)
    !               reduce using rule 45 (expr -> expr % expr .)
    ~               reduce using rule 45 (expr -> expr % expr .)
    ID              reduce using rule 45 (expr -> expr % expr .)
    TYPEOF          reduce using rule 45 (expr -> expr % expr .)
    LAMBDA          reduce using rule 45 (expr -> expr % expr .)
    DEC             reduce using rule 45 (expr -> expr % expr .)
    INC             reduce using rule 45 (expr -> expr % expr .)
    CLASS           reduce using rule 45 (expr -> expr % expr .)
    STRUCT          reduce using rule 45 (expr -> expr % expr .)
    IF              reduce using rule 45 (expr -> expr % expr .)
    FOR             reduce using rule 45 (expr -> expr % expr .)
    WHILE           reduce using rule 45 (expr -> expr % expr .)
    RETURN          reduce using rule 45 (expr -> expr % expr .)
    FN              reduce using rule 45 (expr -> expr % expr .)
    IMPORT          reduce using rule 45 (expr -> expr % expr .)
    [               reduce using rule 45 (expr -> expr % expr .)
    :               reduce using rule 45 (expr -> expr % expr .)
    }               reduce using rule 45 (expr -> expr % expr .)


state 117

    (46) expr -> expr / expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 46 (expr -> expr / expr .)
    %               reduce using rule 46 (expr -> expr / expr .)
    /               reduce using rule 46 (expr -> expr / expr .)
    *               reduce using rule 46 (expr -> expr / expr .)
    -               reduce using rule 46 (expr -> expr / expr .)
    +               reduce using rule 46 (expr -> expr / expr .)
    |               reduce using rule 46 (expr -> expr / expr .)
    ^               reduce using rule 46 (expr -> expr / expr .)
    &               reduce using rule 46 (expr -> expr / expr .)
    SHR             reduce using rule 46 (expr -> expr / expr .)
    SHL             reduce using rule 46 (expr -> expr / expr .)
    GREATER         reduce using rule 46 (expr -> expr / expr .)
    LESS            reduce using rule 46 (expr -> expr / expr .)
    OR              reduce using rule 46 (expr -> expr / expr .)
    AND             reduce using rule 46 (expr -> expr / expr .)
    GREATEREQ       reduce using rule 46 (expr -> expr / expr .)
    LESSEQ          reduce using rule 46 (expr -> expr / expr .)
    NOTEQ           reduce using rule 46 (expr -> expr / expr .)
    EQEQ            reduce using rule 46 (expr -> expr / expr .)
    PIPE            reduce using rule 46 (expr -> expr / expr .)
    ?               reduce using rule 46 (expr -> expr / expr .)
    ]               reduce using rule 46 (expr -> expr / expr .)
    ,               reduce using rule 46 (expr -> expr / expr .)
    )               reduce using rule 46 (expr -> expr / expr .)
    {               reduce using rule 46 (expr -> expr / expr .)
    LET             reduce using rule 46 (expr -> expr / expr .)
    NIL             reduce using rule 46 (expr -> expr / expr .)
    FALSE           reduce using rule 46 (expr -> expr / expr .)
    TRUE            reduce using rule 46 (expr -> expr / expr .)
    STRING          reduce using rule 46 (expr -> expr / expr .)
    FLOAT           reduce using rule 46 (expr -> expr / expr .)
    INT             reduce using rule 46 (expr -> expr / expr .)
    (               reduce using rule 46 (expr -> expr / expr .)
    !               reduce using rule 46 (expr -> expr / expr .)
    ~               reduce using rule 46 (expr -> expr / expr .)
    ID              reduce using rule 46 (expr -> expr / expr .)
    TYPEOF          reduce using rule 46 (expr -> expr / expr .)
    LAMBDA          reduce using rule 46 (expr -> expr / expr .)
    DEC             reduce using rule 46 (expr -> expr / expr .)
    INC             reduce using rule 46 (expr -> expr / expr .)
    CLASS           reduce using rule 46 (expr -> expr / expr .)
    STRUCT          reduce using rule 46 (expr -> expr / expr .)
    IF              reduce using rule 46 (expr -> expr / expr .)
    FOR             reduce using rule 46 (expr -> expr / expr .)
    WHILE           reduce using rule 46 (expr -> expr / expr .)
    RETURN          reduce using rule 46 (expr -> expr / expr .)
    FN              reduce using rule 46 (expr -> expr / expr .)
    IMPORT          reduce using rule 46 (expr -> expr / expr .)
    [               reduce using rule 46 (expr -> expr / expr .)
    :               reduce using rule 46 (expr -> expr / expr .)
    }               reduce using rule 46 (expr -> expr / expr .)


state 118

    (47) expr -> expr * expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 47 (expr -> expr * expr .)
    %               reduce using rule 47 (expr -> expr * expr .)
    /               reduce using rule 47 (expr -> expr * expr .)
    *               reduce using rule 47 (expr -> expr * expr .)
    -               reduce using rule 47 (expr -> expr * expr .)
    +               reduce using rule 47 (expr -> expr * expr .)
    |               reduce using rule 47 (expr -> expr * expr .)
    ^               reduce using rule 47 (expr -> expr * expr .)
    &               reduce using rule 47 (expr -> expr * expr .)
    SHR             reduce using rule 47 (expr -> expr * expr .)
    SHL             reduce using rule 47 (expr -> expr * expr .)
    GREATER         reduce using rule 47 (expr -> expr * expr .)
    LESS            reduce using rule 47 (expr -> expr * expr .)
    OR              reduce using rule 47 (expr -> expr * expr .)
    AND             reduce using rule 47 (expr -> expr * expr .)
    GREATEREQ       reduce using rule 47 (expr -> expr * expr .)
    LESSEQ          reduce using rule 47 (expr -> expr * expr .)
    NOTEQ           reduce using rule 47 (expr -> expr * expr .)
    EQEQ            reduce using rule 47 (expr -> expr * expr .)
    PIPE            reduce using rule 47 (expr -> expr * expr .)
    ?               reduce using rule 47 (expr -> expr * expr .)
    ]               reduce using rule 47 (expr -> expr * expr .)
    ,               reduce using rule 47 (expr -> expr * expr .)
    )               reduce using rule 47 (expr -> expr * expr .)
    {               reduce using rule 47 (expr -> expr * expr .)
    LET             reduce using rule 47 (expr -> expr * expr .)
    NIL             reduce using rule 47 (expr -> expr * expr .)
    FALSE           reduce using rule 47 (expr -> expr * expr .)
    TRUE            reduce using rule 47 (expr -> expr * expr .)
    STRING          reduce using rule 47 (expr -> expr * expr .)
    FLOAT           reduce using rule 47 (expr -> expr * expr .)
    INT             reduce using rule 47 (expr -> expr * expr .)
    (               reduce using rule 47 (expr -> expr * expr .)
    !               reduce using rule 47 (expr -> expr * expr .)
    ~               reduce using rule 47 (expr -> expr * expr .)
    ID              reduce using rule 47 (expr -> expr * expr .)
    TYPEOF          reduce using rule 47 (expr -> expr * expr .)
    LAMBDA          reduce using rule 47 (expr -> expr * expr .)
    DEC             reduce using rule 47 (expr -> expr * expr .)
    INC             reduce using rule 47 (expr -> expr * expr .)
    CLASS           reduce using rule 47 (expr -> expr * expr .)
    STRUCT          reduce using rule 47 (expr -> expr * expr .)
    IF              reduce using rule 47 (expr -> expr * expr .)
    FOR             reduce using rule 47 (expr -> expr * expr .)
    WHILE           reduce using rule 47 (expr -> expr * expr .)
    RETURN          reduce using rule 47 (expr -> expr * expr .)
    FN              reduce using rule 47 (expr -> expr * expr .)
    IMPORT          reduce using rule 47 (expr -> expr * expr .)
    [               reduce using rule 47 (expr -> expr * expr .)
    :               reduce using rule 47 (expr -> expr * expr .)
    }               reduce using rule 47 (expr -> expr * expr .)


state 119

    (48) expr -> expr - expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 48 (expr -> expr - expr .)
    -               reduce using rule 48 (expr -> expr - expr .)
    +               reduce using rule 48 (expr -> expr - expr .)
    |               reduce using rule 48 (expr -> expr - expr .)
    ^               reduce using rule 48 (expr -> expr - expr .)
    &               reduce using rule 48 (expr -> expr - expr .)
    SHR             reduce using rule 48 (expr -> expr - expr .)
    SHL             reduce using rule 48 (expr -> expr - expr .)
    GREATER         reduce using rule 48 (expr -> expr - expr .)
    LESS            reduce using rule 48 (expr -> expr - expr .)
    OR              reduce using rule 48 (expr -> expr - expr .)
    AND             reduce using rule 48 (expr -> expr - expr .)
    GREATEREQ       reduce using rule 48 (expr -> expr - expr .)
    LESSEQ          reduce using rule 48 (expr -> expr - expr .)
    NOTEQ           reduce using rule 48 (expr -> expr - expr .)
    EQEQ            reduce using rule 48 (expr -> expr - expr .)
    PIPE            reduce using rule 48 (expr -> expr - expr .)
    ?               reduce using rule 48 (expr -> expr - expr .)
    ]               reduce using rule 48 (expr -> expr - expr .)
    ,               reduce using rule 48 (expr -> expr - expr .)
    )               reduce using rule 48 (expr -> expr - expr .)
    {               reduce using rule 48 (expr -> expr - expr .)
    LET             reduce using rule 48 (expr -> expr - expr .)
    NIL             reduce using rule 48 (expr -> expr - expr .)
    FALSE           reduce using rule 48 (expr -> expr - expr .)
    TRUE            reduce using rule 48 (expr -> expr - expr .)
    STRING          reduce using rule 48 (expr -> expr - expr .)
    FLOAT           reduce using rule 48 (expr -> expr - expr .)
    INT             reduce using rule 48 (expr -> expr - expr .)
    (               reduce using rule 48 (expr -> expr - expr .)
    !               reduce using rule 48 (expr -> expr - expr .)
    ~               reduce using rule 48 (expr -> expr - expr .)
    ID              reduce using rule 48 (expr -> expr - expr .)
    TYPEOF          reduce using rule 48 (expr -> expr - expr .)
    LAMBDA          reduce using rule 48 (expr -> expr - expr .)
    DEC             reduce using rule 48 (expr -> expr - expr .)
    INC             reduce using rule 48 (expr -> expr - expr .)
    CLASS           reduce using rule 48 (expr -> expr - expr .)
    STRUCT          reduce using rule 48 (expr -> expr - expr .)
    IF              reduce using rule 48 (expr -> expr - expr .)
    FOR             reduce using rule 48 (expr -> expr - expr .)
    WHILE           reduce using rule 48 (expr -> expr - expr .)
    RETURN          reduce using rule 48 (expr -> expr - expr .)
    FN              reduce using rule 48 (expr -> expr - expr .)
    IMPORT          reduce using rule 48 (expr -> expr - expr .)
    [               reduce using rule 48 (expr -> expr - expr .)
    :               reduce using rule 48 (expr -> expr - expr .)
    }               reduce using rule 48 (expr -> expr - expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50


state 120

    (49) expr -> expr + expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 49 (expr -> expr + expr .)
    -               reduce using rule 49 (expr -> expr + expr .)
    +               reduce using rule 49 (expr -> expr + expr .)
    |               reduce using rule 49 (expr -> expr + expr .)
    ^               reduce using rule 49 (expr -> expr + expr .)
    &               reduce using rule 49 (expr -> expr + expr .)
    SHR             reduce using rule 49 (expr -> expr + expr .)
    SHL             reduce using rule 49 (expr -> expr + expr .)
    GREATER         reduce using rule 49 (expr -> expr + expr .)
    LESS            reduce using rule 49 (expr -> expr + expr .)
    OR              reduce using rule 49 (expr -> expr + expr .)
    AND             reduce using rule 49 (expr -> expr + expr .)
    GREATEREQ       reduce using rule 49 (expr -> expr + expr .)
    LESSEQ          reduce using rule 49 (expr -> expr + expr .)
    NOTEQ           reduce using rule 49 (expr -> expr + expr .)
    EQEQ            reduce using rule 49 (expr -> expr + expr .)
    PIPE            reduce using rule 49 (expr -> expr + expr .)
    ?               reduce using rule 49 (expr -> expr + expr .)
    ]               reduce using rule 49 (expr -> expr + expr .)
    ,               reduce using rule 49 (expr -> expr + expr .)
    )               reduce using rule 49 (expr -> expr + expr .)
    {               reduce using rule 49 (expr -> expr + expr .)
    LET             reduce using rule 49 (expr -> expr + expr .)
    NIL             reduce using rule 49 (expr -> expr + expr .)
    FALSE           reduce using rule 49 (expr -> expr + expr .)
    TRUE            reduce using rule 49 (expr -> expr + expr .)
    STRING          reduce using rule 49 (expr -> expr + expr .)
    FLOAT           reduce using rule 49 (expr -> expr + expr .)
    INT             reduce using rule 49 (expr -> expr + expr .)
    (               reduce using rule 49 (expr -> expr + expr .)
    !               reduce using rule 49 (expr -> expr + expr .)
    ~               reduce using rule 49 (expr -> expr + expr .)
    ID              reduce using rule 49 (expr -> expr + expr .)
    TYPEOF          reduce using rule 49 (expr -> expr + expr .)
    LAMBDA          reduce using rule 49 (expr -> expr + expr .)
    DEC             reduce using rule 49 (expr -> expr + expr .)
    INC             reduce using rule 49 (expr -> expr + expr .)
    CLASS           reduce using rule 49 (expr -> expr + expr .)
    STRUCT          reduce using rule 49 (expr -> expr + expr .)
    IF              reduce using rule 49 (expr -> expr + expr .)
    FOR             reduce using rule 49 (expr -> expr + expr .)
    WHILE           reduce using rule 49 (expr -> expr + expr .)
    RETURN          reduce using rule 49 (expr -> expr + expr .)
    FN              reduce using rule 49 (expr -> expr + expr .)
    IMPORT          reduce using rule 49 (expr -> expr + expr .)
    [               reduce using rule 49 (expr -> expr + expr .)
    :               reduce using rule 49 (expr -> expr + expr .)
    }               reduce using rule 49 (expr -> expr + expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50


state 121

    (54) expr -> expr | expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 54 (expr -> expr | expr .)
    |               reduce using rule 54 (expr -> expr | expr .)
    OR              reduce using rule 54 (expr -> expr | expr .)
    AND             reduce using rule 54 (expr -> expr | expr .)
    PIPE            reduce using rule 54 (expr -> expr | expr .)
    ?               reduce using rule 54 (expr -> expr | expr .)
    ]               reduce using rule 54 (expr -> expr | expr .)
    ,               reduce using rule 54 (expr -> expr | expr .)
    )               reduce using rule 54 (expr -> expr | expr .)
    {               reduce using rule 54 (expr -> expr | expr .)
    LET             reduce using rule 54 (expr -> expr | expr .)
    NIL             reduce using rule 54 (expr -> expr | expr .)
    FALSE           reduce using rule 54 (expr -> expr | expr .)
    TRUE            reduce using rule 54 (expr -> expr | expr .)
    STRING          reduce using rule 54 (expr -> expr | expr .)
    FLOAT           reduce using rule 54 (expr -> expr | expr .)
    INT             reduce using rule 54 (expr -> expr | expr .)
    (               reduce using rule 54 (expr -> expr | expr .)
    !               reduce using rule 54 (expr -> expr | expr .)
    ~               reduce using rule 54 (expr -> expr | expr .)
    ID              reduce using rule 54 (expr -> expr | expr .)
    TYPEOF          reduce using rule 54 (expr -> expr | expr .)
    LAMBDA          reduce using rule 54 (expr -> expr | expr .)
    DEC             reduce using rule 54 (expr -> expr | expr .)
    INC             reduce using rule 54 (expr -> expr | expr .)
    CLASS           reduce using rule 54 (expr -> expr | expr .)
    STRUCT          reduce using rule 54 (expr -> expr | expr .)
    IF              reduce using rule 54 (expr -> expr | expr .)
    FOR             reduce using rule 54 (expr -> expr | expr .)
    WHILE           reduce using rule 54 (expr -> expr | expr .)
    RETURN          reduce using rule 54 (expr -> expr | expr .)
    FN              reduce using rule 54 (expr -> expr | expr .)
    IMPORT          reduce using rule 54 (expr -> expr | expr .)
    [               reduce using rule 54 (expr -> expr | expr .)
    :               reduce using rule 54 (expr -> expr | expr .)
    }               reduce using rule 54 (expr -> expr | expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65


state 122

    (55) expr -> expr ^ expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 55 (expr -> expr ^ expr .)
    |               reduce using rule 55 (expr -> expr ^ expr .)
    ^               reduce using rule 55 (expr -> expr ^ expr .)
    OR              reduce using rule 55 (expr -> expr ^ expr .)
    AND             reduce using rule 55 (expr -> expr ^ expr .)
    PIPE            reduce using rule 55 (expr -> expr ^ expr .)
    ?               reduce using rule 55 (expr -> expr ^ expr .)
    ]               reduce using rule 55 (expr -> expr ^ expr .)
    ,               reduce using rule 55 (expr -> expr ^ expr .)
    )               reduce using rule 55 (expr -> expr ^ expr .)
    {               reduce using rule 55 (expr -> expr ^ expr .)
    LET             reduce using rule 55 (expr -> expr ^ expr .)
    NIL             reduce using rule 55 (expr -> expr ^ expr .)
    FALSE           reduce using rule 55 (expr -> expr ^ expr .)
    TRUE            reduce using rule 55 (expr -> expr ^ expr .)
    STRING          reduce using rule 55 (expr -> expr ^ expr .)
    FLOAT           reduce using rule 55 (expr -> expr ^ expr .)
    INT             reduce using rule 55 (expr -> expr ^ expr .)
    (               reduce using rule 55 (expr -> expr ^ expr .)
    !               reduce using rule 55 (expr -> expr ^ expr .)
    ~               reduce using rule 55 (expr -> expr ^ expr .)
    ID              reduce using rule 55 (expr -> expr ^ expr .)
    TYPEOF          reduce using rule 55 (expr -> expr ^ expr .)
    LAMBDA          reduce using rule 55 (expr -> expr ^ expr .)
    DEC             reduce using rule 55 (expr -> expr ^ expr .)
    INC             reduce using rule 55 (expr -> expr ^ expr .)
    CLASS           reduce using rule 55 (expr -> expr ^ expr .)
    STRUCT          reduce using rule 55 (expr -> expr ^ expr .)
    IF              reduce using rule 55 (expr -> expr ^ expr .)
    FOR             reduce using rule 55 (expr -> expr ^ expr .)
    WHILE           reduce using rule 55 (expr -> expr ^ expr .)
    RETURN          reduce using rule 55 (expr -> expr ^ expr .)
    FN              reduce using rule 55 (expr -> expr ^ expr .)
    IMPORT          reduce using rule 55 (expr -> expr ^ expr .)
    [               reduce using rule 55 (expr -> expr ^ expr .)
    :               reduce using rule 55 (expr -> expr ^ expr .)
    }               reduce using rule 55 (expr -> expr ^ expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65


state 123

    (56) expr -> expr & expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 56 (expr -> expr & expr .)
    |               reduce using rule 56 (expr -> expr & expr .)
    ^               reduce using rule 56 (expr -> expr & expr .)
    &               reduce using rule 56 (expr -> expr & expr .)
    OR              reduce using rule 56 (expr -> expr & expr .)
    AND             reduce using rule 56 (expr -> expr & expr .)
    PIPE            reduce using rule 56 (expr -> expr & expr .)
    ?               reduce using rule 56 (expr -> expr & expr .)
    ]               reduce using rule 56 (expr -> expr & expr .)
    ,               reduce using rule 56 (expr -> expr & expr .)
    )               reduce using rule 56 (expr -> expr & expr .)
    {               reduce using rule 56 (expr -> expr & expr .)
    LET             reduce using rule 56 (expr -> expr & expr .)
    NIL             reduce using rule 56 (expr -> expr & expr .)
    FALSE           reduce using rule 56 (expr -> expr & expr .)
    TRUE            reduce using rule 56 (expr -> expr & expr .)
    STRING          reduce using rule 56 (expr -> expr & expr .)
    FLOAT           reduce using rule 56 (expr -> expr & expr .)
    INT             reduce using rule 56 (expr -> expr & expr .)
    (               reduce using rule 56 (expr -> expr & expr .)
    !               reduce using rule 56 (expr -> expr & expr .)
    ~               reduce using rule 56 (expr -> expr & expr .)
    ID              reduce using rule 56 (expr -> expr & expr .)
    TYPEOF          reduce using rule 56 (expr -> expr & expr .)
    LAMBDA          reduce using rule 56 (expr -> expr & expr .)
    DEC             reduce using rule 56 (expr -> expr & expr .)
    INC             reduce using rule 56 (expr -> expr & expr .)
    CLASS           reduce using rule 56 (expr -> expr & expr .)
    STRUCT          reduce using rule 56 (expr -> expr & expr .)
    IF              reduce using rule 56 (expr -> expr & expr .)
    FOR             reduce using rule 56 (expr -> expr & expr .)
    WHILE           reduce using rule 56 (expr -> expr & expr .)
    RETURN          reduce using rule 56 (expr -> expr & expr .)
    FN              reduce using rule 56 (expr -> expr & expr .)
    IMPORT          reduce using rule 56 (expr -> expr & expr .)
    [               reduce using rule 56 (expr -> expr & expr .)
    :               reduce using rule 56 (expr -> expr & expr .)
    }               reduce using rule 56 (expr -> expr & expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65


state 124

    (57) expr -> expr SHR expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 57 (expr -> expr SHR expr .)
    |               reduce using rule 57 (expr -> expr SHR expr .)
    ^               reduce using rule 57 (expr -> expr SHR expr .)
    &               reduce using rule 57 (expr -> expr SHR expr .)
    SHR             reduce using rule 57 (expr -> expr SHR expr .)
    SHL             reduce using rule 57 (expr -> expr SHR expr .)
    GREATER         reduce using rule 57 (expr -> expr SHR expr .)
    LESS            reduce using rule 57 (expr -> expr SHR expr .)
    OR              reduce using rule 57 (expr -> expr SHR expr .)
    AND             reduce using rule 57 (expr -> expr SHR expr .)
    GREATEREQ       reduce using rule 57 (expr -> expr SHR expr .)
    LESSEQ          reduce using rule 57 (expr -> expr SHR expr .)
    NOTEQ           reduce using rule 57 (expr -> expr SHR expr .)
    EQEQ            reduce using rule 57 (expr -> expr SHR expr .)
    PIPE            reduce using rule 57 (expr -> expr SHR expr .)
    ?               reduce using rule 57 (expr -> expr SHR expr .)
    ]               reduce using rule 57 (expr -> expr SHR expr .)
    ,               reduce using rule 57 (expr -> expr SHR expr .)
    )               reduce using rule 57 (expr -> expr SHR expr .)
    {               reduce using rule 57 (expr -> expr SHR expr .)
    LET             reduce using rule 57 (expr -> expr SHR expr .)
    NIL             reduce using rule 57 (expr -> expr SHR expr .)
    FALSE           reduce using rule 57 (expr -> expr SHR expr .)
    TRUE            reduce using rule 57 (expr -> expr SHR expr .)
    STRING          reduce using rule 57 (expr -> expr SHR expr .)
    FLOAT           reduce using rule 57 (expr -> expr SHR expr .)
    INT             reduce using rule 57 (expr -> expr SHR expr .)
    (               reduce using rule 57 (expr -> expr SHR expr .)
    !               reduce using rule 57 (expr -> expr SHR expr .)
    ~               reduce using rule 57 (expr -> expr SHR expr .)
    ID              reduce using rule 57 (expr -> expr SHR expr .)
    TYPEOF          reduce using rule 57 (expr -> expr SHR expr .)
    LAMBDA          reduce using rule 57 (expr -> expr SHR expr .)
    DEC             reduce using rule 57 (expr -> expr SHR expr .)
    INC             reduce using rule 57 (expr -> expr SHR expr .)
    CLASS           reduce using rule 57 (expr -> expr SHR expr .)
    STRUCT          reduce using rule 57 (expr -> expr SHR expr .)
    IF              reduce using rule 57 (expr -> expr SHR expr .)
    FOR             reduce using rule 57 (expr -> expr SHR expr .)
    WHILE           reduce using rule 57 (expr -> expr SHR expr .)
    RETURN          reduce using rule 57 (expr -> expr SHR expr .)
    FN              reduce using rule 57 (expr -> expr SHR expr .)
    IMPORT          reduce using rule 57 (expr -> expr SHR expr .)
    [               reduce using rule 57 (expr -> expr SHR expr .)
    :               reduce using rule 57 (expr -> expr SHR expr .)
    }               reduce using rule 57 (expr -> expr SHR expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 125

    (58) expr -> expr SHL expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 58 (expr -> expr SHL expr .)
    |               reduce using rule 58 (expr -> expr SHL expr .)
    ^               reduce using rule 58 (expr -> expr SHL expr .)
    &               reduce using rule 58 (expr -> expr SHL expr .)
    SHR             reduce using rule 58 (expr -> expr SHL expr .)
    SHL             reduce using rule 58 (expr -> expr SHL expr .)
    GREATER         reduce using rule 58 (expr -> expr SHL expr .)
    LESS            reduce using rule 58 (expr -> expr SHL expr .)
    OR              reduce using rule 58 (expr -> expr SHL expr .)
    AND             reduce using rule 58 (expr -> expr SHL expr .)
    GREATEREQ       reduce using rule 58 (expr -> expr SHL expr .)
    LESSEQ          reduce using rule 58 (expr -> expr SHL expr .)
    NOTEQ           reduce using rule 58 (expr -> expr SHL expr .)
    EQEQ            reduce using rule 58 (expr -> expr SHL expr .)
    PIPE            reduce using rule 58 (expr -> expr SHL expr .)
    ?               reduce using rule 58 (expr -> expr SHL expr .)
    ]               reduce using rule 58 (expr -> expr SHL expr .)
    ,               reduce using rule 58 (expr -> expr SHL expr .)
    )               reduce using rule 58 (expr -> expr SHL expr .)
    {               reduce using rule 58 (expr -> expr SHL expr .)
    LET             reduce using rule 58 (expr -> expr SHL expr .)
    NIL             reduce using rule 58 (expr -> expr SHL expr .)
    FALSE           reduce using rule 58 (expr -> expr SHL expr .)
    TRUE            reduce using rule 58 (expr -> expr SHL expr .)
    STRING          reduce using rule 58 (expr -> expr SHL expr .)
    FLOAT           reduce using rule 58 (expr -> expr SHL expr .)
    INT             reduce using rule 58 (expr -> expr SHL expr .)
    (               reduce using rule 58 (expr -> expr SHL expr .)
    !               reduce using rule 58 (expr -> expr SHL expr .)
    ~               reduce using rule 58 (expr -> expr SHL expr .)
    ID              reduce using rule 58 (expr -> expr SHL expr .)
    TYPEOF          reduce using rule 58 (expr -> expr SHL expr .)
    LAMBDA          reduce using rule 58 (expr -> expr SHL expr .)
    DEC             reduce using rule 58 (expr -> expr SHL expr .)
    INC             reduce using rule 58 (expr -> expr SHL expr .)
    CLASS           reduce using rule 58 (expr -> expr SHL expr .)
    STRUCT          reduce using rule 58 (expr -> expr SHL expr .)
    IF              reduce using rule 58 (expr -> expr SHL expr .)
    FOR             reduce using rule 58 (expr -> expr SHL expr .)
    WHILE           reduce using rule 58 (expr -> expr SHL expr .)
    RETURN          reduce using rule 58 (expr -> expr SHL expr .)
    FN              reduce using rule 58 (expr -> expr SHL expr .)
    IMPORT          reduce using rule 58 (expr -> expr SHL expr .)
    [               reduce using rule 58 (expr -> expr SHL expr .)
    :               reduce using rule 58 (expr -> expr SHL expr .)
    }               reduce using rule 58 (expr -> expr SHL expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52


state 126

    (59) expr -> expr GREATER expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 59 (expr -> expr GREATER expr .)
    |               reduce using rule 59 (expr -> expr GREATER expr .)
    ^               reduce using rule 59 (expr -> expr GREATER expr .)
    &               reduce using rule 59 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 59 (expr -> expr GREATER expr .)
    LESS            reduce using rule 59 (expr -> expr GREATER expr .)
    OR              reduce using rule 59 (expr -> expr GREATER expr .)
    AND             reduce using rule 59 (expr -> expr GREATER expr .)
    GREATEREQ       reduce using rule 59 (expr -> expr GREATER expr .)
    LESSEQ          reduce using rule 59 (expr -> expr GREATER expr .)
    NOTEQ           reduce using rule 59 (expr -> expr GREATER expr .)
    EQEQ            reduce using rule 59 (expr -> expr GREATER expr .)
    PIPE            reduce using rule 59 (expr -> expr GREATER expr .)
    ?               reduce using rule 59 (expr -> expr GREATER expr .)
    ]               reduce using rule 59 (expr -> expr GREATER expr .)
    ,               reduce using rule 59 (expr -> expr GREATER expr .)
    )               reduce using rule 59 (expr -> expr GREATER expr .)
    {               reduce using rule 59 (expr -> expr GREATER expr .)
    LET             reduce using rule 59 (expr -> expr GREATER expr .)
    NIL             reduce using rule 59 (expr -> expr GREATER expr .)
    FALSE           reduce using rule 59 (expr -> expr GREATER expr .)
    TRUE            reduce using rule 59 (expr -> expr GREATER expr .)
    STRING          reduce using rule 59 (expr -> expr GREATER expr .)
    FLOAT           reduce using rule 59 (expr -> expr GREATER expr .)
    INT             reduce using rule 59 (expr -> expr GREATER expr .)
    (               reduce using rule 59 (expr -> expr GREATER expr .)
    !               reduce using rule 59 (expr -> expr GREATER expr .)
    ~               reduce using rule 59 (expr -> expr GREATER expr .)
    ID              reduce using rule 59 (expr -> expr GREATER expr .)
    TYPEOF          reduce using rule 59 (expr -> expr GREATER expr .)
    LAMBDA          reduce using rule 59 (expr -> expr GREATER expr .)
    DEC             reduce using rule 59 (expr -> expr GREATER expr .)
    INC             reduce using rule 59 (expr -> expr GREATER expr .)
    CLASS           reduce using rule 59 (expr -> expr GREATER expr .)
    STRUCT          reduce using rule 59 (expr -> expr GREATER expr .)
    IF              reduce using rule 59 (expr -> expr GREATER expr .)
    FOR             reduce using rule 59 (expr -> expr GREATER expr .)
    WHILE           reduce using rule 59 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 59 (expr -> expr GREATER expr .)
    FN              reduce using rule 59 (expr -> expr GREATER expr .)
    IMPORT          reduce using rule 59 (expr -> expr GREATER expr .)
    [               reduce using rule 59 (expr -> expr GREATER expr .)
    :               reduce using rule 59 (expr -> expr GREATER expr .)
    }               reduce using rule 59 (expr -> expr GREATER expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57


state 127

    (60) expr -> expr LESS expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 60 (expr -> expr LESS expr .)
    |               reduce using rule 60 (expr -> expr LESS expr .)
    ^               reduce using rule 60 (expr -> expr LESS expr .)
    &               reduce using rule 60 (expr -> expr LESS expr .)
    GREATER         reduce using rule 60 (expr -> expr LESS expr .)
    LESS            reduce using rule 60 (expr -> expr LESS expr .)
    OR              reduce using rule 60 (expr -> expr LESS expr .)
    AND             reduce using rule 60 (expr -> expr LESS expr .)
    GREATEREQ       reduce using rule 60 (expr -> expr LESS expr .)
    LESSEQ          reduce using rule 60 (expr -> expr LESS expr .)
    NOTEQ           reduce using rule 60 (expr -> expr LESS expr .)
    EQEQ            reduce using rule 60 (expr -> expr LESS expr .)
    PIPE            reduce using rule 60 (expr -> expr LESS expr .)
    ?               reduce using rule 60 (expr -> expr LESS expr .)
    ]               reduce using rule 60 (expr -> expr LESS expr .)
    ,               reduce using rule 60 (expr -> expr LESS expr .)
    )               reduce using rule 60 (expr -> expr LESS expr .)
    {               reduce using rule 60 (expr -> expr LESS expr .)
    LET             reduce using rule 60 (expr -> expr LESS expr .)
    NIL             reduce using rule 60 (expr -> expr LESS expr .)
    FALSE           reduce using rule 60 (expr -> expr LESS expr .)
    TRUE            reduce using rule 60 (expr -> expr LESS expr .)
    STRING          reduce using rule 60 (expr -> expr LESS expr .)
    FLOAT           reduce using rule 60 (expr -> expr LESS expr .)
    INT             reduce using rule 60 (expr -> expr LESS expr .)
    (               reduce using rule 60 (expr -> expr LESS expr .)
    !               reduce using rule 60 (expr -> expr LESS expr .)
    ~               reduce using rule 60 (expr -> expr LESS expr .)
    ID              reduce using rule 60 (expr -> expr LESS expr .)
    TYPEOF          reduce using rule 60 (expr -> expr LESS expr .)
    LAMBDA          reduce using rule 60 (expr -> expr LESS expr .)
    DEC             reduce using rule 60 (expr -> expr LESS expr .)
    INC             reduce using rule 60 (expr -> expr LESS expr .)
    CLASS           reduce using rule 60 (expr -> expr LESS expr .)
    STRUCT          reduce using rule 60 (expr -> expr LESS expr .)
    IF              reduce using rule 60 (expr -> expr LESS expr .)
    FOR             reduce using rule 60 (expr -> expr LESS expr .)
    WHILE           reduce using rule 60 (expr -> expr LESS expr .)
    RETURN          reduce using rule 60 (expr -> expr LESS expr .)
    FN              reduce using rule 60 (expr -> expr LESS expr .)
    IMPORT          reduce using rule 60 (expr -> expr LESS expr .)
    [               reduce using rule 60 (expr -> expr LESS expr .)
    :               reduce using rule 60 (expr -> expr LESS expr .)
    }               reduce using rule 60 (expr -> expr LESS expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57


state 128

    (61) expr -> expr OR expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 61 (expr -> expr OR expr .)
    OR              reduce using rule 61 (expr -> expr OR expr .)
    PIPE            reduce using rule 61 (expr -> expr OR expr .)
    ?               reduce using rule 61 (expr -> expr OR expr .)
    ]               reduce using rule 61 (expr -> expr OR expr .)
    ,               reduce using rule 61 (expr -> expr OR expr .)
    )               reduce using rule 61 (expr -> expr OR expr .)
    {               reduce using rule 61 (expr -> expr OR expr .)
    LET             reduce using rule 61 (expr -> expr OR expr .)
    NIL             reduce using rule 61 (expr -> expr OR expr .)
    FALSE           reduce using rule 61 (expr -> expr OR expr .)
    TRUE            reduce using rule 61 (expr -> expr OR expr .)
    STRING          reduce using rule 61 (expr -> expr OR expr .)
    FLOAT           reduce using rule 61 (expr -> expr OR expr .)
    INT             reduce using rule 61 (expr -> expr OR expr .)
    (               reduce using rule 61 (expr -> expr OR expr .)
    !               reduce using rule 61 (expr -> expr OR expr .)
    ~               reduce using rule 61 (expr -> expr OR expr .)
    ID              reduce using rule 61 (expr -> expr OR expr .)
    TYPEOF          reduce using rule 61 (expr -> expr OR expr .)
    LAMBDA          reduce using rule 61 (expr -> expr OR expr .)
    DEC             reduce using rule 61 (expr -> expr OR expr .)
    INC             reduce using rule 61 (expr -> expr OR expr .)
    CLASS           reduce using rule 61 (expr -> expr OR expr .)
    STRUCT          reduce using rule 61 (expr -> expr OR expr .)
    IF              reduce using rule 61 (expr -> expr OR expr .)
    FOR             reduce using rule 61 (expr -> expr OR expr .)
    WHILE           reduce using rule 61 (expr -> expr OR expr .)
    RETURN          reduce using rule 61 (expr -> expr OR expr .)
    FN              reduce using rule 61 (expr -> expr OR expr .)
    IMPORT          reduce using rule 61 (expr -> expr OR expr .)
    [               reduce using rule 61 (expr -> expr OR expr .)
    :               reduce using rule 61 (expr -> expr OR expr .)
    }               reduce using rule 61 (expr -> expr OR expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65


state 129

    (62) expr -> expr AND expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 62 (expr -> expr AND expr .)
    OR              reduce using rule 62 (expr -> expr AND expr .)
    AND             reduce using rule 62 (expr -> expr AND expr .)
    PIPE            reduce using rule 62 (expr -> expr AND expr .)
    ?               reduce using rule 62 (expr -> expr AND expr .)
    ]               reduce using rule 62 (expr -> expr AND expr .)
    ,               reduce using rule 62 (expr -> expr AND expr .)
    )               reduce using rule 62 (expr -> expr AND expr .)
    {               reduce using rule 62 (expr -> expr AND expr .)
    LET             reduce using rule 62 (expr -> expr AND expr .)
    NIL             reduce using rule 62 (expr -> expr AND expr .)
    FALSE           reduce using rule 62 (expr -> expr AND expr .)
    TRUE            reduce using rule 62 (expr -> expr AND expr .)
    STRING          reduce using rule 62 (expr -> expr AND expr .)
    FLOAT           reduce using rule 62 (expr -> expr AND expr .)
    INT             reduce using rule 62 (expr -> expr AND expr .)
    (               reduce using rule 62 (expr -> expr AND expr .)
    !               reduce using rule 62 (expr -> expr AND expr .)
    ~               reduce using rule 62 (expr -> expr AND expr .)
    ID              reduce using rule 62 (expr -> expr AND expr .)
    TYPEOF          reduce using rule 62 (expr -> expr AND expr .)
    LAMBDA          reduce using rule 62 (expr -> expr AND expr .)
    DEC             reduce using rule 62 (expr -> expr AND expr .)
    INC             reduce using rule 62 (expr -> expr AND expr .)
    CLASS           reduce using rule 62 (expr -> expr AND expr .)
    STRUCT          reduce using rule 62 (expr -> expr AND expr .)
    IF              reduce using rule 62 (expr -> expr AND expr .)
    FOR             reduce using rule 62 (expr -> expr AND expr .)
    WHILE           reduce using rule 62 (expr -> expr AND expr .)
    RETURN          reduce using rule 62 (expr -> expr AND expr .)
    FN              reduce using rule 62 (expr -> expr AND expr .)
    IMPORT          reduce using rule 62 (expr -> expr AND expr .)
    [               reduce using rule 62 (expr -> expr AND expr .)
    :               reduce using rule 62 (expr -> expr AND expr .)
    }               reduce using rule 62 (expr -> expr AND expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65


state 130

    (63) expr -> expr GREATEREQ expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    |               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    ^               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    &               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    GREATER         reduce using rule 63 (expr -> expr GREATEREQ expr .)
    LESS            reduce using rule 63 (expr -> expr GREATEREQ expr .)
    OR              reduce using rule 63 (expr -> expr GREATEREQ expr .)
    AND             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    GREATEREQ       reduce using rule 63 (expr -> expr GREATEREQ expr .)
    LESSEQ          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    NOTEQ           reduce using rule 63 (expr -> expr GREATEREQ expr .)
    EQEQ            reduce using rule 63 (expr -> expr GREATEREQ expr .)
    PIPE            reduce using rule 63 (expr -> expr GREATEREQ expr .)
    ?               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    ]               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    ,               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    )               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    {               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    LET             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    NIL             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    FALSE           reduce using rule 63 (expr -> expr GREATEREQ expr .)
    TRUE            reduce using rule 63 (expr -> expr GREATEREQ expr .)
    STRING          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    FLOAT           reduce using rule 63 (expr -> expr GREATEREQ expr .)
    INT             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    (               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    !               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    ~               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    ID              reduce using rule 63 (expr -> expr GREATEREQ expr .)
    TYPEOF          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    LAMBDA          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    DEC             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    INC             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    CLASS           reduce using rule 63 (expr -> expr GREATEREQ expr .)
    STRUCT          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    IF              reduce using rule 63 (expr -> expr GREATEREQ expr .)
    FOR             reduce using rule 63 (expr -> expr GREATEREQ expr .)
    WHILE           reduce using rule 63 (expr -> expr GREATEREQ expr .)
    RETURN          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    FN              reduce using rule 63 (expr -> expr GREATEREQ expr .)
    IMPORT          reduce using rule 63 (expr -> expr GREATEREQ expr .)
    [               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    :               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    }               reduce using rule 63 (expr -> expr GREATEREQ expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57


state 131

    (64) expr -> expr LESSEQ expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 64 (expr -> expr LESSEQ expr .)
    |               reduce using rule 64 (expr -> expr LESSEQ expr .)
    ^               reduce using rule 64 (expr -> expr LESSEQ expr .)
    &               reduce using rule 64 (expr -> expr LESSEQ expr .)
    GREATER         reduce using rule 64 (expr -> expr LESSEQ expr .)
    LESS            reduce using rule 64 (expr -> expr LESSEQ expr .)
    OR              reduce using rule 64 (expr -> expr LESSEQ expr .)
    AND             reduce using rule 64 (expr -> expr LESSEQ expr .)
    GREATEREQ       reduce using rule 64 (expr -> expr LESSEQ expr .)
    LESSEQ          reduce using rule 64 (expr -> expr LESSEQ expr .)
    NOTEQ           reduce using rule 64 (expr -> expr LESSEQ expr .)
    EQEQ            reduce using rule 64 (expr -> expr LESSEQ expr .)
    PIPE            reduce using rule 64 (expr -> expr LESSEQ expr .)
    ?               reduce using rule 64 (expr -> expr LESSEQ expr .)
    ]               reduce using rule 64 (expr -> expr LESSEQ expr .)
    ,               reduce using rule 64 (expr -> expr LESSEQ expr .)
    )               reduce using rule 64 (expr -> expr LESSEQ expr .)
    {               reduce using rule 64 (expr -> expr LESSEQ expr .)
    LET             reduce using rule 64 (expr -> expr LESSEQ expr .)
    NIL             reduce using rule 64 (expr -> expr LESSEQ expr .)
    FALSE           reduce using rule 64 (expr -> expr LESSEQ expr .)
    TRUE            reduce using rule 64 (expr -> expr LESSEQ expr .)
    STRING          reduce using rule 64 (expr -> expr LESSEQ expr .)
    FLOAT           reduce using rule 64 (expr -> expr LESSEQ expr .)
    INT             reduce using rule 64 (expr -> expr LESSEQ expr .)
    (               reduce using rule 64 (expr -> expr LESSEQ expr .)
    !               reduce using rule 64 (expr -> expr LESSEQ expr .)
    ~               reduce using rule 64 (expr -> expr LESSEQ expr .)
    ID              reduce using rule 64 (expr -> expr LESSEQ expr .)
    TYPEOF          reduce using rule 64 (expr -> expr LESSEQ expr .)
    LAMBDA          reduce using rule 64 (expr -> expr LESSEQ expr .)
    DEC             reduce using rule 64 (expr -> expr LESSEQ expr .)
    INC             reduce using rule 64 (expr -> expr LESSEQ expr .)
    CLASS           reduce using rule 64 (expr -> expr LESSEQ expr .)
    STRUCT          reduce using rule 64 (expr -> expr LESSEQ expr .)
    IF              reduce using rule 64 (expr -> expr LESSEQ expr .)
    FOR             reduce using rule 64 (expr -> expr LESSEQ expr .)
    WHILE           reduce using rule 64 (expr -> expr LESSEQ expr .)
    RETURN          reduce using rule 64 (expr -> expr LESSEQ expr .)
    FN              reduce using rule 64 (expr -> expr LESSEQ expr .)
    IMPORT          reduce using rule 64 (expr -> expr LESSEQ expr .)
    [               reduce using rule 64 (expr -> expr LESSEQ expr .)
    :               reduce using rule 64 (expr -> expr LESSEQ expr .)
    }               reduce using rule 64 (expr -> expr LESSEQ expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57


state 132

    (65) expr -> expr NOTEQ expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 65 (expr -> expr NOTEQ expr .)
    |               reduce using rule 65 (expr -> expr NOTEQ expr .)
    ^               reduce using rule 65 (expr -> expr NOTEQ expr .)
    &               reduce using rule 65 (expr -> expr NOTEQ expr .)
    OR              reduce using rule 65 (expr -> expr NOTEQ expr .)
    AND             reduce using rule 65 (expr -> expr NOTEQ expr .)
    NOTEQ           reduce using rule 65 (expr -> expr NOTEQ expr .)
    EQEQ            reduce using rule 65 (expr -> expr NOTEQ expr .)
    PIPE            reduce using rule 65 (expr -> expr NOTEQ expr .)
    ?               reduce using rule 65 (expr -> expr NOTEQ expr .)
    ]               reduce using rule 65 (expr -> expr NOTEQ expr .)
    ,               reduce using rule 65 (expr -> expr NOTEQ expr .)
    )               reduce using rule 65 (expr -> expr NOTEQ expr .)
    {               reduce using rule 65 (expr -> expr NOTEQ expr .)
    LET             reduce using rule 65 (expr -> expr NOTEQ expr .)
    NIL             reduce using rule 65 (expr -> expr NOTEQ expr .)
    FALSE           reduce using rule 65 (expr -> expr NOTEQ expr .)
    TRUE            reduce using rule 65 (expr -> expr NOTEQ expr .)
    STRING          reduce using rule 65 (expr -> expr NOTEQ expr .)
    FLOAT           reduce using rule 65 (expr -> expr NOTEQ expr .)
    INT             reduce using rule 65 (expr -> expr NOTEQ expr .)
    (               reduce using rule 65 (expr -> expr NOTEQ expr .)
    !               reduce using rule 65 (expr -> expr NOTEQ expr .)
    ~               reduce using rule 65 (expr -> expr NOTEQ expr .)
    ID              reduce using rule 65 (expr -> expr NOTEQ expr .)
    TYPEOF          reduce using rule 65 (expr -> expr NOTEQ expr .)
    LAMBDA          reduce using rule 65 (expr -> expr NOTEQ expr .)
    DEC             reduce using rule 65 (expr -> expr NOTEQ expr .)
    INC             reduce using rule 65 (expr -> expr NOTEQ expr .)
    CLASS           reduce using rule 65 (expr -> expr NOTEQ expr .)
    STRUCT          reduce using rule 65 (expr -> expr NOTEQ expr .)
    IF              reduce using rule 65 (expr -> expr NOTEQ expr .)
    FOR             reduce using rule 65 (expr -> expr NOTEQ expr .)
    WHILE           reduce using rule 65 (expr -> expr NOTEQ expr .)
    RETURN          reduce using rule 65 (expr -> expr NOTEQ expr .)
    FN              reduce using rule 65 (expr -> expr NOTEQ expr .)
    IMPORT          reduce using rule 65 (expr -> expr NOTEQ expr .)
    [               reduce using rule 65 (expr -> expr NOTEQ expr .)
    :               reduce using rule 65 (expr -> expr NOTEQ expr .)
    }               reduce using rule 65 (expr -> expr NOTEQ expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63


state 133

    (66) expr -> expr EQEQ expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 66 (expr -> expr EQEQ expr .)
    |               reduce using rule 66 (expr -> expr EQEQ expr .)
    ^               reduce using rule 66 (expr -> expr EQEQ expr .)
    &               reduce using rule 66 (expr -> expr EQEQ expr .)
    OR              reduce using rule 66 (expr -> expr EQEQ expr .)
    AND             reduce using rule 66 (expr -> expr EQEQ expr .)
    NOTEQ           reduce using rule 66 (expr -> expr EQEQ expr .)
    EQEQ            reduce using rule 66 (expr -> expr EQEQ expr .)
    PIPE            reduce using rule 66 (expr -> expr EQEQ expr .)
    ?               reduce using rule 66 (expr -> expr EQEQ expr .)
    ]               reduce using rule 66 (expr -> expr EQEQ expr .)
    ,               reduce using rule 66 (expr -> expr EQEQ expr .)
    )               reduce using rule 66 (expr -> expr EQEQ expr .)
    {               reduce using rule 66 (expr -> expr EQEQ expr .)
    LET             reduce using rule 66 (expr -> expr EQEQ expr .)
    NIL             reduce using rule 66 (expr -> expr EQEQ expr .)
    FALSE           reduce using rule 66 (expr -> expr EQEQ expr .)
    TRUE            reduce using rule 66 (expr -> expr EQEQ expr .)
    STRING          reduce using rule 66 (expr -> expr EQEQ expr .)
    FLOAT           reduce using rule 66 (expr -> expr EQEQ expr .)
    INT             reduce using rule 66 (expr -> expr EQEQ expr .)
    (               reduce using rule 66 (expr -> expr EQEQ expr .)
    !               reduce using rule 66 (expr -> expr EQEQ expr .)
    ~               reduce using rule 66 (expr -> expr EQEQ expr .)
    ID              reduce using rule 66 (expr -> expr EQEQ expr .)
    TYPEOF          reduce using rule 66 (expr -> expr EQEQ expr .)
    LAMBDA          reduce using rule 66 (expr -> expr EQEQ expr .)
    DEC             reduce using rule 66 (expr -> expr EQEQ expr .)
    INC             reduce using rule 66 (expr -> expr EQEQ expr .)
    CLASS           reduce using rule 66 (expr -> expr EQEQ expr .)
    STRUCT          reduce using rule 66 (expr -> expr EQEQ expr .)
    IF              reduce using rule 66 (expr -> expr EQEQ expr .)
    FOR             reduce using rule 66 (expr -> expr EQEQ expr .)
    WHILE           reduce using rule 66 (expr -> expr EQEQ expr .)
    RETURN          reduce using rule 66 (expr -> expr EQEQ expr .)
    FN              reduce using rule 66 (expr -> expr EQEQ expr .)
    IMPORT          reduce using rule 66 (expr -> expr EQEQ expr .)
    [               reduce using rule 66 (expr -> expr EQEQ expr .)
    :               reduce using rule 66 (expr -> expr EQEQ expr .)
    }               reduce using rule 66 (expr -> expr EQEQ expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63


state 134

    (67) expr -> expr PIPE ID . ( args )
    (               shift and go to state 181


state 135

    (70) expr -> expr ? expr . : expr
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    :               shift and go to state 182
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 136

    (7) statement -> LET var : . var_type SEP
    (25) var_type -> . DICT_TYPE
    (26) var_type -> . LIST_TYPE
    (27) var_type -> . BOOL_TYPE
    (28) var_type -> . STRING_TYPE
    (29) var_type -> . FLOAT_TYPE
    (30) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 184
    LIST_TYPE       shift and go to state 185
    BOOL_TYPE       shift and go to state 186
    STRING_TYPE     shift and go to state 187
    FLOAT_TYPE      shift and go to state 188
    INT_TYPE        shift and go to state 189

    var_type                       shift and go to state 183

state 137

    (77) var_define -> LET var ASSIGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 190
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 138

    (100) var -> var [ . expr ]
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    var                            shift and go to state 93
    expr                           shift and go to state 191
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 139

    (76) var_define -> LET getter ASSIGN . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    getter                         shift and go to state 18
    expr                           shift and go to state 192
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 140

    (37) expr -> var [ expr . ]
    (100) var -> var [ expr . ]
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    ]               shift and go to state 193
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 141

    (81) var_assign -> var SHRASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    {               reduce using rule 81 (var_assign -> var SHRASGN expr .)
    LET             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    NIL             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    FALSE           reduce using rule 81 (var_assign -> var SHRASGN expr .)
    TRUE            reduce using rule 81 (var_assign -> var SHRASGN expr .)
    STRING          reduce using rule 81 (var_assign -> var SHRASGN expr .)
    FLOAT           reduce using rule 81 (var_assign -> var SHRASGN expr .)
    INT             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    (               reduce using rule 81 (var_assign -> var SHRASGN expr .)
    !               reduce using rule 81 (var_assign -> var SHRASGN expr .)
    ~               reduce using rule 81 (var_assign -> var SHRASGN expr .)
    ID              reduce using rule 81 (var_assign -> var SHRASGN expr .)
    TYPEOF          reduce using rule 81 (var_assign -> var SHRASGN expr .)
    LAMBDA          reduce using rule 81 (var_assign -> var SHRASGN expr .)
    DEC             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    INC             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    CLASS           reduce using rule 81 (var_assign -> var SHRASGN expr .)
    STRUCT          reduce using rule 81 (var_assign -> var SHRASGN expr .)
    IF              reduce using rule 81 (var_assign -> var SHRASGN expr .)
    FOR             reduce using rule 81 (var_assign -> var SHRASGN expr .)
    WHILE           reduce using rule 81 (var_assign -> var SHRASGN expr .)
    RETURN          reduce using rule 81 (var_assign -> var SHRASGN expr .)
    FN              reduce using rule 81 (var_assign -> var SHRASGN expr .)
    IMPORT          reduce using rule 81 (var_assign -> var SHRASGN expr .)
    [               reduce using rule 81 (var_assign -> var SHRASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 142

    (82) var_assign -> var SHLASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    {               reduce using rule 82 (var_assign -> var SHLASGN expr .)
    LET             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    NIL             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    FALSE           reduce using rule 82 (var_assign -> var SHLASGN expr .)
    TRUE            reduce using rule 82 (var_assign -> var SHLASGN expr .)
    STRING          reduce using rule 82 (var_assign -> var SHLASGN expr .)
    FLOAT           reduce using rule 82 (var_assign -> var SHLASGN expr .)
    INT             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    (               reduce using rule 82 (var_assign -> var SHLASGN expr .)
    !               reduce using rule 82 (var_assign -> var SHLASGN expr .)
    ~               reduce using rule 82 (var_assign -> var SHLASGN expr .)
    ID              reduce using rule 82 (var_assign -> var SHLASGN expr .)
    TYPEOF          reduce using rule 82 (var_assign -> var SHLASGN expr .)
    LAMBDA          reduce using rule 82 (var_assign -> var SHLASGN expr .)
    DEC             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    INC             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    CLASS           reduce using rule 82 (var_assign -> var SHLASGN expr .)
    STRUCT          reduce using rule 82 (var_assign -> var SHLASGN expr .)
    IF              reduce using rule 82 (var_assign -> var SHLASGN expr .)
    FOR             reduce using rule 82 (var_assign -> var SHLASGN expr .)
    WHILE           reduce using rule 82 (var_assign -> var SHLASGN expr .)
    RETURN          reduce using rule 82 (var_assign -> var SHLASGN expr .)
    FN              reduce using rule 82 (var_assign -> var SHLASGN expr .)
    IMPORT          reduce using rule 82 (var_assign -> var SHLASGN expr .)
    [               reduce using rule 82 (var_assign -> var SHLASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 143

    (83) var_assign -> var XORASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 83 (var_assign -> var XORASGN expr .)
    {               reduce using rule 83 (var_assign -> var XORASGN expr .)
    LET             reduce using rule 83 (var_assign -> var XORASGN expr .)
    NIL             reduce using rule 83 (var_assign -> var XORASGN expr .)
    FALSE           reduce using rule 83 (var_assign -> var XORASGN expr .)
    TRUE            reduce using rule 83 (var_assign -> var XORASGN expr .)
    STRING          reduce using rule 83 (var_assign -> var XORASGN expr .)
    FLOAT           reduce using rule 83 (var_assign -> var XORASGN expr .)
    INT             reduce using rule 83 (var_assign -> var XORASGN expr .)
    (               reduce using rule 83 (var_assign -> var XORASGN expr .)
    !               reduce using rule 83 (var_assign -> var XORASGN expr .)
    ~               reduce using rule 83 (var_assign -> var XORASGN expr .)
    ID              reduce using rule 83 (var_assign -> var XORASGN expr .)
    TYPEOF          reduce using rule 83 (var_assign -> var XORASGN expr .)
    LAMBDA          reduce using rule 83 (var_assign -> var XORASGN expr .)
    DEC             reduce using rule 83 (var_assign -> var XORASGN expr .)
    INC             reduce using rule 83 (var_assign -> var XORASGN expr .)
    CLASS           reduce using rule 83 (var_assign -> var XORASGN expr .)
    STRUCT          reduce using rule 83 (var_assign -> var XORASGN expr .)
    IF              reduce using rule 83 (var_assign -> var XORASGN expr .)
    FOR             reduce using rule 83 (var_assign -> var XORASGN expr .)
    WHILE           reduce using rule 83 (var_assign -> var XORASGN expr .)
    RETURN          reduce using rule 83 (var_assign -> var XORASGN expr .)
    FN              reduce using rule 83 (var_assign -> var XORASGN expr .)
    IMPORT          reduce using rule 83 (var_assign -> var XORASGN expr .)
    [               reduce using rule 83 (var_assign -> var XORASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 144

    (84) var_assign -> var ORASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 84 (var_assign -> var ORASGN expr .)
    {               reduce using rule 84 (var_assign -> var ORASGN expr .)
    LET             reduce using rule 84 (var_assign -> var ORASGN expr .)
    NIL             reduce using rule 84 (var_assign -> var ORASGN expr .)
    FALSE           reduce using rule 84 (var_assign -> var ORASGN expr .)
    TRUE            reduce using rule 84 (var_assign -> var ORASGN expr .)
    STRING          reduce using rule 84 (var_assign -> var ORASGN expr .)
    FLOAT           reduce using rule 84 (var_assign -> var ORASGN expr .)
    INT             reduce using rule 84 (var_assign -> var ORASGN expr .)
    (               reduce using rule 84 (var_assign -> var ORASGN expr .)
    !               reduce using rule 84 (var_assign -> var ORASGN expr .)
    ~               reduce using rule 84 (var_assign -> var ORASGN expr .)
    ID              reduce using rule 84 (var_assign -> var ORASGN expr .)
    TYPEOF          reduce using rule 84 (var_assign -> var ORASGN expr .)
    LAMBDA          reduce using rule 84 (var_assign -> var ORASGN expr .)
    DEC             reduce using rule 84 (var_assign -> var ORASGN expr .)
    INC             reduce using rule 84 (var_assign -> var ORASGN expr .)
    CLASS           reduce using rule 84 (var_assign -> var ORASGN expr .)
    STRUCT          reduce using rule 84 (var_assign -> var ORASGN expr .)
    IF              reduce using rule 84 (var_assign -> var ORASGN expr .)
    FOR             reduce using rule 84 (var_assign -> var ORASGN expr .)
    WHILE           reduce using rule 84 (var_assign -> var ORASGN expr .)
    RETURN          reduce using rule 84 (var_assign -> var ORASGN expr .)
    FN              reduce using rule 84 (var_assign -> var ORASGN expr .)
    IMPORT          reduce using rule 84 (var_assign -> var ORASGN expr .)
    [               reduce using rule 84 (var_assign -> var ORASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 145

    (85) var_assign -> var ANDASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    {               reduce using rule 85 (var_assign -> var ANDASGN expr .)
    LET             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    NIL             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    FALSE           reduce using rule 85 (var_assign -> var ANDASGN expr .)
    TRUE            reduce using rule 85 (var_assign -> var ANDASGN expr .)
    STRING          reduce using rule 85 (var_assign -> var ANDASGN expr .)
    FLOAT           reduce using rule 85 (var_assign -> var ANDASGN expr .)
    INT             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    (               reduce using rule 85 (var_assign -> var ANDASGN expr .)
    !               reduce using rule 85 (var_assign -> var ANDASGN expr .)
    ~               reduce using rule 85 (var_assign -> var ANDASGN expr .)
    ID              reduce using rule 85 (var_assign -> var ANDASGN expr .)
    TYPEOF          reduce using rule 85 (var_assign -> var ANDASGN expr .)
    LAMBDA          reduce using rule 85 (var_assign -> var ANDASGN expr .)
    DEC             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    INC             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    CLASS           reduce using rule 85 (var_assign -> var ANDASGN expr .)
    STRUCT          reduce using rule 85 (var_assign -> var ANDASGN expr .)
    IF              reduce using rule 85 (var_assign -> var ANDASGN expr .)
    FOR             reduce using rule 85 (var_assign -> var ANDASGN expr .)
    WHILE           reduce using rule 85 (var_assign -> var ANDASGN expr .)
    RETURN          reduce using rule 85 (var_assign -> var ANDASGN expr .)
    FN              reduce using rule 85 (var_assign -> var ANDASGN expr .)
    IMPORT          reduce using rule 85 (var_assign -> var ANDASGN expr .)
    [               reduce using rule 85 (var_assign -> var ANDASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 146

    (86) var_assign -> var MODULOASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    {               reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    LET             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    NIL             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    FALSE           reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    TRUE            reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    STRING          reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    FLOAT           reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    INT             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    (               reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    !               reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    ~               reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    ID              reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    TYPEOF          reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    LAMBDA          reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    DEC             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    INC             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    CLASS           reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    STRUCT          reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    IF              reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    FOR             reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    WHILE           reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    RETURN          reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    FN              reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    IMPORT          reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    [               reduce using rule 86 (var_assign -> var MODULOASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 147

    (87) var_assign -> var SLASHASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    {               reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    LET             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    NIL             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    FALSE           reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    TRUE            reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    STRING          reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    FLOAT           reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    INT             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    (               reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    !               reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    ~               reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    ID              reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    TYPEOF          reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    LAMBDA          reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    DEC             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    INC             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    CLASS           reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    STRUCT          reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    IF              reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    FOR             reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    WHILE           reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    RETURN          reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    FN              reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    IMPORT          reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    [               reduce using rule 87 (var_assign -> var SLASHASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 148

    (88) var_assign -> var STARASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 88 (var_assign -> var STARASGN expr .)
    {               reduce using rule 88 (var_assign -> var STARASGN expr .)
    LET             reduce using rule 88 (var_assign -> var STARASGN expr .)
    NIL             reduce using rule 88 (var_assign -> var STARASGN expr .)
    FALSE           reduce using rule 88 (var_assign -> var STARASGN expr .)
    TRUE            reduce using rule 88 (var_assign -> var STARASGN expr .)
    STRING          reduce using rule 88 (var_assign -> var STARASGN expr .)
    FLOAT           reduce using rule 88 (var_assign -> var STARASGN expr .)
    INT             reduce using rule 88 (var_assign -> var STARASGN expr .)
    (               reduce using rule 88 (var_assign -> var STARASGN expr .)
    !               reduce using rule 88 (var_assign -> var STARASGN expr .)
    ~               reduce using rule 88 (var_assign -> var STARASGN expr .)
    ID              reduce using rule 88 (var_assign -> var STARASGN expr .)
    TYPEOF          reduce using rule 88 (var_assign -> var STARASGN expr .)
    LAMBDA          reduce using rule 88 (var_assign -> var STARASGN expr .)
    DEC             reduce using rule 88 (var_assign -> var STARASGN expr .)
    INC             reduce using rule 88 (var_assign -> var STARASGN expr .)
    CLASS           reduce using rule 88 (var_assign -> var STARASGN expr .)
    STRUCT          reduce using rule 88 (var_assign -> var STARASGN expr .)
    IF              reduce using rule 88 (var_assign -> var STARASGN expr .)
    FOR             reduce using rule 88 (var_assign -> var STARASGN expr .)
    WHILE           reduce using rule 88 (var_assign -> var STARASGN expr .)
    RETURN          reduce using rule 88 (var_assign -> var STARASGN expr .)
    FN              reduce using rule 88 (var_assign -> var STARASGN expr .)
    IMPORT          reduce using rule 88 (var_assign -> var STARASGN expr .)
    [               reduce using rule 88 (var_assign -> var STARASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 149

    (89) var_assign -> var MINUSASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    {               reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    LET             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    NIL             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    FALSE           reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    TRUE            reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    STRING          reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    FLOAT           reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    INT             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    (               reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    !               reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    ~               reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    ID              reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    TYPEOF          reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    LAMBDA          reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    DEC             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    INC             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    CLASS           reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    STRUCT          reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    IF              reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    FOR             reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    WHILE           reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    RETURN          reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    FN              reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    IMPORT          reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    [               reduce using rule 89 (var_assign -> var MINUSASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 150

    (90) var_assign -> var PLUSASGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    {               reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    LET             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    NIL             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    FALSE           reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    TRUE            reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    STRING          reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    FLOAT           reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    INT             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    (               reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    !               reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    ~               reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    ID              reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    TYPEOF          reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    LAMBDA          reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    DEC             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    INC             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    CLASS           reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    STRUCT          reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    IF              reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    FOR             reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    WHILE           reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    RETURN          reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    FN              reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    IMPORT          reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    [               reduce using rule 90 (var_assign -> var PLUSASGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 151

    (91) var_assign -> var ASSIGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    SEP             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    {               reduce using rule 91 (var_assign -> var ASSIGN expr .)
    LET             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    NIL             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    FALSE           reduce using rule 91 (var_assign -> var ASSIGN expr .)
    TRUE            reduce using rule 91 (var_assign -> var ASSIGN expr .)
    STRING          reduce using rule 91 (var_assign -> var ASSIGN expr .)
    FLOAT           reduce using rule 91 (var_assign -> var ASSIGN expr .)
    INT             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    (               reduce using rule 91 (var_assign -> var ASSIGN expr .)
    !               reduce using rule 91 (var_assign -> var ASSIGN expr .)
    ~               reduce using rule 91 (var_assign -> var ASSIGN expr .)
    ID              reduce using rule 91 (var_assign -> var ASSIGN expr .)
    TYPEOF          reduce using rule 91 (var_assign -> var ASSIGN expr .)
    LAMBDA          reduce using rule 91 (var_assign -> var ASSIGN expr .)
    DEC             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    INC             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    CLASS           reduce using rule 91 (var_assign -> var ASSIGN expr .)
    STRUCT          reduce using rule 91 (var_assign -> var ASSIGN expr .)
    IF              reduce using rule 91 (var_assign -> var ASSIGN expr .)
    FOR             reduce using rule 91 (var_assign -> var ASSIGN expr .)
    WHILE           reduce using rule 91 (var_assign -> var ASSIGN expr .)
    RETURN          reduce using rule 91 (var_assign -> var ASSIGN expr .)
    FN              reduce using rule 91 (var_assign -> var ASSIGN expr .)
    IMPORT          reduce using rule 91 (var_assign -> var ASSIGN expr .)
    [               reduce using rule 91 (var_assign -> var ASSIGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 152

    (118) getter -> getter . ID .
    .               reduce using rule 118 (getter -> getter . ID .)
    SEP             reduce using rule 118 (getter -> getter . ID .)
    %               reduce using rule 118 (getter -> getter . ID .)
    /               reduce using rule 118 (getter -> getter . ID .)
    *               reduce using rule 118 (getter -> getter . ID .)
    -               reduce using rule 118 (getter -> getter . ID .)
    +               reduce using rule 118 (getter -> getter . ID .)
    |               reduce using rule 118 (getter -> getter . ID .)
    ^               reduce using rule 118 (getter -> getter . ID .)
    &               reduce using rule 118 (getter -> getter . ID .)
    SHR             reduce using rule 118 (getter -> getter . ID .)
    SHL             reduce using rule 118 (getter -> getter . ID .)
    GREATER         reduce using rule 118 (getter -> getter . ID .)
    LESS            reduce using rule 118 (getter -> getter . ID .)
    OR              reduce using rule 118 (getter -> getter . ID .)
    AND             reduce using rule 118 (getter -> getter . ID .)
    GREATEREQ       reduce using rule 118 (getter -> getter . ID .)
    LESSEQ          reduce using rule 118 (getter -> getter . ID .)
    NOTEQ           reduce using rule 118 (getter -> getter . ID .)
    EQEQ            reduce using rule 118 (getter -> getter . ID .)
    PIPE            reduce using rule 118 (getter -> getter . ID .)
    ?               reduce using rule 118 (getter -> getter . ID .)
    ASSIGN          reduce using rule 118 (getter -> getter . ID .)
    ]               reduce using rule 118 (getter -> getter . ID .)
    ,               reduce using rule 118 (getter -> getter . ID .)
    )               reduce using rule 118 (getter -> getter . ID .)
    {               reduce using rule 118 (getter -> getter . ID .)
    LET             reduce using rule 118 (getter -> getter . ID .)
    NIL             reduce using rule 118 (getter -> getter . ID .)
    FALSE           reduce using rule 118 (getter -> getter . ID .)
    TRUE            reduce using rule 118 (getter -> getter . ID .)
    STRING          reduce using rule 118 (getter -> getter . ID .)
    FLOAT           reduce using rule 118 (getter -> getter . ID .)
    INT             reduce using rule 118 (getter -> getter . ID .)
    (               reduce using rule 118 (getter -> getter . ID .)
    !               reduce using rule 118 (getter -> getter . ID .)
    ~               reduce using rule 118 (getter -> getter . ID .)
    ID              reduce using rule 118 (getter -> getter . ID .)
    TYPEOF          reduce using rule 118 (getter -> getter . ID .)
    LAMBDA          reduce using rule 118 (getter -> getter . ID .)
    DEC             reduce using rule 118 (getter -> getter . ID .)
    INC             reduce using rule 118 (getter -> getter . ID .)
    CLASS           reduce using rule 118 (getter -> getter . ID .)
    STRUCT          reduce using rule 118 (getter -> getter . ID .)
    IF              reduce using rule 118 (getter -> getter . ID .)
    FOR             reduce using rule 118 (getter -> getter . ID .)
    WHILE           reduce using rule 118 (getter -> getter . ID .)
    RETURN          reduce using rule 118 (getter -> getter . ID .)
    FN              reduce using rule 118 (getter -> getter . ID .)
    IMPORT          reduce using rule 118 (getter -> getter . ID .)
    [               reduce using rule 118 (getter -> getter . ID .)
    :               reduce using rule 118 (getter -> getter . ID .)
    }               reduce using rule 118 (getter -> getter . ID .)


state 153

    (34) expr -> { member_list } .
    SEP             reduce using rule 34 (expr -> { member_list } .)
    %               reduce using rule 34 (expr -> { member_list } .)
    /               reduce using rule 34 (expr -> { member_list } .)
    *               reduce using rule 34 (expr -> { member_list } .)
    -               reduce using rule 34 (expr -> { member_list } .)
    +               reduce using rule 34 (expr -> { member_list } .)
    |               reduce using rule 34 (expr -> { member_list } .)
    ^               reduce using rule 34 (expr -> { member_list } .)
    &               reduce using rule 34 (expr -> { member_list } .)
    SHR             reduce using rule 34 (expr -> { member_list } .)
    SHL             reduce using rule 34 (expr -> { member_list } .)
    GREATER         reduce using rule 34 (expr -> { member_list } .)
    LESS            reduce using rule 34 (expr -> { member_list } .)
    OR              reduce using rule 34 (expr -> { member_list } .)
    AND             reduce using rule 34 (expr -> { member_list } .)
    GREATEREQ       reduce using rule 34 (expr -> { member_list } .)
    LESSEQ          reduce using rule 34 (expr -> { member_list } .)
    NOTEQ           reduce using rule 34 (expr -> { member_list } .)
    EQEQ            reduce using rule 34 (expr -> { member_list } .)
    PIPE            reduce using rule 34 (expr -> { member_list } .)
    ?               reduce using rule 34 (expr -> { member_list } .)
    ]               reduce using rule 34 (expr -> { member_list } .)
    ,               reduce using rule 34 (expr -> { member_list } .)
    )               reduce using rule 34 (expr -> { member_list } .)
    {               reduce using rule 34 (expr -> { member_list } .)
    LET             reduce using rule 34 (expr -> { member_list } .)
    NIL             reduce using rule 34 (expr -> { member_list } .)
    FALSE           reduce using rule 34 (expr -> { member_list } .)
    TRUE            reduce using rule 34 (expr -> { member_list } .)
    STRING          reduce using rule 34 (expr -> { member_list } .)
    FLOAT           reduce using rule 34 (expr -> { member_list } .)
    INT             reduce using rule 34 (expr -> { member_list } .)
    (               reduce using rule 34 (expr -> { member_list } .)
    !               reduce using rule 34 (expr -> { member_list } .)
    ~               reduce using rule 34 (expr -> { member_list } .)
    ID              reduce using rule 34 (expr -> { member_list } .)
    TYPEOF          reduce using rule 34 (expr -> { member_list } .)
    LAMBDA          reduce using rule 34 (expr -> { member_list } .)
    DEC             reduce using rule 34 (expr -> { member_list } .)
    INC             reduce using rule 34 (expr -> { member_list } .)
    CLASS           reduce using rule 34 (expr -> { member_list } .)
    STRUCT          reduce using rule 34 (expr -> { member_list } .)
    IF              reduce using rule 34 (expr -> { member_list } .)
    FOR             reduce using rule 34 (expr -> { member_list } .)
    WHILE           reduce using rule 34 (expr -> { member_list } .)
    RETURN          reduce using rule 34 (expr -> { member_list } .)
    FN              reduce using rule 34 (expr -> { member_list } .)
    IMPORT          reduce using rule 34 (expr -> { member_list } .)
    [               reduce using rule 34 (expr -> { member_list } .)
    :               reduce using rule 34 (expr -> { member_list } .)
    }               reduce using rule 34 (expr -> { member_list } .)


state 154

    (113) member_list -> member_list , . member
    (116) member -> . STRING : expr
    STRING          shift and go to state 89

    member                         shift and go to state 194

state 155

    (116) member -> STRING : . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 195
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 156

    (96) list_val -> [ exprs ] .
    SEP             reduce using rule 96 (list_val -> [ exprs ] .)
    %               reduce using rule 96 (list_val -> [ exprs ] .)
    /               reduce using rule 96 (list_val -> [ exprs ] .)
    *               reduce using rule 96 (list_val -> [ exprs ] .)
    -               reduce using rule 96 (list_val -> [ exprs ] .)
    +               reduce using rule 96 (list_val -> [ exprs ] .)
    |               reduce using rule 96 (list_val -> [ exprs ] .)
    ^               reduce using rule 96 (list_val -> [ exprs ] .)
    &               reduce using rule 96 (list_val -> [ exprs ] .)
    SHR             reduce using rule 96 (list_val -> [ exprs ] .)
    SHL             reduce using rule 96 (list_val -> [ exprs ] .)
    GREATER         reduce using rule 96 (list_val -> [ exprs ] .)
    LESS            reduce using rule 96 (list_val -> [ exprs ] .)
    OR              reduce using rule 96 (list_val -> [ exprs ] .)
    AND             reduce using rule 96 (list_val -> [ exprs ] .)
    GREATEREQ       reduce using rule 96 (list_val -> [ exprs ] .)
    LESSEQ          reduce using rule 96 (list_val -> [ exprs ] .)
    NOTEQ           reduce using rule 96 (list_val -> [ exprs ] .)
    EQEQ            reduce using rule 96 (list_val -> [ exprs ] .)
    PIPE            reduce using rule 96 (list_val -> [ exprs ] .)
    ?               reduce using rule 96 (list_val -> [ exprs ] .)
    ]               reduce using rule 96 (list_val -> [ exprs ] .)
    ,               reduce using rule 96 (list_val -> [ exprs ] .)
    )               reduce using rule 96 (list_val -> [ exprs ] .)
    {               reduce using rule 96 (list_val -> [ exprs ] .)
    LET             reduce using rule 96 (list_val -> [ exprs ] .)
    NIL             reduce using rule 96 (list_val -> [ exprs ] .)
    FALSE           reduce using rule 96 (list_val -> [ exprs ] .)
    TRUE            reduce using rule 96 (list_val -> [ exprs ] .)
    STRING          reduce using rule 96 (list_val -> [ exprs ] .)
    FLOAT           reduce using rule 96 (list_val -> [ exprs ] .)
    INT             reduce using rule 96 (list_val -> [ exprs ] .)
    (               reduce using rule 96 (list_val -> [ exprs ] .)
    !               reduce using rule 96 (list_val -> [ exprs ] .)
    ~               reduce using rule 96 (list_val -> [ exprs ] .)
    ID              reduce using rule 96 (list_val -> [ exprs ] .)
    TYPEOF          reduce using rule 96 (list_val -> [ exprs ] .)
    LAMBDA          reduce using rule 96 (list_val -> [ exprs ] .)
    DEC             reduce using rule 96 (list_val -> [ exprs ] .)
    INC             reduce using rule 96 (list_val -> [ exprs ] .)
    CLASS           reduce using rule 96 (list_val -> [ exprs ] .)
    STRUCT          reduce using rule 96 (list_val -> [ exprs ] .)
    IF              reduce using rule 96 (list_val -> [ exprs ] .)
    FOR             reduce using rule 96 (list_val -> [ exprs ] .)
    WHILE           reduce using rule 96 (list_val -> [ exprs ] .)
    RETURN          reduce using rule 96 (list_val -> [ exprs ] .)
    FN              reduce using rule 96 (list_val -> [ exprs ] .)
    IMPORT          reduce using rule 96 (list_val -> [ exprs ] .)
    [               reduce using rule 96 (list_val -> [ exprs ] .)
    :               reduce using rule 96 (list_val -> [ exprs ] .)
    }               reduce using rule 96 (list_val -> [ exprs ] .)


state 157

    (97) exprs -> exprs , . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 196
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 158

    (44) expr -> ( expr ) .
    SEP             reduce using rule 44 (expr -> ( expr ) .)
    %               reduce using rule 44 (expr -> ( expr ) .)
    /               reduce using rule 44 (expr -> ( expr ) .)
    *               reduce using rule 44 (expr -> ( expr ) .)
    -               reduce using rule 44 (expr -> ( expr ) .)
    +               reduce using rule 44 (expr -> ( expr ) .)
    |               reduce using rule 44 (expr -> ( expr ) .)
    ^               reduce using rule 44 (expr -> ( expr ) .)
    &               reduce using rule 44 (expr -> ( expr ) .)
    SHR             reduce using rule 44 (expr -> ( expr ) .)
    SHL             reduce using rule 44 (expr -> ( expr ) .)
    GREATER         reduce using rule 44 (expr -> ( expr ) .)
    LESS            reduce using rule 44 (expr -> ( expr ) .)
    OR              reduce using rule 44 (expr -> ( expr ) .)
    AND             reduce using rule 44 (expr -> ( expr ) .)
    GREATEREQ       reduce using rule 44 (expr -> ( expr ) .)
    LESSEQ          reduce using rule 44 (expr -> ( expr ) .)
    NOTEQ           reduce using rule 44 (expr -> ( expr ) .)
    EQEQ            reduce using rule 44 (expr -> ( expr ) .)
    PIPE            reduce using rule 44 (expr -> ( expr ) .)
    ?               reduce using rule 44 (expr -> ( expr ) .)
    ]               reduce using rule 44 (expr -> ( expr ) .)
    ,               reduce using rule 44 (expr -> ( expr ) .)
    )               reduce using rule 44 (expr -> ( expr ) .)
    {               reduce using rule 44 (expr -> ( expr ) .)
    LET             reduce using rule 44 (expr -> ( expr ) .)
    NIL             reduce using rule 44 (expr -> ( expr ) .)
    FALSE           reduce using rule 44 (expr -> ( expr ) .)
    TRUE            reduce using rule 44 (expr -> ( expr ) .)
    STRING          reduce using rule 44 (expr -> ( expr ) .)
    FLOAT           reduce using rule 44 (expr -> ( expr ) .)
    INT             reduce using rule 44 (expr -> ( expr ) .)
    (               reduce using rule 44 (expr -> ( expr ) .)
    !               reduce using rule 44 (expr -> ( expr ) .)
    ~               reduce using rule 44 (expr -> ( expr ) .)
    ID              reduce using rule 44 (expr -> ( expr ) .)
    TYPEOF          reduce using rule 44 (expr -> ( expr ) .)
    LAMBDA          reduce using rule 44 (expr -> ( expr ) .)
    DEC             reduce using rule 44 (expr -> ( expr ) .)
    INC             reduce using rule 44 (expr -> ( expr ) .)
    CLASS           reduce using rule 44 (expr -> ( expr ) .)
    STRUCT          reduce using rule 44 (expr -> ( expr ) .)
    IF              reduce using rule 44 (expr -> ( expr ) .)
    FOR             reduce using rule 44 (expr -> ( expr ) .)
    WHILE           reduce using rule 44 (expr -> ( expr ) .)
    RETURN          reduce using rule 44 (expr -> ( expr ) .)
    FN              reduce using rule 44 (expr -> ( expr ) .)
    IMPORT          reduce using rule 44 (expr -> ( expr ) .)
    [               reduce using rule 44 (expr -> ( expr ) .)
    :               reduce using rule 44 (expr -> ( expr ) .)
    }               reduce using rule 44 (expr -> ( expr ) .)


state 159

    (68) expr -> ID DOUBLECOLON ID . ( args )
    (               shift and go to state 197


state 160

    (69) expr -> ID ( args . )
    (111) args -> args . , arg
    )               shift and go to state 198
    ,               shift and go to state 199


state 161

    (109) args -> empty .
    )               reduce using rule 109 (args -> empty .)
    ,               reduce using rule 109 (args -> empty .)


state 162

    (110) args -> arg .
    )               reduce using rule 110 (args -> arg .)
    ,               reduce using rule 110 (args -> arg .)


state 163

    (112) arg -> expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    )               reduce using rule 112 (arg -> expr .)
    ,               reduce using rule 112 (arg -> expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 164

    (73) expr -> ID LEFTARROW { . struct_init_exprs }
    (74) struct_init_exprs -> . struct_init_exprs , expr
    (75) struct_init_exprs -> . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    struct_init_exprs              shift and go to state 200
    expr                           shift and go to state 201
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 165

    (72) expr -> LAMBDA ( params . ) ARROW expr
    (107) params -> params . , param
    )               shift and go to state 202
    ,               shift and go to state 203


state 166

    (105) params -> empty .
    )               reduce using rule 105 (params -> empty .)
    ,               reduce using rule 105 (params -> empty .)


state 167

    (106) params -> param .
    )               reduce using rule 106 (params -> param .)
    ,               reduce using rule 106 (params -> param .)


state 168

    (108) param -> ID . : var_type
    :               shift and go to state 204


state 169

    (17) class_definition -> CLASS ID { . function_definitions }
    (18) function_definitions -> . function_definitions function_definition
    (19) function_definitions -> . function_definition
    (20) function_definitions -> . empty
    (32) function_definition -> . FN ID ( params ) block
    (102) empty -> .
  ! shift/reduce conflict for FN resolved as shift
    FN              shift and go to state 44
    }               reduce using rule 102 (empty -> .)

    function_definitions           shift and go to state 205
    function_definition            shift and go to state 206
    empty                          shift and go to state 207

state 170

    (21) struct_definition -> STRUCT ID { . struct_fields } SEP
    (22) struct_fields -> . struct_fields struct_field
    (23) struct_fields -> . struct_field
    (24) struct_field -> . LET ID : var_type SEP
    LET             shift and go to state 210

    struct_fields                  shift and go to state 208
    struct_field                   shift and go to state 209

state 171

    (92) if_statement -> IF expr block .
    (93) if_statement -> IF expr block . ELSE block
  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 92 (if_statement -> IF expr block .)
    {               reduce using rule 92 (if_statement -> IF expr block .)
    NIL             reduce using rule 92 (if_statement -> IF expr block .)
    FALSE           reduce using rule 92 (if_statement -> IF expr block .)
    TRUE            reduce using rule 92 (if_statement -> IF expr block .)
    STRING          reduce using rule 92 (if_statement -> IF expr block .)
    FLOAT           reduce using rule 92 (if_statement -> IF expr block .)
    INT             reduce using rule 92 (if_statement -> IF expr block .)
    (               reduce using rule 92 (if_statement -> IF expr block .)
    !               reduce using rule 92 (if_statement -> IF expr block .)
    +               reduce using rule 92 (if_statement -> IF expr block .)
    -               reduce using rule 92 (if_statement -> IF expr block .)
    ~               reduce using rule 92 (if_statement -> IF expr block .)
    ID              reduce using rule 92 (if_statement -> IF expr block .)
    TYPEOF          reduce using rule 92 (if_statement -> IF expr block .)
    LAMBDA          reduce using rule 92 (if_statement -> IF expr block .)
    DEC             reduce using rule 92 (if_statement -> IF expr block .)
    INC             reduce using rule 92 (if_statement -> IF expr block .)
    CLASS           reduce using rule 92 (if_statement -> IF expr block .)
    STRUCT          reduce using rule 92 (if_statement -> IF expr block .)
    IF              reduce using rule 92 (if_statement -> IF expr block .)
    FOR             reduce using rule 92 (if_statement -> IF expr block .)
    WHILE           reduce using rule 92 (if_statement -> IF expr block .)
    RETURN          reduce using rule 92 (if_statement -> IF expr block .)
    FN              reduce using rule 92 (if_statement -> IF expr block .)
    IMPORT          reduce using rule 92 (if_statement -> IF expr block .)
    [               reduce using rule 92 (if_statement -> IF expr block .)
    $end            reduce using rule 92 (if_statement -> IF expr block .)
    }               reduce using rule 92 (if_statement -> IF expr block .)
    ELSE            shift and go to state 211


state 172

    (48) expr -> expr - . expr
    (52) expr -> - . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 212
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 173

    (49) expr -> expr + . expr
    (51) expr -> + . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 213
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 174

    (103) block -> statement .
    ELSE            reduce using rule 103 (block -> statement .)
    LET             reduce using rule 103 (block -> statement .)
    {               reduce using rule 103 (block -> statement .)
    NIL             reduce using rule 103 (block -> statement .)
    FALSE           reduce using rule 103 (block -> statement .)
    TRUE            reduce using rule 103 (block -> statement .)
    STRING          reduce using rule 103 (block -> statement .)
    FLOAT           reduce using rule 103 (block -> statement .)
    INT             reduce using rule 103 (block -> statement .)
    (               reduce using rule 103 (block -> statement .)
    !               reduce using rule 103 (block -> statement .)
    +               reduce using rule 103 (block -> statement .)
    -               reduce using rule 103 (block -> statement .)
    ~               reduce using rule 103 (block -> statement .)
    ID              reduce using rule 103 (block -> statement .)
    TYPEOF          reduce using rule 103 (block -> statement .)
    LAMBDA          reduce using rule 103 (block -> statement .)
    DEC             reduce using rule 103 (block -> statement .)
    INC             reduce using rule 103 (block -> statement .)
    CLASS           reduce using rule 103 (block -> statement .)
    STRUCT          reduce using rule 103 (block -> statement .)
    IF              reduce using rule 103 (block -> statement .)
    FOR             reduce using rule 103 (block -> statement .)
    WHILE           reduce using rule 103 (block -> statement .)
    RETURN          reduce using rule 103 (block -> statement .)
    FN              reduce using rule 103 (block -> statement .)
    IMPORT          reduce using rule 103 (block -> statement .)
    [               reduce using rule 103 (block -> statement .)
    $end            reduce using rule 103 (block -> statement .)
    }               reduce using rule 103 (block -> statement .)


state 175

    (104) block -> { . program }
    (34) expr -> { . member_list }
    (1) program -> . empty
    (2) program -> . statements
    (113) member_list -> . member_list , member
    (114) member_list -> . member
    (115) member_list -> . empty
    (102) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (116) member -> . STRING : expr
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    }               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    STRING          shift and go to state 216
    LET             shift and go to state 7
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    program                        shift and go to state 214
    member_list                    shift and go to state 86
    empty                          shift and go to state 215
    statements                     shift and go to state 3
    member                         shift and go to state 87
    statement                      shift and go to state 4
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 176

    (95) for_statement -> FOR var_assign SEP . expr SEP var_assign block
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 217
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 177

    (94) while_statement -> WHILE expr block .
    LET             reduce using rule 94 (while_statement -> WHILE expr block .)
    {               reduce using rule 94 (while_statement -> WHILE expr block .)
    NIL             reduce using rule 94 (while_statement -> WHILE expr block .)
    FALSE           reduce using rule 94 (while_statement -> WHILE expr block .)
    TRUE            reduce using rule 94 (while_statement -> WHILE expr block .)
    STRING          reduce using rule 94 (while_statement -> WHILE expr block .)
    FLOAT           reduce using rule 94 (while_statement -> WHILE expr block .)
    INT             reduce using rule 94 (while_statement -> WHILE expr block .)
    (               reduce using rule 94 (while_statement -> WHILE expr block .)
    !               reduce using rule 94 (while_statement -> WHILE expr block .)
    +               reduce using rule 94 (while_statement -> WHILE expr block .)
    -               reduce using rule 94 (while_statement -> WHILE expr block .)
    ~               reduce using rule 94 (while_statement -> WHILE expr block .)
    ID              reduce using rule 94 (while_statement -> WHILE expr block .)
    TYPEOF          reduce using rule 94 (while_statement -> WHILE expr block .)
    LAMBDA          reduce using rule 94 (while_statement -> WHILE expr block .)
    DEC             reduce using rule 94 (while_statement -> WHILE expr block .)
    INC             reduce using rule 94 (while_statement -> WHILE expr block .)
    CLASS           reduce using rule 94 (while_statement -> WHILE expr block .)
    STRUCT          reduce using rule 94 (while_statement -> WHILE expr block .)
    IF              reduce using rule 94 (while_statement -> WHILE expr block .)
    FOR             reduce using rule 94 (while_statement -> WHILE expr block .)
    WHILE           reduce using rule 94 (while_statement -> WHILE expr block .)
    RETURN          reduce using rule 94 (while_statement -> WHILE expr block .)
    FN              reduce using rule 94 (while_statement -> WHILE expr block .)
    IMPORT          reduce using rule 94 (while_statement -> WHILE expr block .)
    [               reduce using rule 94 (while_statement -> WHILE expr block .)
    $end            reduce using rule 94 (while_statement -> WHILE expr block .)
    }               reduce using rule 94 (while_statement -> WHILE expr block .)
    ELSE            reduce using rule 94 (while_statement -> WHILE expr block .)


state 178

    (78) return_statement -> RETURN expr SEP .
    LET             reduce using rule 78 (return_statement -> RETURN expr SEP .)
    {               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    NIL             reduce using rule 78 (return_statement -> RETURN expr SEP .)
    FALSE           reduce using rule 78 (return_statement -> RETURN expr SEP .)
    TRUE            reduce using rule 78 (return_statement -> RETURN expr SEP .)
    STRING          reduce using rule 78 (return_statement -> RETURN expr SEP .)
    FLOAT           reduce using rule 78 (return_statement -> RETURN expr SEP .)
    INT             reduce using rule 78 (return_statement -> RETURN expr SEP .)
    (               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    !               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    +               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    -               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    ~               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    ID              reduce using rule 78 (return_statement -> RETURN expr SEP .)
    TYPEOF          reduce using rule 78 (return_statement -> RETURN expr SEP .)
    LAMBDA          reduce using rule 78 (return_statement -> RETURN expr SEP .)
    DEC             reduce using rule 78 (return_statement -> RETURN expr SEP .)
    INC             reduce using rule 78 (return_statement -> RETURN expr SEP .)
    CLASS           reduce using rule 78 (return_statement -> RETURN expr SEP .)
    STRUCT          reduce using rule 78 (return_statement -> RETURN expr SEP .)
    IF              reduce using rule 78 (return_statement -> RETURN expr SEP .)
    FOR             reduce using rule 78 (return_statement -> RETURN expr SEP .)
    WHILE           reduce using rule 78 (return_statement -> RETURN expr SEP .)
    RETURN          reduce using rule 78 (return_statement -> RETURN expr SEP .)
    FN              reduce using rule 78 (return_statement -> RETURN expr SEP .)
    IMPORT          reduce using rule 78 (return_statement -> RETURN expr SEP .)
    [               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    $end            reduce using rule 78 (return_statement -> RETURN expr SEP .)
    }               reduce using rule 78 (return_statement -> RETURN expr SEP .)
    ELSE            reduce using rule 78 (return_statement -> RETURN expr SEP .)


state 179

    (32) function_definition -> FN ID ( . params ) block
    (105) params -> . empty
    (106) params -> . param
    (107) params -> . params , param
    (102) empty -> .
    (108) param -> . ID : var_type
    )               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    ID              shift and go to state 168

    params                         shift and go to state 218
    empty                          shift and go to state 166
    param                          shift and go to state 167

state 180

    (31) import_statement -> IMPORT STRING SEP .
    LET             reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    {               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    NIL             reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    FALSE           reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    TRUE            reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    STRING          reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    FLOAT           reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    INT             reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    (               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    !               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    +               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    -               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    ~               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    ID              reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    TYPEOF          reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    LAMBDA          reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    DEC             reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    INC             reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    CLASS           reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    STRUCT          reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    IF              reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    FOR             reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    WHILE           reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    RETURN          reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    FN              reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    IMPORT          reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    [               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    $end            reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    }               reduce using rule 31 (import_statement -> IMPORT STRING SEP .)
    ELSE            reduce using rule 31 (import_statement -> IMPORT STRING SEP .)


state 181

    (67) expr -> expr PIPE ID ( . args )
    (109) args -> . empty
    (110) args -> . arg
    (111) args -> . args , arg
    (102) empty -> .
    (112) arg -> . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    )               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 163
    args                           shift and go to state 219
    empty                          shift and go to state 161
    arg                            shift and go to state 162
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 182

    (70) expr -> expr ? expr : . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 220
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 183

    (7) statement -> LET var : var_type . SEP
    SEP             shift and go to state 221


state 184

    (25) var_type -> DICT_TYPE .
    SEP             reduce using rule 25 (var_type -> DICT_TYPE .)
    )               reduce using rule 25 (var_type -> DICT_TYPE .)
    ,               reduce using rule 25 (var_type -> DICT_TYPE .)


state 185

    (26) var_type -> LIST_TYPE .
    SEP             reduce using rule 26 (var_type -> LIST_TYPE .)
    )               reduce using rule 26 (var_type -> LIST_TYPE .)
    ,               reduce using rule 26 (var_type -> LIST_TYPE .)


state 186

    (27) var_type -> BOOL_TYPE .
    SEP             reduce using rule 27 (var_type -> BOOL_TYPE .)
    )               reduce using rule 27 (var_type -> BOOL_TYPE .)
    ,               reduce using rule 27 (var_type -> BOOL_TYPE .)


state 187

    (28) var_type -> STRING_TYPE .
    SEP             reduce using rule 28 (var_type -> STRING_TYPE .)
    )               reduce using rule 28 (var_type -> STRING_TYPE .)
    ,               reduce using rule 28 (var_type -> STRING_TYPE .)


state 188

    (29) var_type -> FLOAT_TYPE .
    SEP             reduce using rule 29 (var_type -> FLOAT_TYPE .)
    )               reduce using rule 29 (var_type -> FLOAT_TYPE .)
    ,               reduce using rule 29 (var_type -> FLOAT_TYPE .)


state 189

    (30) var_type -> INT_TYPE .
    SEP             reduce using rule 30 (var_type -> INT_TYPE .)
    )               reduce using rule 30 (var_type -> INT_TYPE .)
    ,               reduce using rule 30 (var_type -> INT_TYPE .)


state 190

    (77) var_define -> LET var ASSIGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 77 (var_define -> LET var ASSIGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 191

    (100) var -> var [ expr . ]
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    ]               shift and go to state 222
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 192

    (76) var_define -> LET getter ASSIGN expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             reduce using rule 76 (var_define -> LET getter ASSIGN expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 193

    (37) expr -> var [ expr ] .
    (100) var -> var [ expr ] .
  ! reduce/reduce conflict for [ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SEP resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for % resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for / resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for * resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for - resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for + resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for | resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ^ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for & resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SHR resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SHL resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for GREATER resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LESS resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for OR resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for AND resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for EQEQ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for PIPE resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ? resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ] resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for , resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ) resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for { resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LET resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for NIL resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FALSE resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TRUE resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for STRING resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FLOAT resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for INT resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ( resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ! resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ~ resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ID resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TYPEOF resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LAMBDA resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for DEC resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for INC resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for CLASS resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for STRUCT resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for IF resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FOR resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for WHILE resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for RETURN resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FN resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for IMPORT resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for : resolved using rule 37 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for } resolved using rule 37 (expr -> var [ expr ] .)
    SEP             reduce using rule 37 (expr -> var [ expr ] .)
    %               reduce using rule 37 (expr -> var [ expr ] .)
    /               reduce using rule 37 (expr -> var [ expr ] .)
    *               reduce using rule 37 (expr -> var [ expr ] .)
    -               reduce using rule 37 (expr -> var [ expr ] .)
    +               reduce using rule 37 (expr -> var [ expr ] .)
    |               reduce using rule 37 (expr -> var [ expr ] .)
    ^               reduce using rule 37 (expr -> var [ expr ] .)
    &               reduce using rule 37 (expr -> var [ expr ] .)
    SHR             reduce using rule 37 (expr -> var [ expr ] .)
    SHL             reduce using rule 37 (expr -> var [ expr ] .)
    GREATER         reduce using rule 37 (expr -> var [ expr ] .)
    LESS            reduce using rule 37 (expr -> var [ expr ] .)
    OR              reduce using rule 37 (expr -> var [ expr ] .)
    AND             reduce using rule 37 (expr -> var [ expr ] .)
    GREATEREQ       reduce using rule 37 (expr -> var [ expr ] .)
    LESSEQ          reduce using rule 37 (expr -> var [ expr ] .)
    NOTEQ           reduce using rule 37 (expr -> var [ expr ] .)
    EQEQ            reduce using rule 37 (expr -> var [ expr ] .)
    PIPE            reduce using rule 37 (expr -> var [ expr ] .)
    ?               reduce using rule 37 (expr -> var [ expr ] .)
    ]               reduce using rule 37 (expr -> var [ expr ] .)
    ,               reduce using rule 37 (expr -> var [ expr ] .)
    )               reduce using rule 37 (expr -> var [ expr ] .)
    {               reduce using rule 37 (expr -> var [ expr ] .)
    LET             reduce using rule 37 (expr -> var [ expr ] .)
    NIL             reduce using rule 37 (expr -> var [ expr ] .)
    FALSE           reduce using rule 37 (expr -> var [ expr ] .)
    TRUE            reduce using rule 37 (expr -> var [ expr ] .)
    STRING          reduce using rule 37 (expr -> var [ expr ] .)
    FLOAT           reduce using rule 37 (expr -> var [ expr ] .)
    INT             reduce using rule 37 (expr -> var [ expr ] .)
    (               reduce using rule 37 (expr -> var [ expr ] .)
    !               reduce using rule 37 (expr -> var [ expr ] .)
    ~               reduce using rule 37 (expr -> var [ expr ] .)
    ID              reduce using rule 37 (expr -> var [ expr ] .)
    TYPEOF          reduce using rule 37 (expr -> var [ expr ] .)
    LAMBDA          reduce using rule 37 (expr -> var [ expr ] .)
    DEC             reduce using rule 37 (expr -> var [ expr ] .)
    INC             reduce using rule 37 (expr -> var [ expr ] .)
    CLASS           reduce using rule 37 (expr -> var [ expr ] .)
    STRUCT          reduce using rule 37 (expr -> var [ expr ] .)
    IF              reduce using rule 37 (expr -> var [ expr ] .)
    FOR             reduce using rule 37 (expr -> var [ expr ] .)
    WHILE           reduce using rule 37 (expr -> var [ expr ] .)
    RETURN          reduce using rule 37 (expr -> var [ expr ] .)
    FN              reduce using rule 37 (expr -> var [ expr ] .)
    IMPORT          reduce using rule 37 (expr -> var [ expr ] .)
    [               reduce using rule 37 (expr -> var [ expr ] .)
    :               reduce using rule 37 (expr -> var [ expr ] .)
    }               reduce using rule 37 (expr -> var [ expr ] .)
    SHRASGN         reduce using rule 100 (var -> var [ expr ] .)
    SHLASGN         reduce using rule 100 (var -> var [ expr ] .)
    XORASGN         reduce using rule 100 (var -> var [ expr ] .)
    ORASGN          reduce using rule 100 (var -> var [ expr ] .)
    ANDASGN         reduce using rule 100 (var -> var [ expr ] .)
    MODULOASGN      reduce using rule 100 (var -> var [ expr ] .)
    SLASHASGN       reduce using rule 100 (var -> var [ expr ] .)
    STARASGN        reduce using rule 100 (var -> var [ expr ] .)
    MINUSASGN       reduce using rule 100 (var -> var [ expr ] .)
    PLUSASGN        reduce using rule 100 (var -> var [ expr ] .)
    ASSIGN          reduce using rule 100 (var -> var [ expr ] .)


state 194

    (113) member_list -> member_list , member .
    }               reduce using rule 113 (member_list -> member_list , member .)
    ,               reduce using rule 113 (member_list -> member_list , member .)


state 195

    (116) member -> STRING : expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    }               reduce using rule 116 (member -> STRING : expr .)
    ,               reduce using rule 116 (member -> STRING : expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 196

    (97) exprs -> exprs , expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    ]               reduce using rule 97 (exprs -> exprs , expr .)
    ,               reduce using rule 97 (exprs -> exprs , expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 197

    (68) expr -> ID DOUBLECOLON ID ( . args )
    (109) args -> . empty
    (110) args -> . arg
    (111) args -> . args , arg
    (102) empty -> .
    (112) arg -> . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    )               reduce using rule 102 (empty -> .)
    ,               reduce using rule 102 (empty -> .)
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    args                           shift and go to state 223
    empty                          shift and go to state 161
    arg                            shift and go to state 162
    expr                           shift and go to state 163
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 198

    (69) expr -> ID ( args ) .
    SEP             reduce using rule 69 (expr -> ID ( args ) .)
    %               reduce using rule 69 (expr -> ID ( args ) .)
    /               reduce using rule 69 (expr -> ID ( args ) .)
    *               reduce using rule 69 (expr -> ID ( args ) .)
    -               reduce using rule 69 (expr -> ID ( args ) .)
    +               reduce using rule 69 (expr -> ID ( args ) .)
    |               reduce using rule 69 (expr -> ID ( args ) .)
    ^               reduce using rule 69 (expr -> ID ( args ) .)
    &               reduce using rule 69 (expr -> ID ( args ) .)
    SHR             reduce using rule 69 (expr -> ID ( args ) .)
    SHL             reduce using rule 69 (expr -> ID ( args ) .)
    GREATER         reduce using rule 69 (expr -> ID ( args ) .)
    LESS            reduce using rule 69 (expr -> ID ( args ) .)
    OR              reduce using rule 69 (expr -> ID ( args ) .)
    AND             reduce using rule 69 (expr -> ID ( args ) .)
    GREATEREQ       reduce using rule 69 (expr -> ID ( args ) .)
    LESSEQ          reduce using rule 69 (expr -> ID ( args ) .)
    NOTEQ           reduce using rule 69 (expr -> ID ( args ) .)
    EQEQ            reduce using rule 69 (expr -> ID ( args ) .)
    PIPE            reduce using rule 69 (expr -> ID ( args ) .)
    ?               reduce using rule 69 (expr -> ID ( args ) .)
    ]               reduce using rule 69 (expr -> ID ( args ) .)
    ,               reduce using rule 69 (expr -> ID ( args ) .)
    )               reduce using rule 69 (expr -> ID ( args ) .)
    {               reduce using rule 69 (expr -> ID ( args ) .)
    LET             reduce using rule 69 (expr -> ID ( args ) .)
    NIL             reduce using rule 69 (expr -> ID ( args ) .)
    FALSE           reduce using rule 69 (expr -> ID ( args ) .)
    TRUE            reduce using rule 69 (expr -> ID ( args ) .)
    STRING          reduce using rule 69 (expr -> ID ( args ) .)
    FLOAT           reduce using rule 69 (expr -> ID ( args ) .)
    INT             reduce using rule 69 (expr -> ID ( args ) .)
    (               reduce using rule 69 (expr -> ID ( args ) .)
    !               reduce using rule 69 (expr -> ID ( args ) .)
    ~               reduce using rule 69 (expr -> ID ( args ) .)
    ID              reduce using rule 69 (expr -> ID ( args ) .)
    TYPEOF          reduce using rule 69 (expr -> ID ( args ) .)
    LAMBDA          reduce using rule 69 (expr -> ID ( args ) .)
    DEC             reduce using rule 69 (expr -> ID ( args ) .)
    INC             reduce using rule 69 (expr -> ID ( args ) .)
    CLASS           reduce using rule 69 (expr -> ID ( args ) .)
    STRUCT          reduce using rule 69 (expr -> ID ( args ) .)
    IF              reduce using rule 69 (expr -> ID ( args ) .)
    FOR             reduce using rule 69 (expr -> ID ( args ) .)
    WHILE           reduce using rule 69 (expr -> ID ( args ) .)
    RETURN          reduce using rule 69 (expr -> ID ( args ) .)
    FN              reduce using rule 69 (expr -> ID ( args ) .)
    IMPORT          reduce using rule 69 (expr -> ID ( args ) .)
    [               reduce using rule 69 (expr -> ID ( args ) .)
    :               reduce using rule 69 (expr -> ID ( args ) .)
    }               reduce using rule 69 (expr -> ID ( args ) .)


state 199

    (111) args -> args , . arg
    (112) arg -> . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    arg                            shift and go to state 224
    expr                           shift and go to state 163
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 200

    (73) expr -> ID LEFTARROW { struct_init_exprs . }
    (74) struct_init_exprs -> struct_init_exprs . , expr
    }               shift and go to state 225
    ,               shift and go to state 226


state 201

    (75) struct_init_exprs -> expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    }               reduce using rule 75 (struct_init_exprs -> expr .)
    ,               reduce using rule 75 (struct_init_exprs -> expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 202

    (72) expr -> LAMBDA ( params ) . ARROW expr
    ARROW           shift and go to state 227


state 203

    (107) params -> params , . param
    (108) param -> . ID : var_type
    ID              shift and go to state 168

    param                          shift and go to state 228

state 204

    (108) param -> ID : . var_type
    (25) var_type -> . DICT_TYPE
    (26) var_type -> . LIST_TYPE
    (27) var_type -> . BOOL_TYPE
    (28) var_type -> . STRING_TYPE
    (29) var_type -> . FLOAT_TYPE
    (30) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 184
    LIST_TYPE       shift and go to state 185
    BOOL_TYPE       shift and go to state 186
    STRING_TYPE     shift and go to state 187
    FLOAT_TYPE      shift and go to state 188
    INT_TYPE        shift and go to state 189

    var_type                       shift and go to state 229

state 205

    (17) class_definition -> CLASS ID { function_definitions . }
    (18) function_definitions -> function_definitions . function_definition
    (32) function_definition -> . FN ID ( params ) block
    }               shift and go to state 230
    FN              shift and go to state 44

    function_definition            shift and go to state 231

state 206

    (19) function_definitions -> function_definition .
    }               reduce using rule 19 (function_definitions -> function_definition .)
    FN              reduce using rule 19 (function_definitions -> function_definition .)


state 207

    (20) function_definitions -> empty .
    }               reduce using rule 20 (function_definitions -> empty .)
    FN              reduce using rule 20 (function_definitions -> empty .)


state 208

    (21) struct_definition -> STRUCT ID { struct_fields . } SEP
    (22) struct_fields -> struct_fields . struct_field
    (24) struct_field -> . LET ID : var_type SEP
    }               shift and go to state 232
    LET             shift and go to state 210

    struct_field                   shift and go to state 233

state 209

    (23) struct_fields -> struct_field .
    }               reduce using rule 23 (struct_fields -> struct_field .)
    LET             reduce using rule 23 (struct_fields -> struct_field .)


state 210

    (24) struct_field -> LET . ID : var_type SEP
    ID              shift and go to state 234


state 211

    (93) if_statement -> IF expr block ELSE . block
    (103) block -> . statement
    (104) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 175
    LET             shift and go to state 7
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    expr                           shift and go to state 5
    block                          shift and go to state 235
    statement                      shift and go to state 174
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 212

    (48) expr -> expr - expr .
    (52) expr -> - expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for % resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for / resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for * resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for - resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for + resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for | resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for ^ resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for & resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for SHR resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for SHL resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for LESS resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for OR resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for AND resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for PIPE resolved using rule 52 (expr -> - expr .)
  ! reduce/reduce conflict for ? resolved using rule 52 (expr -> - expr .)
    {               reduce using rule 48 (expr -> expr - expr .)
    LET             reduce using rule 48 (expr -> expr - expr .)
    NIL             reduce using rule 48 (expr -> expr - expr .)
    FALSE           reduce using rule 48 (expr -> expr - expr .)
    TRUE            reduce using rule 48 (expr -> expr - expr .)
    STRING          reduce using rule 48 (expr -> expr - expr .)
    FLOAT           reduce using rule 48 (expr -> expr - expr .)
    INT             reduce using rule 48 (expr -> expr - expr .)
    (               reduce using rule 48 (expr -> expr - expr .)
    !               reduce using rule 48 (expr -> expr - expr .)
    ~               reduce using rule 48 (expr -> expr - expr .)
    ID              reduce using rule 48 (expr -> expr - expr .)
    TYPEOF          reduce using rule 48 (expr -> expr - expr .)
    LAMBDA          reduce using rule 48 (expr -> expr - expr .)
    DEC             reduce using rule 48 (expr -> expr - expr .)
    INC             reduce using rule 48 (expr -> expr - expr .)
    CLASS           reduce using rule 48 (expr -> expr - expr .)
    STRUCT          reduce using rule 48 (expr -> expr - expr .)
    IF              reduce using rule 48 (expr -> expr - expr .)
    FOR             reduce using rule 48 (expr -> expr - expr .)
    WHILE           reduce using rule 48 (expr -> expr - expr .)
    RETURN          reduce using rule 48 (expr -> expr - expr .)
    FN              reduce using rule 48 (expr -> expr - expr .)
    IMPORT          reduce using rule 48 (expr -> expr - expr .)
    [               reduce using rule 48 (expr -> expr - expr .)
    SEP             reduce using rule 52 (expr -> - expr .)
    %               reduce using rule 52 (expr -> - expr .)
    /               reduce using rule 52 (expr -> - expr .)
    *               reduce using rule 52 (expr -> - expr .)
    -               reduce using rule 52 (expr -> - expr .)
    +               reduce using rule 52 (expr -> - expr .)
    |               reduce using rule 52 (expr -> - expr .)
    ^               reduce using rule 52 (expr -> - expr .)
    &               reduce using rule 52 (expr -> - expr .)
    SHR             reduce using rule 52 (expr -> - expr .)
    SHL             reduce using rule 52 (expr -> - expr .)
    GREATER         reduce using rule 52 (expr -> - expr .)
    LESS            reduce using rule 52 (expr -> - expr .)
    OR              reduce using rule 52 (expr -> - expr .)
    AND             reduce using rule 52 (expr -> - expr .)
    GREATEREQ       reduce using rule 52 (expr -> - expr .)
    LESSEQ          reduce using rule 52 (expr -> - expr .)
    NOTEQ           reduce using rule 52 (expr -> - expr .)
    EQEQ            reduce using rule 52 (expr -> - expr .)
    PIPE            reduce using rule 52 (expr -> - expr .)
    ?               reduce using rule 52 (expr -> - expr .)


state 213

    (49) expr -> expr + expr .
    (51) expr -> + expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for % resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for / resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for * resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for - resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for + resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for | resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for ^ resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for & resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for SHR resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for SHL resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for LESS resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for OR resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for AND resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for PIPE resolved using rule 51 (expr -> + expr .)
  ! reduce/reduce conflict for ? resolved using rule 51 (expr -> + expr .)
    {               reduce using rule 49 (expr -> expr + expr .)
    LET             reduce using rule 49 (expr -> expr + expr .)
    NIL             reduce using rule 49 (expr -> expr + expr .)
    FALSE           reduce using rule 49 (expr -> expr + expr .)
    TRUE            reduce using rule 49 (expr -> expr + expr .)
    STRING          reduce using rule 49 (expr -> expr + expr .)
    FLOAT           reduce using rule 49 (expr -> expr + expr .)
    INT             reduce using rule 49 (expr -> expr + expr .)
    (               reduce using rule 49 (expr -> expr + expr .)
    !               reduce using rule 49 (expr -> expr + expr .)
    ~               reduce using rule 49 (expr -> expr + expr .)
    ID              reduce using rule 49 (expr -> expr + expr .)
    TYPEOF          reduce using rule 49 (expr -> expr + expr .)
    LAMBDA          reduce using rule 49 (expr -> expr + expr .)
    DEC             reduce using rule 49 (expr -> expr + expr .)
    INC             reduce using rule 49 (expr -> expr + expr .)
    CLASS           reduce using rule 49 (expr -> expr + expr .)
    STRUCT          reduce using rule 49 (expr -> expr + expr .)
    IF              reduce using rule 49 (expr -> expr + expr .)
    FOR             reduce using rule 49 (expr -> expr + expr .)
    WHILE           reduce using rule 49 (expr -> expr + expr .)
    RETURN          reduce using rule 49 (expr -> expr + expr .)
    FN              reduce using rule 49 (expr -> expr + expr .)
    IMPORT          reduce using rule 49 (expr -> expr + expr .)
    [               reduce using rule 49 (expr -> expr + expr .)
    SEP             reduce using rule 51 (expr -> + expr .)
    %               reduce using rule 51 (expr -> + expr .)
    /               reduce using rule 51 (expr -> + expr .)
    *               reduce using rule 51 (expr -> + expr .)
    -               reduce using rule 51 (expr -> + expr .)
    +               reduce using rule 51 (expr -> + expr .)
    |               reduce using rule 51 (expr -> + expr .)
    ^               reduce using rule 51 (expr -> + expr .)
    &               reduce using rule 51 (expr -> + expr .)
    SHR             reduce using rule 51 (expr -> + expr .)
    SHL             reduce using rule 51 (expr -> + expr .)
    GREATER         reduce using rule 51 (expr -> + expr .)
    LESS            reduce using rule 51 (expr -> + expr .)
    OR              reduce using rule 51 (expr -> + expr .)
    AND             reduce using rule 51 (expr -> + expr .)
    GREATEREQ       reduce using rule 51 (expr -> + expr .)
    LESSEQ          reduce using rule 51 (expr -> + expr .)
    NOTEQ           reduce using rule 51 (expr -> + expr .)
    EQEQ            reduce using rule 51 (expr -> + expr .)
    PIPE            reduce using rule 51 (expr -> + expr .)
    ?               reduce using rule 51 (expr -> + expr .)


state 214

    (104) block -> { program . }
    }               shift and go to state 236


state 215

    (1) program -> empty .
    (115) member_list -> empty .
  ! reduce/reduce conflict for } resolved using rule 1 (program -> empty .)
    }               reduce using rule 1 (program -> empty .)
    ,               reduce using rule 115 (member_list -> empty .)


state 216

    (116) member -> STRING . : expr
    (41) expr -> STRING .
    :               shift and go to state 155
    SEP             reduce using rule 41 (expr -> STRING .)
    %               reduce using rule 41 (expr -> STRING .)
    /               reduce using rule 41 (expr -> STRING .)
    *               reduce using rule 41 (expr -> STRING .)
    -               reduce using rule 41 (expr -> STRING .)
    +               reduce using rule 41 (expr -> STRING .)
    |               reduce using rule 41 (expr -> STRING .)
    ^               reduce using rule 41 (expr -> STRING .)
    &               reduce using rule 41 (expr -> STRING .)
    SHR             reduce using rule 41 (expr -> STRING .)
    SHL             reduce using rule 41 (expr -> STRING .)
    GREATER         reduce using rule 41 (expr -> STRING .)
    LESS            reduce using rule 41 (expr -> STRING .)
    OR              reduce using rule 41 (expr -> STRING .)
    AND             reduce using rule 41 (expr -> STRING .)
    GREATEREQ       reduce using rule 41 (expr -> STRING .)
    LESSEQ          reduce using rule 41 (expr -> STRING .)
    NOTEQ           reduce using rule 41 (expr -> STRING .)
    EQEQ            reduce using rule 41 (expr -> STRING .)
    PIPE            reduce using rule 41 (expr -> STRING .)
    ?               reduce using rule 41 (expr -> STRING .)


state 217

    (95) for_statement -> FOR var_assign SEP expr . SEP var_assign block
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    SEP             shift and go to state 237
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 218

    (32) function_definition -> FN ID ( params . ) block
    (107) params -> params . , param
    )               shift and go to state 238
    ,               shift and go to state 203


state 219

    (67) expr -> expr PIPE ID ( args . )
    (111) args -> args . , arg
    )               shift and go to state 239
    ,               shift and go to state 199


state 220

    (70) expr -> expr ? expr : expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 70 (expr -> expr ? expr : expr .)
    ]               reduce using rule 70 (expr -> expr ? expr : expr .)
    ,               reduce using rule 70 (expr -> expr ? expr : expr .)
    )               reduce using rule 70 (expr -> expr ? expr : expr .)
    {               reduce using rule 70 (expr -> expr ? expr : expr .)
    LET             reduce using rule 70 (expr -> expr ? expr : expr .)
    NIL             reduce using rule 70 (expr -> expr ? expr : expr .)
    FALSE           reduce using rule 70 (expr -> expr ? expr : expr .)
    TRUE            reduce using rule 70 (expr -> expr ? expr : expr .)
    STRING          reduce using rule 70 (expr -> expr ? expr : expr .)
    FLOAT           reduce using rule 70 (expr -> expr ? expr : expr .)
    INT             reduce using rule 70 (expr -> expr ? expr : expr .)
    (               reduce using rule 70 (expr -> expr ? expr : expr .)
    !               reduce using rule 70 (expr -> expr ? expr : expr .)
    ~               reduce using rule 70 (expr -> expr ? expr : expr .)
    ID              reduce using rule 70 (expr -> expr ? expr : expr .)
    TYPEOF          reduce using rule 70 (expr -> expr ? expr : expr .)
    LAMBDA          reduce using rule 70 (expr -> expr ? expr : expr .)
    DEC             reduce using rule 70 (expr -> expr ? expr : expr .)
    INC             reduce using rule 70 (expr -> expr ? expr : expr .)
    CLASS           reduce using rule 70 (expr -> expr ? expr : expr .)
    STRUCT          reduce using rule 70 (expr -> expr ? expr : expr .)
    IF              reduce using rule 70 (expr -> expr ? expr : expr .)
    FOR             reduce using rule 70 (expr -> expr ? expr : expr .)
    WHILE           reduce using rule 70 (expr -> expr ? expr : expr .)
    RETURN          reduce using rule 70 (expr -> expr ? expr : expr .)
    FN              reduce using rule 70 (expr -> expr ? expr : expr .)
    IMPORT          reduce using rule 70 (expr -> expr ? expr : expr .)
    [               reduce using rule 70 (expr -> expr ? expr : expr .)
    :               reduce using rule 70 (expr -> expr ? expr : expr .)
    }               reduce using rule 70 (expr -> expr ? expr : expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 221

    (7) statement -> LET var : var_type SEP .
    LET             reduce using rule 7 (statement -> LET var : var_type SEP .)
    {               reduce using rule 7 (statement -> LET var : var_type SEP .)
    NIL             reduce using rule 7 (statement -> LET var : var_type SEP .)
    FALSE           reduce using rule 7 (statement -> LET var : var_type SEP .)
    TRUE            reduce using rule 7 (statement -> LET var : var_type SEP .)
    STRING          reduce using rule 7 (statement -> LET var : var_type SEP .)
    FLOAT           reduce using rule 7 (statement -> LET var : var_type SEP .)
    INT             reduce using rule 7 (statement -> LET var : var_type SEP .)
    (               reduce using rule 7 (statement -> LET var : var_type SEP .)
    !               reduce using rule 7 (statement -> LET var : var_type SEP .)
    +               reduce using rule 7 (statement -> LET var : var_type SEP .)
    -               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ~               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ID              reduce using rule 7 (statement -> LET var : var_type SEP .)
    TYPEOF          reduce using rule 7 (statement -> LET var : var_type SEP .)
    LAMBDA          reduce using rule 7 (statement -> LET var : var_type SEP .)
    DEC             reduce using rule 7 (statement -> LET var : var_type SEP .)
    INC             reduce using rule 7 (statement -> LET var : var_type SEP .)
    CLASS           reduce using rule 7 (statement -> LET var : var_type SEP .)
    STRUCT          reduce using rule 7 (statement -> LET var : var_type SEP .)
    IF              reduce using rule 7 (statement -> LET var : var_type SEP .)
    FOR             reduce using rule 7 (statement -> LET var : var_type SEP .)
    WHILE           reduce using rule 7 (statement -> LET var : var_type SEP .)
    RETURN          reduce using rule 7 (statement -> LET var : var_type SEP .)
    FN              reduce using rule 7 (statement -> LET var : var_type SEP .)
    IMPORT          reduce using rule 7 (statement -> LET var : var_type SEP .)
    [               reduce using rule 7 (statement -> LET var : var_type SEP .)
    $end            reduce using rule 7 (statement -> LET var : var_type SEP .)
    }               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ELSE            reduce using rule 7 (statement -> LET var : var_type SEP .)


state 222

    (100) var -> var [ expr ] .
    :               reduce using rule 100 (var -> var [ expr ] .)
    ASSIGN          reduce using rule 100 (var -> var [ expr ] .)
    [               reduce using rule 100 (var -> var [ expr ] .)
    SEP             reduce using rule 100 (var -> var [ expr ] .)
    {               reduce using rule 100 (var -> var [ expr ] .)
    LET             reduce using rule 100 (var -> var [ expr ] .)
    NIL             reduce using rule 100 (var -> var [ expr ] .)
    FALSE           reduce using rule 100 (var -> var [ expr ] .)
    TRUE            reduce using rule 100 (var -> var [ expr ] .)
    STRING          reduce using rule 100 (var -> var [ expr ] .)
    FLOAT           reduce using rule 100 (var -> var [ expr ] .)
    INT             reduce using rule 100 (var -> var [ expr ] .)
    (               reduce using rule 100 (var -> var [ expr ] .)
    !               reduce using rule 100 (var -> var [ expr ] .)
    +               reduce using rule 100 (var -> var [ expr ] .)
    -               reduce using rule 100 (var -> var [ expr ] .)
    ~               reduce using rule 100 (var -> var [ expr ] .)
    ID              reduce using rule 100 (var -> var [ expr ] .)
    TYPEOF          reduce using rule 100 (var -> var [ expr ] .)
    LAMBDA          reduce using rule 100 (var -> var [ expr ] .)
    DEC             reduce using rule 100 (var -> var [ expr ] .)
    INC             reduce using rule 100 (var -> var [ expr ] .)
    CLASS           reduce using rule 100 (var -> var [ expr ] .)
    STRUCT          reduce using rule 100 (var -> var [ expr ] .)
    IF              reduce using rule 100 (var -> var [ expr ] .)
    FOR             reduce using rule 100 (var -> var [ expr ] .)
    WHILE           reduce using rule 100 (var -> var [ expr ] .)
    RETURN          reduce using rule 100 (var -> var [ expr ] .)
    FN              reduce using rule 100 (var -> var [ expr ] .)
    IMPORT          reduce using rule 100 (var -> var [ expr ] .)
    SHRASGN         reduce using rule 100 (var -> var [ expr ] .)
    SHLASGN         reduce using rule 100 (var -> var [ expr ] .)
    XORASGN         reduce using rule 100 (var -> var [ expr ] .)
    ORASGN          reduce using rule 100 (var -> var [ expr ] .)
    ANDASGN         reduce using rule 100 (var -> var [ expr ] .)
    MODULOASGN      reduce using rule 100 (var -> var [ expr ] .)
    SLASHASGN       reduce using rule 100 (var -> var [ expr ] .)
    STARASGN        reduce using rule 100 (var -> var [ expr ] .)
    MINUSASGN       reduce using rule 100 (var -> var [ expr ] .)
    PLUSASGN        reduce using rule 100 (var -> var [ expr ] .)


state 223

    (68) expr -> ID DOUBLECOLON ID ( args . )
    (111) args -> args . , arg
    )               shift and go to state 240
    ,               shift and go to state 199


state 224

    (111) args -> args , arg .
    )               reduce using rule 111 (args -> args , arg .)
    ,               reduce using rule 111 (args -> args , arg .)


state 225

    (73) expr -> ID LEFTARROW { struct_init_exprs } .
    SEP             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    %               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    /               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    *               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    -               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    +               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    |               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ^               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    &               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SHR             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SHL             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    GREATER         reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LESS            reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    OR              reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    AND             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    GREATEREQ       reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LESSEQ          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    NOTEQ           reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    EQEQ            reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    PIPE            reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ?               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ]               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ,               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    )               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    {               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LET             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    NIL             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FALSE           reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TRUE            reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    STRING          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FLOAT           reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    INT             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    (               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    !               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ~               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ID              reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TYPEOF          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LAMBDA          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    DEC             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    INC             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    CLASS           reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    STRUCT          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    IF              reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FOR             reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    WHILE           reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    RETURN          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FN              reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    IMPORT          reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    [               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    :               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)
    }               reduce using rule 73 (expr -> ID LEFTARROW { struct_init_exprs } .)


state 226

    (74) struct_init_exprs -> struct_init_exprs , . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 241
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 227

    (72) expr -> LAMBDA ( params ) ARROW . expr
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 19
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    [               shift and go to state 21

    expr                           shift and go to state 242
    getter                         shift and go to state 18
    var                            shift and go to state 93
    list_val                       shift and go to state 22

state 228

    (107) params -> params , param .
    )               reduce using rule 107 (params -> params , param .)
    ,               reduce using rule 107 (params -> params , param .)


state 229

    (108) param -> ID : var_type .
    )               reduce using rule 108 (param -> ID : var_type .)
    ,               reduce using rule 108 (param -> ID : var_type .)


state 230

    (17) class_definition -> CLASS ID { function_definitions } .
    LET             reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    {               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    NIL             reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    FALSE           reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    TRUE            reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    STRING          reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    FLOAT           reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    INT             reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    (               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    !               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    +               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    -               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    ~               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    ID              reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    TYPEOF          reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    LAMBDA          reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    DEC             reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    INC             reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    CLASS           reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    STRUCT          reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    IF              reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    FOR             reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    WHILE           reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    RETURN          reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    FN              reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    IMPORT          reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    [               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    $end            reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    }               reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)
    ELSE            reduce using rule 17 (class_definition -> CLASS ID { function_definitions } .)


state 231

    (18) function_definitions -> function_definitions function_definition .
    }               reduce using rule 18 (function_definitions -> function_definitions function_definition .)
    FN              reduce using rule 18 (function_definitions -> function_definitions function_definition .)


state 232

    (21) struct_definition -> STRUCT ID { struct_fields } . SEP
    SEP             shift and go to state 243


state 233

    (22) struct_fields -> struct_fields struct_field .
    }               reduce using rule 22 (struct_fields -> struct_fields struct_field .)
    LET             reduce using rule 22 (struct_fields -> struct_fields struct_field .)


state 234

    (24) struct_field -> LET ID . : var_type SEP
    :               shift and go to state 244


state 235

    (93) if_statement -> IF expr block ELSE block .
    LET             reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    {               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    NIL             reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    FALSE           reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    TRUE            reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    STRING          reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    FLOAT           reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    INT             reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    (               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    !               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    +               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    -               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    ~               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    ID              reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    TYPEOF          reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    LAMBDA          reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    DEC             reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    INC             reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    CLASS           reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    STRUCT          reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    IF              reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    FOR             reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    FN              reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    IMPORT          reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    [               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    $end            reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    }               reduce using rule 93 (if_statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 93 (if_statement -> IF expr block ELSE block .)


state 236

    (104) block -> { program } .
    ELSE            reduce using rule 104 (block -> { program } .)
    LET             reduce using rule 104 (block -> { program } .)
    {               reduce using rule 104 (block -> { program } .)
    NIL             reduce using rule 104 (block -> { program } .)
    FALSE           reduce using rule 104 (block -> { program } .)
    TRUE            reduce using rule 104 (block -> { program } .)
    STRING          reduce using rule 104 (block -> { program } .)
    FLOAT           reduce using rule 104 (block -> { program } .)
    INT             reduce using rule 104 (block -> { program } .)
    (               reduce using rule 104 (block -> { program } .)
    !               reduce using rule 104 (block -> { program } .)
    +               reduce using rule 104 (block -> { program } .)
    -               reduce using rule 104 (block -> { program } .)
    ~               reduce using rule 104 (block -> { program } .)
    ID              reduce using rule 104 (block -> { program } .)
    TYPEOF          reduce using rule 104 (block -> { program } .)
    LAMBDA          reduce using rule 104 (block -> { program } .)
    DEC             reduce using rule 104 (block -> { program } .)
    INC             reduce using rule 104 (block -> { program } .)
    CLASS           reduce using rule 104 (block -> { program } .)
    STRUCT          reduce using rule 104 (block -> { program } .)
    IF              reduce using rule 104 (block -> { program } .)
    FOR             reduce using rule 104 (block -> { program } .)
    WHILE           reduce using rule 104 (block -> { program } .)
    RETURN          reduce using rule 104 (block -> { program } .)
    FN              reduce using rule 104 (block -> { program } .)
    IMPORT          reduce using rule 104 (block -> { program } .)
    [               reduce using rule 104 (block -> { program } .)
    $end            reduce using rule 104 (block -> { program } .)
    }               reduce using rule 104 (block -> { program } .)


state 237

    (95) for_statement -> FOR var_assign SEP expr SEP . var_assign block
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (100) var -> . var [ expr ]
    (101) var -> . ID
    DEC             shift and go to state 36
    INC             shift and go to state 37
    ID              shift and go to state 105

    var_assign                     shift and go to state 245
    var                            shift and go to state 111

state 238

    (32) function_definition -> FN ID ( params ) . block
    (103) block -> . statement
    (104) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 175
    LET             shift and go to state 7
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    block                          shift and go to state 246
    statement                      shift and go to state 174
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 239

    (67) expr -> expr PIPE ID ( args ) .
    SEP             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    %               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    /               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    *               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    -               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    +               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    |               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    ^               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    &               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    SHR             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    SHL             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    GREATER         reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    LESS            reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    OR              reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    AND             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    GREATEREQ       reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    LESSEQ          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    NOTEQ           reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    EQEQ            reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    PIPE            reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    ?               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    ]               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    ,               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    )               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    {               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    LET             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    NIL             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    FALSE           reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    TRUE            reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    STRING          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    FLOAT           reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    INT             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    (               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    !               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    ~               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    ID              reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    TYPEOF          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    LAMBDA          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    DEC             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    INC             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    CLASS           reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    STRUCT          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    IF              reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    FOR             reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    WHILE           reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    RETURN          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    FN              reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    IMPORT          reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    [               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    :               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)
    }               reduce using rule 67 (expr -> expr PIPE ID ( args ) .)


state 240

    (68) expr -> ID DOUBLECOLON ID ( args ) .
    SEP             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    %               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    /               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    *               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    -               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    +               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    |               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    ^               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    &               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    SHR             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    SHL             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    GREATER         reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    LESS            reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    OR              reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    AND             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    GREATEREQ       reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    LESSEQ          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    NOTEQ           reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    EQEQ            reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    PIPE            reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    ?               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    ]               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    ,               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    )               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    {               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    LET             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    NIL             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    FALSE           reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    TRUE            reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    STRING          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    FLOAT           reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    INT             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    (               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    !               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    ~               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    ID              reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    TYPEOF          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    LAMBDA          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    DEC             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    INC             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    CLASS           reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    STRUCT          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    IF              reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    FOR             reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    WHILE           reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    RETURN          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    FN              reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    IMPORT          reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    [               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    :               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)
    }               reduce using rule 68 (expr -> ID DOUBLECOLON ID ( args ) .)


state 241

    (74) struct_init_exprs -> struct_init_exprs , expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
    }               reduce using rule 74 (struct_init_exprs -> struct_init_exprs , expr .)
    ,               reduce using rule 74 (struct_init_exprs -> struct_init_exprs , expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 242

    (72) expr -> LAMBDA ( params ) ARROW expr .
    (45) expr -> expr . % expr
    (46) expr -> expr . / expr
    (47) expr -> expr . * expr
    (48) expr -> expr . - expr
    (49) expr -> expr . + expr
    (54) expr -> expr . | expr
    (55) expr -> expr . ^ expr
    (56) expr -> expr . & expr
    (57) expr -> expr . SHR expr
    (58) expr -> expr . SHL expr
    (59) expr -> expr . GREATER expr
    (60) expr -> expr . LESS expr
    (61) expr -> expr . OR expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . GREATEREQ expr
    (64) expr -> expr . LESSEQ expr
    (65) expr -> expr . NOTEQ expr
    (66) expr -> expr . EQEQ expr
    (67) expr -> expr . PIPE ID ( args )
    (70) expr -> expr . ? expr : expr
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    ]               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    ,               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    )               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    {               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    LET             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    NIL             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    FALSE           reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    TRUE            reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    STRING          reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    FLOAT           reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    INT             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    (               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    !               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    ~               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    ID              reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    TYPEOF          reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    LAMBDA          reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    DEC             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    INC             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    CLASS           reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    STRUCT          reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    IF              reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    FOR             reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    WHILE           reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    RETURN          reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    FN              reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    IMPORT          reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    [               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    :               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    }               reduce using rule 72 (expr -> LAMBDA ( params ) ARROW expr .)
    %               shift and go to state 48
    /               shift and go to state 49
    *               shift and go to state 50
    -               shift and go to state 51
    +               shift and go to state 52
    |               shift and go to state 53
    ^               shift and go to state 54
    &               shift and go to state 55
    SHR             shift and go to state 56
    SHL             shift and go to state 57
    GREATER         shift and go to state 58
    LESS            shift and go to state 59
    OR              shift and go to state 60
    AND             shift and go to state 61
    GREATEREQ       shift and go to state 62
    LESSEQ          shift and go to state 63
    NOTEQ           shift and go to state 64
    EQEQ            shift and go to state 65
    PIPE            shift and go to state 66
    ?               shift and go to state 67


state 243

    (21) struct_definition -> STRUCT ID { struct_fields } SEP .
    LET             reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    {               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    NIL             reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FALSE           reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    TRUE            reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    STRING          reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FLOAT           reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    INT             reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    (               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    !               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    +               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    -               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ~               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ID              reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    TYPEOF          reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    LAMBDA          reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    DEC             reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    INC             reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    CLASS           reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    STRUCT          reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    IF              reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FOR             reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    WHILE           reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    RETURN          reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FN              reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    IMPORT          reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    [               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    $end            reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    }               reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ELSE            reduce using rule 21 (struct_definition -> STRUCT ID { struct_fields } SEP .)


state 244

    (24) struct_field -> LET ID : . var_type SEP
    (25) var_type -> . DICT_TYPE
    (26) var_type -> . LIST_TYPE
    (27) var_type -> . BOOL_TYPE
    (28) var_type -> . STRING_TYPE
    (29) var_type -> . FLOAT_TYPE
    (30) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 184
    LIST_TYPE       shift and go to state 185
    BOOL_TYPE       shift and go to state 186
    STRING_TYPE     shift and go to state 187
    FLOAT_TYPE      shift and go to state 188
    INT_TYPE        shift and go to state 189

    var_type                       shift and go to state 247

state 245

    (95) for_statement -> FOR var_assign SEP expr SEP var_assign . block
    (103) block -> . statement
    (104) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . var_define SEP
    (9) statement -> . class_definition
    (10) statement -> . struct_definition
    (11) statement -> . if_statement
    (12) statement -> . for_statement
    (13) statement -> . while_statement
    (14) statement -> . return_statement
    (15) statement -> . function_definition
    (16) statement -> . import_statement
    (33) expr -> . getter
    (34) expr -> . { member_list }
    (35) expr -> . NIL
    (36) expr -> . var
    (37) expr -> . var [ expr ]
    (38) expr -> . list_val
    (39) expr -> . FALSE
    (40) expr -> . TRUE
    (41) expr -> . STRING
    (42) expr -> . FLOAT
    (43) expr -> . INT
    (44) expr -> . ( expr )
    (45) expr -> . expr % expr
    (46) expr -> . expr / expr
    (47) expr -> . expr * expr
    (48) expr -> . expr - expr
    (49) expr -> . expr + expr
    (50) expr -> . ! expr
    (51) expr -> . + expr
    (52) expr -> . - expr
    (53) expr -> . ~ expr
    (54) expr -> . expr | expr
    (55) expr -> . expr ^ expr
    (56) expr -> . expr & expr
    (57) expr -> . expr SHR expr
    (58) expr -> . expr SHL expr
    (59) expr -> . expr GREATER expr
    (60) expr -> . expr LESS expr
    (61) expr -> . expr OR expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr GREATEREQ expr
    (64) expr -> . expr LESSEQ expr
    (65) expr -> . expr NOTEQ expr
    (66) expr -> . expr EQEQ expr
    (67) expr -> . expr PIPE ID ( args )
    (68) expr -> . ID DOUBLECOLON ID ( args )
    (69) expr -> . ID ( args )
    (70) expr -> . expr ? expr : expr
    (71) expr -> . TYPEOF expr
    (72) expr -> . LAMBDA ( params ) ARROW expr
    (73) expr -> . ID LEFTARROW { struct_init_exprs }
    (79) var_assign -> . DEC var
    (80) var_assign -> . INC var
    (81) var_assign -> . var SHRASGN expr
    (82) var_assign -> . var SHLASGN expr
    (83) var_assign -> . var XORASGN expr
    (84) var_assign -> . var ORASGN expr
    (85) var_assign -> . var ANDASGN expr
    (86) var_assign -> . var MODULOASGN expr
    (87) var_assign -> . var SLASHASGN expr
    (88) var_assign -> . var STARASGN expr
    (89) var_assign -> . var MINUSASGN expr
    (90) var_assign -> . var PLUSASGN expr
    (91) var_assign -> . var ASSIGN expr
    (76) var_define -> . LET getter ASSIGN expr
    (77) var_define -> . LET var ASSIGN expr
    (17) class_definition -> . CLASS ID { function_definitions }
    (21) struct_definition -> . STRUCT ID { struct_fields } SEP
    (92) if_statement -> . IF expr block
    (93) if_statement -> . IF expr block ELSE block
    (95) for_statement -> . FOR var_assign SEP expr SEP var_assign block
    (94) while_statement -> . WHILE expr block
    (78) return_statement -> . RETURN expr SEP
    (32) function_definition -> . FN ID ( params ) block
    (31) import_statement -> . IMPORT STRING SEP
    (117) getter -> . ID
    (118) getter -> . getter . ID
    (100) var -> . var [ expr ]
    (101) var -> . ID
    (96) list_val -> . [ exprs ]
    {               shift and go to state 175
    LET             shift and go to state 7
    NIL             shift and go to state 20
    FALSE           shift and go to state 23
    TRUE            shift and go to state 24
    STRING          shift and go to state 25
    FLOAT           shift and go to state 26
    INT             shift and go to state 27
    (               shift and go to state 28
    !               shift and go to state 31
    +               shift and go to state 30
    -               shift and go to state 29
    ~               shift and go to state 32
    ID              shift and go to state 33
    TYPEOF          shift and go to state 34
    LAMBDA          shift and go to state 35
    DEC             shift and go to state 36
    INC             shift and go to state 37
    CLASS           shift and go to state 38
    STRUCT          shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    FN              shift and go to state 44
    IMPORT          shift and go to state 45
    [               shift and go to state 21

    var_assign                     shift and go to state 6
    expr                           shift and go to state 5
    block                          shift and go to state 248
    statement                      shift and go to state 174
    var                            shift and go to state 8
    var_define                     shift and go to state 9
    class_definition               shift and go to state 10
    struct_definition              shift and go to state 11
    if_statement                   shift and go to state 12
    for_statement                  shift and go to state 13
    while_statement                shift and go to state 14
    return_statement               shift and go to state 15
    function_definition            shift and go to state 16
    import_statement               shift and go to state 17
    getter                         shift and go to state 18
    list_val                       shift and go to state 22

state 246

    (32) function_definition -> FN ID ( params ) block .
    LET             reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    {               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    NIL             reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    FALSE           reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    TRUE            reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    STRING          reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    FLOAT           reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    INT             reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    (               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    !               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    +               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    -               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    ~               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    ID              reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    TYPEOF          reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    LAMBDA          reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    DEC             reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    INC             reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    CLASS           reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    STRUCT          reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    IF              reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    FOR             reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    WHILE           reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    RETURN          reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    FN              reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    IMPORT          reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    [               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    $end            reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    }               reduce using rule 32 (function_definition -> FN ID ( params ) block .)
    ELSE            reduce using rule 32 (function_definition -> FN ID ( params ) block .)


state 247

    (24) struct_field -> LET ID : var_type . SEP
    SEP             shift and go to state 249


state 248

    (95) for_statement -> FOR var_assign SEP expr SEP var_assign block .
    LET             reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    {               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    NIL             reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FALSE           reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    TRUE            reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    STRING          reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FLOAT           reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    INT             reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    (               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    !               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    +               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    -               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ~               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ID              reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    TYPEOF          reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    LAMBDA          reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    DEC             reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    INC             reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    CLASS           reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    STRUCT          reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    IF              reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FOR             reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    WHILE           reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    RETURN          reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    FN              reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    IMPORT          reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    [               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    $end            reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    }               reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)
    ELSE            reduce using rule 95 (for_statement -> FOR var_assign SEP expr SEP var_assign block .)


state 249

    (24) struct_field -> LET ID : var_type SEP .
    }               reduce using rule 24 (struct_field -> LET ID : var_type SEP .)
    LET             reduce using rule 24 (struct_field -> LET ID : var_type SEP .)


Conflicts:

shift/reduce conflict for ( in state 33 resolved as shift
shift/reduce conflict for ( in state 33 resolved as shift
shift/reduce conflict for [ in state 93 resolved as shift
shift/reduce conflict for % in state 102 resolved as shift
shift/reduce conflict for / in state 102 resolved as shift
shift/reduce conflict for * in state 102 resolved as shift
shift/reduce conflict for - in state 102 resolved as shift
shift/reduce conflict for + in state 102 resolved as shift
shift/reduce conflict for | in state 102 resolved as shift
shift/reduce conflict for ^ in state 102 resolved as shift
shift/reduce conflict for & in state 102 resolved as shift
shift/reduce conflict for SHR in state 102 resolved as shift
shift/reduce conflict for SHL in state 102 resolved as shift
shift/reduce conflict for GREATER in state 102 resolved as shift
shift/reduce conflict for LESS in state 102 resolved as shift
shift/reduce conflict for OR in state 102 resolved as shift
shift/reduce conflict for AND in state 102 resolved as shift
shift/reduce conflict for GREATEREQ in state 102 resolved as shift
shift/reduce conflict for LESSEQ in state 102 resolved as shift
shift/reduce conflict for NOTEQ in state 102 resolved as shift
shift/reduce conflict for EQEQ in state 102 resolved as shift
shift/reduce conflict for PIPE in state 102 resolved as shift
shift/reduce conflict for ? in state 102 resolved as shift
shift/reduce conflict for - in state 151 resolved as shift
shift/reduce conflict for + in state 151 resolved as shift
shift/reduce conflict for FN in state 169 resolved as shift
shift/reduce conflict for ELSE in state 171 resolved as shift
shift/reduce conflict for % in state 220 resolved as shift
shift/reduce conflict for / in state 220 resolved as shift
shift/reduce conflict for * in state 220 resolved as shift
shift/reduce conflict for - in state 220 resolved as shift
shift/reduce conflict for + in state 220 resolved as shift
shift/reduce conflict for | in state 220 resolved as shift
shift/reduce conflict for ^ in state 220 resolved as shift
shift/reduce conflict for & in state 220 resolved as shift
shift/reduce conflict for SHR in state 220 resolved as shift
shift/reduce conflict for SHL in state 220 resolved as shift
shift/reduce conflict for GREATER in state 220 resolved as shift
shift/reduce conflict for LESS in state 220 resolved as shift
shift/reduce conflict for OR in state 220 resolved as shift
shift/reduce conflict for AND in state 220 resolved as shift
shift/reduce conflict for GREATEREQ in state 220 resolved as shift
shift/reduce conflict for LESSEQ in state 220 resolved as shift
shift/reduce conflict for NOTEQ in state 220 resolved as shift
shift/reduce conflict for EQEQ in state 220 resolved as shift
shift/reduce conflict for PIPE in state 220 resolved as shift
shift/reduce conflict for ? in state 220 resolved as shift
shift/reduce conflict for % in state 242 resolved as shift
shift/reduce conflict for / in state 242 resolved as shift
shift/reduce conflict for * in state 242 resolved as shift
shift/reduce conflict for - in state 242 resolved as shift
shift/reduce conflict for + in state 242 resolved as shift
shift/reduce conflict for | in state 242 resolved as shift
shift/reduce conflict for ^ in state 242 resolved as shift
shift/reduce conflict for & in state 242 resolved as shift
shift/reduce conflict for SHR in state 242 resolved as shift
shift/reduce conflict for SHL in state 242 resolved as shift
shift/reduce conflict for GREATER in state 242 resolved as shift
shift/reduce conflict for LESS in state 242 resolved as shift
shift/reduce conflict for OR in state 242 resolved as shift
shift/reduce conflict for AND in state 242 resolved as shift
shift/reduce conflict for GREATEREQ in state 242 resolved as shift
shift/reduce conflict for LESSEQ in state 242 resolved as shift
shift/reduce conflict for NOTEQ in state 242 resolved as shift
shift/reduce conflict for EQEQ in state 242 resolved as shift
shift/reduce conflict for PIPE in state 242 resolved as shift
shift/reduce conflict for ? in state 242 resolved as shift
reduce/reduce conflict in state 33 resolved using rule var -> ID
rejected rule (getter -> ID) in state 33
reduce/reduce conflict in state 71 resolved using rule var -> ID
rejected rule (getter -> ID) in state 71
reduce/reduce conflict in state 193 resolved using rule expr -> var [ expr ]
rejected rule (var -> var [ expr ]) in state 193
reduce/reduce conflict in state 212 resolved using rule expr -> - expr  [precedence=right, level=12]
rejected rule (expr -> expr - expr  [precedence=left, level=10]) in state 212
reduce/reduce conflict in state 213 resolved using rule expr -> + expr  [precedence=right, level=12]
rejected rule (expr -> expr + expr  [precedence=left, level=10]) in state 213
reduce/reduce conflict in state 215 resolved using rule program -> empty
rejected rule (member_list -> empty) in state 215